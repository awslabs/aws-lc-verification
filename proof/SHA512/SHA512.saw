enable_experimental;

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";


/*
 * SHA512 defines
 */
let SHA512_CBLOCK = 128;
let SHA512_CTX_SIZE = eval_int {{ (64 + 8 + 8 + `SHA512_CBLOCK + 4 + 4) : [64] }};


/*
 * SAW helpers
 */
let alloc_init ty v = do {
  p <- crucible_alloc ty;
  crucible_points_to p v;
  return p;
};

let alloc_init_readonly ty v = do {
  p <- crucible_alloc_readonly ty;
  crucible_points_to p v;
  return p;
};

let ptr_to_fresh n ty = do {
  x <- crucible_fresh_var n ty;
  p <- alloc_init ty (crucible_term x);
  return (x, p);
};

let ptr_to_fresh_readonly n ty = do {
  x <- crucible_fresh_var n ty;
  p <- alloc_init_readonly ty (crucible_term x);
  return (x, p);
};

let global_points_to n v = do {
  crucible_points_to (crucible_global n) (crucible_term v);
};

let global_alloc_init n v = do {
  crucible_alloc_global n;
  global_points_to n v;
};


////////////////////////////////////////////////////////////////////////////////
// Specifications

/*
 * Specification of OPENSSL memory management functions
 */
let OPENSSL_malloc_spec size = do {
  crucible_execute_func [crucible_term {{ `size : [64] }}];
  ptr <- crucible_alloc_aligned 128 (llvm_array size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_free_nonnull_spec size = do {
  ptr <- crucible_alloc (llvm_array size (llvm_int 8));
  crucible_execute_func [ptr];
};

let OPENSSL_free_null_spec = do {
  crucible_execute_func [crucible_null];
};

let OPENSSL_cleanse_spec len = do {
  ptr <- crucible_alloc (llvm_array len (llvm_int 8));
  crucible_execute_func [ptr, crucible_term {{ `len : [64] }}];
  crucible_points_to ptr (crucible_term {{ zero : [len][8] }});
};


/*
 * Architecture features for the AVX+shrd code path
 */
let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};


/*
 * Specification of block function for SHA512
 */
let sha512_block_data_order_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  (state, state_ptr) <- ptr_to_fresh "state" (llvm_array 8 (llvm_int 64));

  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array SHA512_CBLOCK (llvm_int 8));

  crucible_execute_func [state_ptr, data_ptr, crucible_term {{ 1 : [64] }}];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  crucible_points_to state_ptr (crucible_term {{ SHA512Block state (split (join data)) }});
};


/*
 * Helpers for specifying the SHA512 structs
 */
let fresh_sha512_state_st name n = do {
  h <- crucible_fresh_var (str_concat name ".h") (llvm_array 8 (llvm_int 64));
  block <- crucible_fresh_var (str_concat name ".block") (llvm_array n (llvm_int 8));
  sz <- crucible_fresh_var (str_concat name ".sz") (llvm_int 128);
  return {{ { h = h, block = (block # zero) : [128][8], n = `n : [32], sz = sz } }};
};

// Specify the sha512_state_st struct
let points_to_sha512_state_st ptr state num = do {
  crucible_points_to (crucible_field ptr "h") (crucible_term {{ state.h }});
  crucible_points_to (crucible_field ptr "Nl") (crucible_term {{ drop`{64} state.sz }});
  crucible_points_to (crucible_field ptr "Nh") (crucible_term {{ take`{64} state.sz }});
  if eval_bool {{ `num == 0 }} then do {
    return ();
  } else do {
    crucible_points_to_untyped (crucible_field ptr "p") (crucible_term {{ take`{num} state.block }});
  };
  crucible_points_to (crucible_field ptr "num") (crucible_term {{ state.n }});
  crucible_points_to (crucible_field ptr "md_len") (crucible_term {{ `SHA_DIGEST_LENGTH : [32] }});
};

// Specify the env_md_st struct for SHA512
let points_to_env_md_st ptr = do {
  crucible_points_to (crucible_field ptr "type") (crucible_term {{ `NID : [32] }});
  crucible_points_to (crucible_field ptr "md_size") (crucible_term {{ `SHA_DIGEST_LENGTH : [32] }});
  crucible_points_to (crucible_field ptr "flags") (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "init") (crucible_global SHA_INIT);
  crucible_points_to (crucible_field ptr "update") (crucible_global SHA_UPDATE);
  crucible_points_to (crucible_field ptr "final") (crucible_global SHA_FINAL);
  crucible_points_to (crucible_field ptr "block_size") (crucible_term {{ `SHA512_CBLOCK : [32] }});
  crucible_points_to (crucible_field ptr "ctx_size") (crucible_term {{ `SHA512_CTX_SIZE : [32] }});
};

// Specify the env_md_ctx_st struct
let points_to_env_md_ctx_st ptr digest_ptr md_data_ptr = do {
  crucible_points_to (crucible_field ptr "digest") digest_ptr;
  crucible_points_to (crucible_field ptr "md_data") md_data_ptr;
  crucible_points_to (crucible_field ptr "pctx") crucible_null;
  crucible_points_to (crucible_field ptr "pctx_ops") crucible_null;
};

// Specification of EVP_sha512_init and EVP_sha384_init, the initialization
// functions for EVP_sha512_storage and EVP_sha384_storage respectively
let EVP_sha_init_spec = do {
  crucible_alloc_global EVP_SHA_STORAGE;
  crucible_execute_func [];
  points_to_env_md_st (crucible_global EVP_SHA_STORAGE);
};


/*
 * Specifications of EVP_Digest, EVP_DigestInit, EVP_DigestUpdate, and
 * EVP_DigestFinal functions for SHA512.
 */
let EVP_DigestInit_spec = do {
  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");
  type_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st type_ptr;

  crucible_execute_func [ctx_ptr, type_ptr];

  sha512_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  points_to_sha512_state_st
    sha512_ctx_ptr
    {{ { h = SHA_H0, block = zero : [128][8], n = 0 : [32], sz = 0 : [128] } }}
    0;
  points_to_env_md_ctx_st ctx_ptr type_ptr sha512_ctx_ptr;
  crucible_return (crucible_term {{ 1 : [32] }});
};


let EVP_DigestUpdate_spec num len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  sha512_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  sha512_ctx <- fresh_sha512_state_st "sha512_ctx" num;
  points_to_sha512_state_st sha512_ctx_ptr sha512_ctx num;

  points_to_env_md_ctx_st ctx_ptr digest_ptr sha512_ctx_ptr;

  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array len (llvm_int 8));

  crucible_execute_func [ctx_ptr, data_ptr, crucible_term {{ `len : [64] }}];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  points_to_sha512_state_st sha512_ctx_ptr {{ SHA512Update sha512_ctx data }} (eval_int {{ `((num + len) % SHA512_CBLOCK ) : [64]}});

  points_to_env_md_ctx_st ctx_ptr digest_ptr sha512_ctx_ptr;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let EVP_DigestFinal_spec num = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  md_out_ptr <- crucible_alloc (llvm_array SHA_DIGEST_LENGTH (llvm_int 8));

  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  sha512_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  sha512_ctx <- fresh_sha512_state_st "sha512_ctx" num;
  points_to_sha512_state_st sha512_ctx_ptr sha512_ctx num;

  points_to_env_md_ctx_st ctx_ptr digest_ptr sha512_ctx_ptr;

  crucible_execute_func [ctx_ptr, md_out_ptr, crucible_null];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  crucible_points_to md_out_ptr (crucible_term {{ reverse (split`{SHA_DIGEST_LENGTH} (join (reverse (split`{each=64} (SHA_FINAL_SPEC sha512_ctx))))) }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

let EVP_Digest_spec len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array len (llvm_int 8));

  md_out_ptr <- crucible_alloc (llvm_array SHA_DIGEST_LENGTH (llvm_int 8));

  type_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st type_ptr;

  crucible_execute_func
    [ data_ptr
    , crucible_term {{ `len : [64] }}
    , md_out_ptr
    , crucible_null
    , type_ptr
    , crucible_null
    ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  crucible_points_to md_out_ptr (crucible_term {{ reverse (split`{SHA_DIGEST_LENGTH} (join (reverse (split`{each=64} (SHA_IMP_SPEC data))))) }});

  crucible_return (crucible_term {{ 1 : [32] }});
};


////////////////////////////////////////////////////////////////////////////////
// Proof commands

OPENSSL_malloc_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec SHA512_CTX_SIZE);

OPENSSL_free_nonnull_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  (OPENSSL_free_nonnull_spec SHA512_CTX_SIZE);

OPENSSL_free_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  OPENSSL_free_null_spec;

OPENSSL_cleanse_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_cleanse"
  (OPENSSL_cleanse_spec SHA512_CTX_SIZE);


let bvShl3  = parse_core "\\(x : bitvector 64) -> bvShl 64 x 3";
let bvShl7  = parse_core "\\(x : bitvector 64) -> bvShl 64 x 7";
let bvShl42 = parse_core "\\(x : bitvector 64) -> bvShl 64 x 42";
let bvShl56 = parse_core "\\(x : bitvector 64) -> bvShl 64 x 56";

let bvShr1  = parse_core "\\(x : bitvector 64) -> bvShr 64 x 1";
let bvShr7  = parse_core "\\(x : bitvector 64) -> bvShr 64 x 7";
let bvShr6  = parse_core "\\(x : bitvector 64) -> bvShr 64 x 6";
let bvShr19 = parse_core "\\(x : bitvector 64) -> bvShr 64 x 19";
let bvShr42 = parse_core "\\(x : bitvector 64) -> bvShr 64 x 42";

let slice_8_56_0  = parse_core "\\(x : bitvector 64) -> slice Bool 8 56 0 x";
let slice_0_8_56  = parse_core "\\(x : bitvector 64) -> slice Bool 0 8 56 x";
let slice_36_28_0 = parse_core "\\(x : bitvector 64) -> slice Bool 36 28 0 x";
let slice_0_36_28 = parse_core "\\(x : bitvector 64) -> slice Bool 0 36 28 x";
let slice_41_23_0 = parse_core "\\(x : bitvector 64) -> slice Bool 41 23 0 x";
let slice_0_41_23 = parse_core "\\(x : bitvector 64) -> slice Bool 0 41 23 x";
let slice_50_14_0 = parse_core "\\(x : bitvector 64) -> slice Bool 50 14 0 x";
let slice_0_50_14 = parse_core "\\(x : bitvector 64) -> slice Bool 0 50 14 x";
let slice_58_6_0  = parse_core "\\(x : bitvector 64) -> slice Bool 58 6 0 x";
let slice_0_58_6  = parse_core "\\(x : bitvector 64) -> slice Bool 0 58 6 x";
let slice_59_5_0  = parse_core "\\(x : bitvector 64) -> slice Bool 59 5 0 x";
let slice_0_59_5  = parse_core "\\(x : bitvector 64) -> slice Bool 0 59 5 x";
let slice_60_4_0  = parse_core "\\(x : bitvector 64) -> slice Bool 60 4 0 x";
let slice_0_60_4  = parse_core "\\(x : bitvector 64) -> slice Bool 0 60 4 x";


let prove_folding_theorem t = prove_print abc (rewrite (cryptol_ss ()) t);

rotate8_thm  <- prove_folding_theorem {{ \x -> (slice_8_56_0  x) # (slice_0_8_56  x) == x <<<  8 }};
rotate36_thm <- prove_folding_theorem {{ \x -> (slice_36_28_0 x) # (slice_0_36_28 x) == x <<< 36 }};
rotate41_thm <- prove_folding_theorem {{ \x -> (slice_41_23_0 x) # (slice_0_41_23 x) == x <<< 41 }};
rotate50_thm <- prove_folding_theorem {{ \x -> (slice_50_14_0 x) # (slice_0_50_14 x) == x <<< 50 }};
rotate58_thm <- prove_folding_theorem {{ \x -> (slice_58_6_0  x) # (slice_0_58_6  x) == x <<< 58 }};
rotate59_thm <- prove_folding_theorem {{ \x -> (slice_59_5_0  x) # (slice_0_59_5  x) == x <<< 59 }};
rotate60_thm <- prove_folding_theorem {{ \x -> (slice_60_4_0  x) # (slice_0_60_4  x) == x <<< 60 }};

rotate59_slice_add_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50) <<< 59
  }};

rotate59_slice_add_1_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54) <<< 59
  }};

rotate59_slice_add_2_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58) <<< 59
  }};

rotate59_slice_add_3_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 + x61 + x62))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 + x61 + x62))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 + x61 + x62) <<< 59
  }};

xor_append_64_64_thm <- prove_folding_theorem
  {{ \(x : [64]) (y : [64]) u v -> (x # y) ^ (u # v) == (x ^ u) # (y ^ v) }};

Sigma0_thm   <- prove_folding_theorem {{ \x -> (x ^ ((x ^ (x <<< 59)) <<< 58)) <<< 36 == S0 x }};
Sigma0_1_thm <- prove_folding_theorem {{ \x -> ((((x <<< 59) ^ x) <<< 58) ^ x) <<< 36 == S0 x }};
Sigma1_thm   <- prove_folding_theorem {{ \x -> (x ^ ((x ^ (x <<< 41)) <<< 60)) <<< 50 == S1 x }};
Sigma1_1_thm <- prove_folding_theorem {{ \x -> ((((x <<< 41) ^ x) <<< 60) ^ x) <<< 50 == S1 x }};
sigma0_thm <- prove_folding_theorem
  {{ \x -> (bvShr1 x) ^ (bvShr7 x) ^ (bvShl56 x) ^ (bvShr7 (bvShr1 x)) ^ (bvShl7 (bvShl56 x)) == s0 x }};
sigma1_thm <- prove_folding_theorem
  {{ \x -> (bvShr6 x) ^ (bvShl3 x) ^ (bvShr19 x) ^ (bvShl42 (bvShl3 x)) ^ (bvShr42 (bvShr19 x)) == s1 x }};

Ch_thm   <- prove_folding_theorem {{ \x y z -> z ^ (x && (z ^ y)) == Ch x y z }};
Ch_1_thm <- prove_folding_theorem {{ \x y z -> z ^ (x && (y ^ z)) == Ch x y z }};
Ch_2_thm <- prove_folding_theorem {{ \x y z -> z ^ ((y ^ z) && x) == Ch x y z }};
Ch_3_thm <- prove_folding_theorem {{ \x y z -> z ^ ((y ^ z) && x) == Ch x y z }};
Ch_4_thm <- prove_folding_theorem {{ \x y z -> ((y ^ z) && x) ^ z == Ch x y z }};
Ch_5_thm <- prove_folding_theorem {{ \x y z -> ((z ^ y) && x) ^ z == Ch x y z }};
Ch_6_thm <- prove_folding_theorem {{ \x y z -> (x && (y ^ z)) ^ z == Ch x y z }};
Ch_7_thm <- prove_folding_theorem {{ \x y z -> (x && (z ^ y)) ^ z == Ch x y z }};

Maj_thm   <- prove_folding_theorem {{ \x y z -> Ch (x ^ y) z y == Maj x y z }};
Maj_1_thm <- prove_folding_theorem {{ \x y z -> Ch (y ^ x) z y == Maj x y z }};

let bvult = parse_core "\\(x y : bitvector 64) -> bvult 64 x y";
// replace (bvult x y) with (x - y <$ 0) in order for the semiring and abstract domain to work
cmp_sub_thm <- prove_folding_theorem
  {{ \x y -> bvult x y == if (x @ 0 == y @ 0) then (x - y <$ 0) else (x @ 0 < y @ 0) }};

let thms =
  [ rotate8_thm
  , rotate36_thm
  , rotate41_thm
  , rotate50_thm
  , rotate58_thm
  , rotate59_thm
  , rotate60_thm
  , rotate59_slice_add_thm
  , rotate59_slice_add_1_thm
  , rotate59_slice_add_2_thm
  , rotate59_slice_add_3_thm
  , xor_append_64_64_thm
  , Sigma0_thm
  , Sigma0_1_thm
  , Sigma1_thm
  , Sigma1_1_thm
  , sigma0_thm
  , sigma1_thm
  , Ch_thm
  , Ch_1_thm
  , Ch_2_thm
  , Ch_3_thm
  , Ch_4_thm
  , Ch_5_thm
  , Ch_6_thm
  , Ch_7_thm
  , Maj_thm
  , Maj_1_thm
  , cmp_sub_thm
  ];

concat_assoc_thm <- prove_folding_theorem
  {{ \(x0 : [8]) (x1 : [8]) (x2 : [8]) (x3 : [8]) (x4 : [8]) (x5 : [8]) (x6 : [8]) (x7 : [8]) -> x0 # (x1 # (x2 # (x3 # (x4 # (x5 # (x6 # x7)))))) == (((((((x0 # x1) # x2) # x3) # x4) # x5) # x6) # x7) }};


enable_what4_hash_consing;

sha512_block_data_order_spec <- crucible_llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "sha512_block_data_order"
  [ ("K512", 5120) // immutable constants
  ]
  true
  sha512_block_data_order_spec
  (do {
    simplify (cryptol_ss ());
    simplify (addsimps thms empty_ss);
    simplify (addsimp concat_assoc_thm empty_ss);
    w4_unint_yices ["S0", "S1", "s0", "s1", "Ch"];
  });

disable_what4_hash_consing;


crucible_llvm_verify m EVP_SHA_INIT [] true EVP_sha_init_spec (w4_unint_yices []);


crucible_llvm_verify m "EVP_DigestInit"
  [ OPENSSL_malloc_ov
  , OPENSSL_free_null_ov
  ]
  true
  EVP_DigestInit_spec
  (w4_unint_yices []);

crucible_llvm_verify m "EVP_DigestUpdate"
  [sha512_block_data_order_spec]
  true
  // num=0, len=240 covers the case with one call to the block function,
  // on one block from data, and the rest of data copied in c->data
  (EVP_DigestUpdate_spec 0 240)
  (w4_unint_yices ["SHA512Block"]);
crucible_llvm_verify m "EVP_DigestUpdate"
  [sha512_block_data_order_spec]
  true
  // num=0, len=127 covers the case without any calls to the block function,
  // and data copied in c->data
  (EVP_DigestUpdate_spec 0 127)
  (w4_unint_yices ["SHA512Block"]);
crucible_llvm_verify m "EVP_DigestUpdate"
  [sha512_block_data_order_spec]
  true
  // num=127, len=241 covers the case with two calls to the block function,
  // the first one on c->data, the second one on one block from data,
  // and the rest of data copied in c->data
  (EVP_DigestUpdate_spec 127 241)
  (w4_unint_yices ["SHA512Block"]);

crucible_llvm_verify m "EVP_DigestFinal"
  [ sha512_block_data_order_spec
  , OPENSSL_free_nonnull_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // num=111 covers the case with one call to the block function
  (EVP_DigestFinal_spec 111)
  (w4_unint_yices ["SHA512Block"]);
crucible_llvm_verify m "EVP_DigestFinal"
  [ sha512_block_data_order_spec
  , OPENSSL_free_nonnull_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // num=112 covers the case with two calls to the block function
  (EVP_DigestFinal_spec 112)
  (w4_unint_yices ["SHA512Block"]);

crucible_llvm_verify m "EVP_Digest"
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ]
  true
  (EVP_Digest_spec 240)
  (w4_unint_yices ["SHA512Block"]);

