enable_experimental;

// Load LLVM bytecode
m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";


/*
 * SAW helpers
 */
// Given a value `v` of type `ty`, allocates and returns a pointer to memory
// storing `v`
let alloc_init ty v = do {
  p <- crucible_alloc ty;
  crucible_points_to p v;
  return p;
};

// Given a value `v` of type `ty`, allocates and returns a read only pointer to
// memory storing `v`
let alloc_init_readonly ty v = do {
  p <- crucible_alloc_readonly ty;
  crucible_points_to p v;
  return p;
};

// Given a name `n` and a type `ty`, allocates a fresh variable `x` of type
// `ty` and returns a tuple of `x` and a pointer to `x`.
let ptr_to_fresh n ty = do {
  x <- crucible_fresh_var n ty;
  p <- alloc_init ty (crucible_term x);
  return (x, p);
};

// Given a name `n` and a type `ty`, allocates a fresh variable `x` of type
// `ty` and returns a tuple of `x` and a read only pointer to `x`.
let ptr_to_fresh_readonly n ty = do {
  x <- crucible_fresh_var n ty;
  p <- alloc_init_readonly ty (crucible_term x);
  return (x, p);
};

let global_points_to n v = do {
  crucible_points_to (crucible_global n) (crucible_term v);
};

let global_alloc_init n v = do {
  crucible_alloc_global n;
  global_points_to n v;
};


////////////////////////////////////////////////////////////////////////////////
// Specifications

/*
 * This section of the SAW script contains specifications of the functions that
 * SAW will verify.  Each specification can be broken down into 3 components:
 * preconditions, a function call description, and postconditions.
 *
 * A precondition is a predicate that must be true prior to the application of
 * a function for the specification's postcondition to hold.  Preconditions are
 * typically restrictions on function inputs or global state.  For example, a
 * function that returns the first element of an array might have a
 * precondition that the array is not empty.  A specification makes no
 * guarantees about how the function acts when the precondition is violated.
 * In a SAW specification, preconditions are the statements that come before a
 * function call description.  If a function has no preconditions we say that
 * the precondition is "true", meaning that the postcondition holds for all
 * possible inputs and program states.
 *
 * A function call description tells SAW how to call the function being
 * specified.  It has the form:
 *     crucible_execute_func [<list of arguments>]
 * These arguments are typically from the preconditions, specification inputs,
 * global variables, and literals.  SAW does not actually execute the function,
 * but rather uses symbolic execution to examine all possible executions
 * through the function, subject to precondition constraints.  For example,
 * if a precondition states that a variable `ctx_ptr` is a pointer to an
 * `env_md_ctx_st` struct:
 *     ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");
 * And the function call description takes `ctx_ptr` as an input:
 *     crucible_execute_func [ctx_ptr];
 * Then SAW will reason about the function over all possible `env_md_ctx_st`
 * structs.  We call `ctx_ptr` a symbol because SAW does not evaluate it, but
 * rather treats it as the set of all possible `env_md_ctx_st` structs.
 *
 * A postcondition is a predicate that must be true following the application
 * of a function, assuming the function's precondition held.  From a logic
 * perspective, you can think of this as:
 *     (<conjunction of preconditions> /\ <function application>) ->
 *     <conjunction of postconditions>
 * where "/\" is logical AND and "->" is logical implication.  If a SAW proof
 * succeeds, then SAW guarantees that the postconditions hold following function
 * application, so long as the function's preconditions held just prior to the
 * function's application.  In a SAW specification, postconditions are the
 * statements that come after a function call description.  If a function has
 * no postconditions, then we say that the postcondition is "true", meaning
 * that the specification makes no guarantees about the function's behavior.
 */

/*
 * Specification of OPENSSL memory management functions
 */
let OPENSSL_malloc_spec size = do {
  // Precondition: true

  // Call function with argument `size`.
  // `crucible_term` converts `size` to a symbol so that SAW may reason about
  // it during symbolic execution.  This line also contains a type annotation
  // on `size` to declare that it is a 64 bit integer.  This is necessary
  // because SAW integers are unbounded, but the function expects a 64 bit
  // value so the spec must explicitly convert the unbounded SAW integer to a
  // 64 bit value.
  crucible_execute_func [crucible_term {{ `size : [64] }}];

  // Postcondition: returns a pointer to a 128 byte aligned array of `size`
  // bytes
  ptr <- crucible_alloc_aligned 128 (llvm_array size (llvm_int 8));
  crucible_return ptr;
};

let OPENSSL_free_nonnull_spec size = do {
  // Precondition: `ptr` is a pointer to an array of `size` bytes
  ptr <- crucible_alloc (llvm_array size (llvm_int 8));

  // Call function with argument `ptr`
  crucible_execute_func [ptr];

  // Postcondition: true
};

let OPENSSL_free_null_spec = do {
  // Precondition: true

  // Call function with NULL as the argument
  crucible_execute_func [crucible_null];

  // Postcondition: true
};

let OPENSSL_cleanse_spec len = do {
  // Precondition: `ptr` is a pointer to an array of `len` bytes
  ptr <- crucible_alloc (llvm_array len (llvm_int 8));

  // Call function with arguments `ptr` and `len`
  crucible_execute_func [ptr, crucible_term {{ `len : [64] }}];

  // Postcondition: Data pointed to by `ptr` has been zeroed out
  crucible_points_to ptr (crucible_term {{ zero : [len][8] }});
};


/*
 * SHA512 defines
 */
// Size of a block in bytes
let SHA512_CBLOCK = 128;

// Size of the SHA512 context struct
let SHA512_CTX_SIZE = eval_int {{ (64 + 8 + 8 + `SHA512_CBLOCK + 4 + 4) : [64] }};


/*
 * Architecture features for the AVX+shrd code path
 */
let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};


/*
 * Specification of block function for SHA512
 */
let sha512_block_data_order_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `state_ptr` points to an array of 8 64 bit integers
  (state, state_ptr) <- ptr_to_fresh "state" (llvm_array 8 (llvm_int 64));

  // Precondition: `data_ptr` points to a const message block
  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array SHA512_CBLOCK (llvm_int 8));

  // Call function with `state_ptr`, `data_ptr`, and the value `1`
  crucible_execute_func [state_ptr, data_ptr, crucible_term {{ 1 : [64] }}];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The data pointed to by `state_ptr` is equivalent to the
  // return value of the SHA512Block Cryptol spec function applied to `state`
  // and `data`.
  crucible_points_to state_ptr (crucible_term {{ SHA512Block state (split (join data)) }});
};


/*
 * Helpers for specifying the SHA512 structs
 */
// Create a Cryptol SHA512State
let fresh_sha512_state_st name n = do {
  // Hash value
  h <- crucible_fresh_var (str_concat name ".h") (llvm_array 8 (llvm_int 64));
  // Message block
  block <- crucible_fresh_var (str_concat name ".block") (llvm_array n (llvm_int 8));
  // Size
  sz <- crucible_fresh_var (str_concat name ".sz") (llvm_int 128);
  // Build SHA512State, padding `block` with zeros to fit
  return {{ { h = h, block = (block # zero) : [128][8], n = `n : [32], sz = sz } }};
};

/*
 * The next three functions all specify structs used in the C SHA
 * implementation.  Most of the statements in these are of the form:
 *    crucible_points_to (crucible_field ptr "name") (crucible_term {{ term }})
 * which indicates that the field `name` of the struct pointed to by `ptr`
 * contains the value `term`.  Some have the form:
 *    crucible_points_to (crucible_field ptr "name") (crucible_global GLOBAL)
 * which indicates that the field `name` of the struct pointed to by `ptr`
 * contains the value of the global variable `GLOBAL`.
 * All statements that do not match these two forms are documented inline
 */
// Specify the sha512_state_st struct from a SHA512State
let points_to_sha512_state_st ptr state num = do {
  crucible_points_to (crucible_field ptr "h") (crucible_term {{ state.h }});

  // Specify `sha512_state_st.Nl` contains last 64 bits of `state.sz`
  crucible_points_to (crucible_field ptr "Nl") (crucible_term {{ drop`{64} state.sz }});

  // Specify `sha512_state_st.Nh` contains first 64 bits of `state.sz`
  crucible_points_to (crucible_field ptr "Nh") (crucible_term {{ take`{64} state.sz }});

  if eval_bool {{ `num == 0 }} then do {
    // Do not specify anything about `sha512_state_st.p`
    return ();
  } else do {
    // Specify that the first `num` bytes of `sha512_state_st.p` match the
    // first `num` bits of `state.block`.
    // Untypted check because the size of `sha512_state_st.p` does not match
    // the size of (take`{num} state.block) unless `num` == `SHA512_CBLOCK`
    crucible_points_to_untyped (crucible_field ptr "p") (crucible_term {{ take`{num} state.block }});
  };

  crucible_points_to (crucible_field ptr "num") (crucible_term {{ state.n }});
  crucible_points_to (crucible_field ptr "md_len") (crucible_term {{ `SHA_DIGEST_LENGTH : [32] }});
};

// Specify the env_md_st struct
let points_to_env_md_st ptr = do {
  crucible_points_to (crucible_field ptr "type") (crucible_term {{ `NID : [32] }});
  crucible_points_to (crucible_field ptr "md_size") (crucible_term {{ `SHA_DIGEST_LENGTH : [32] }});
  crucible_points_to (crucible_field ptr "flags") (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "init") (crucible_global SHA_INIT);
  crucible_points_to (crucible_field ptr "update") (crucible_global SHA_UPDATE);
  crucible_points_to (crucible_field ptr "final") (crucible_global SHA_FINAL);
  crucible_points_to (crucible_field ptr "block_size") (crucible_term {{ `SHA512_CBLOCK : [32] }});
  crucible_points_to (crucible_field ptr "ctx_size") (crucible_term {{ `SHA512_CTX_SIZE : [32] }});
};

// Specify the env_md_ctx_st struct
let points_to_env_md_ctx_st ptr digest_ptr md_data_ptr = do {
  crucible_points_to (crucible_field ptr "digest") digest_ptr;
  crucible_points_to (crucible_field ptr "md_data") md_data_ptr;

  // Specify that the `pctx` and `pctx_ops` fields are null
  crucible_points_to (crucible_field ptr "pctx") crucible_null;
  crucible_points_to (crucible_field ptr "pctx_ops") crucible_null;
};

// Specification of EVP_sha512_init and EVP_sha384_init, the initialization
// functions for EVP_sha512_storage and EVP_sha384_storage respectively
let EVP_sha_init_spec = do {
  // Precondition: The global variable `EVP_SHA_STORAGE` exists
  crucible_alloc_global EVP_SHA_STORAGE;

  // Call function with no arguments
  crucible_execute_func [];

  // Postcondition: `EVP_SHA_STORAGE` global variable satisfies the
  // `points_to_env_md_st` specification
  points_to_env_md_st (crucible_global EVP_SHA_STORAGE);
};


/*
 * Specifications of EVP_Digest, EVP_DigestInit, EVP_DigestUpdate, and
 * EVP_DigestFinal functions for SHA512.
 */
let EVP_DigestInit_spec = do {
  // Precondition: `ctx_ptr` is a pointer to an `env_md_ctx_st` struct
  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  // Precondition: `type_ptr` is a pointer to a const `env_md_ctx_st` struct
  // satisfying the `points_to_env_md_st` specification
  type_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st type_ptr;

  // Call function with `ctx_ptr` and `type_ptr`
  crucible_execute_func [ctx_ptr, type_ptr];

  // Postcondition: `ctx_ptr->digest == type_ptr` and `ctx_ptr->md_data`
  // holds an initialized SHA512 context
  sha512_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  points_to_sha512_state_st
    sha512_ctx_ptr
    {{ { h = SHA_H0, block = zero : [128][8], n = 0 : [32], sz = 0 : [128] } }}
    0;
  points_to_env_md_ctx_st ctx_ptr type_ptr sha512_ctx_ptr;

  // Postcondition: The function returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};


let EVP_DigestUpdate_spec num len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `ctx_ptr` is a pointer to an `env_md_ctx_st` struct
  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  // Precondition: `digest_ptr` is a pointer to a const `env_md_st` struct
  // satisfying the `points_to_env_md_st` specification
  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  // Precondition: `sha512_ctx_ptr` is a pointer to a `sha512_state_st` struct
  sha512_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  // Precondition: `sha512_ctx` is a fresh Cryptol SHA512State
  sha512_ctx <- fresh_sha512_state_st "sha512_ctx" num;
  // Precondition: `sha512_ctx_ptr` matches `sha512_ctx`.  The message blocks
  // of the two must only match up to the first `num` bits
  points_to_sha512_state_st sha512_ctx_ptr sha512_ctx num;

  // Precondition: Struct pointed to by `ctx_ptr` points to `digest_ptr` and
  // `sha512_ctx_ptr`.
  points_to_env_md_ctx_st ctx_ptr digest_ptr sha512_ctx_ptr;

  // Precondition: `data` is a fresh array of `len` bytes, and `data_ptr`
  // points to `data`.
  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array len (llvm_int 8));

  // Call function with `ctx_ptr`, `data_ptr`, and `len` as arguments.
  crucible_execute_func [ctx_ptr, data_ptr, crucible_term {{ `len : [64] }}];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The context `sha512_ctx_ptr` points to matches the result
  // of executing the cryptol function `SHA512Update` on `sha512_ctx` and
  // `data`, with the exception of the message block, which must only match up
  // to the first `(num + len) % SHA512_CBLOCK` bytes.  This is because the
  // C implementation does not clear the unused bytes of message block, and
  // therefore the tail end of the block contains garbage.
  points_to_sha512_state_st sha512_ctx_ptr {{ SHA512Update sha512_ctx data }} (eval_int {{ `((num + len) % SHA512_CBLOCK ) : [64]}});

  // Postcondition: Struct pointed to by `ctx_ptr` points to `digest_ptr` and
  // `sha512_ctx_ptr`.
  points_to_env_md_ctx_st ctx_ptr digest_ptr sha512_ctx_ptr;

  // Postcondition: The function returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

let EVP_DigestFinal_spec num = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `md_out_ptr` points to an array of `SHA_DIGEST_LENGTH` bytes
  md_out_ptr <- crucible_alloc (llvm_array SHA_DIGEST_LENGTH (llvm_int 8));

  // Precondition: `ctx_ptr` points to an `env_md_ctx_st` struct
  ctx_ptr <- crucible_alloc (llvm_struct "struct.env_md_ctx_st");

  // Precondition: `digest_ptr` points to a const `env_md_st` struct satisfying
  // the `digest_ptr` specification.
  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  // Precondition: `sha512_ctx_ptr` is a pointer to a `sha512_state_st` struct
  sha512_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  // Precondition: `sha512_ctx` is a fresh Cryptol SHA512State
  sha512_ctx <- fresh_sha512_state_st "sha512_ctx" num;
  // Precondition: `sha512_ctx_ptr` matches `sha512_ctx`.  The message blocks
  // of the two must only match up to the first `num` bits
  points_to_sha512_state_st sha512_ctx_ptr sha512_ctx num;

  // Precondition: Struct pointed to by `ctx_ptr` points to `digest_ptr` and
  // `sha512_ctx_ptr`.
  points_to_env_md_ctx_st ctx_ptr digest_ptr sha512_ctx_ptr;

  // Call function with `ctx_ptr`, `md_out_ptr`, and NULL
  crucible_execute_func [ctx_ptr, md_out_ptr, crucible_null];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The data pointed to by `md_out_ptr` matches the message
  // digest returned by the Cryptol function `SHA_FINAL_SPEC`.  The reverses,
  // splits, and joins transform the Cryptol function's big endian output to
  // little endian.
  crucible_points_to md_out_ptr (crucible_term {{ reverse (split`{SHA_DIGEST_LENGTH} (join (reverse (split`{each=64} (SHA_FINAL_SPEC sha512_ctx))))) }});

  // Postcondition: The function returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

let EVP_Digest_spec len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `data` is a fresh const array of `len` bytes, and `data_ptr`
  // points to `data`.
  (data, data_ptr) <- ptr_to_fresh_readonly "data" (llvm_array len (llvm_int 8));

  // Precondition: `md_out_ptr` is a pointer to an array of `SHA_DIGEST_LENGTH`
  // bytes.
  md_out_ptr <- crucible_alloc (llvm_array SHA_DIGEST_LENGTH (llvm_int 8));

  // Precondition: `type_ptr` is a pointer to a const `env_md_ctx_st` struct
  // satisfying the `points_to_env_md_st` specification
  type_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st type_ptr;

  // Call function with arguments data_ptr, len, md_out_ptr, NULL, type_ptr,
  // and NULL
  crucible_execute_func
    [ data_ptr
    , crucible_term {{ `len : [64] }}
    , md_out_ptr
    , crucible_null
    , type_ptr
    , crucible_null
    ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The data pointed to by `md_out_ptr` matches the message
  // digest returned by the Cryptol function `SHA_IMP_SPEC`.  The reverses,
  // splits, and joins transform the Cryptol function's big endian output to
  // little endian.
  crucible_points_to md_out_ptr (crucible_term {{ reverse (split`{SHA_DIGEST_LENGTH} (join (reverse (split`{each=64} (SHA_IMP_SPEC data))))) }});

  // Postcondition:  The function returns the value `1`
  crucible_return (crucible_term {{ 1 : [32] }});
};


////////////////////////////////////////////////////////////////////////////////
// Proof commands

// Assume `OPENSSL_malloc` satisfies `OPENSSL_malloc_spec`
OPENSSL_malloc_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec SHA512_CTX_SIZE);

// Assume `OPENSSL_free` satisfies `OPENSSL_free_nonnull_spec`
OPENSSL_free_nonnull_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  (OPENSSL_free_nonnull_spec SHA512_CTX_SIZE);

// Assume `OPENSSL_free` satisfies `OPENSSL_free_null_spec`
OPENSSL_free_null_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  OPENSSL_free_null_spec;

// Assume `OPENSSL_cleanse` satisfies `OPENSSL_cleanse_spec`
OPENSSL_cleanse_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_cleanse"
  (OPENSSL_cleanse_spec SHA512_CTX_SIZE);


// bvShl<N> functions take a 64 bit vector and shift left by N
let bvShl3  = parse_core "\\(x : bitvector 64) -> bvShl 64 x 3";
let bvShl7  = parse_core "\\(x : bitvector 64) -> bvShl 64 x 7";
let bvShl42 = parse_core "\\(x : bitvector 64) -> bvShl 64 x 42";
let bvShl56 = parse_core "\\(x : bitvector 64) -> bvShl 64 x 56";

// bvShr<N> functions take a 64 bit vector and shift right by N
let bvShr1  = parse_core "\\(x : bitvector 64) -> bvShr 64 x 1";
let bvShr7  = parse_core "\\(x : bitvector 64) -> bvShr 64 x 7";
let bvShr6  = parse_core "\\(x : bitvector 64) -> bvShr 64 x 6";
let bvShr19 = parse_core "\\(x : bitvector 64) -> bvShr 64 x 19";
let bvShr42 = parse_core "\\(x : bitvector 64) -> bvShr 64 x 42";

// slice_<A>_<B>_<C> functions take a 64 bit vector x and return the slice of
// size B that immediately follows the first A bytes of x and that immediately
// precedes the final C bytes of x.
let slice_8_56_0  = parse_core "\\(x : bitvector 64) -> slice Bool 8 56 0 x";
let slice_0_8_56  = parse_core "\\(x : bitvector 64) -> slice Bool 0 8 56 x";
let slice_36_28_0 = parse_core "\\(x : bitvector 64) -> slice Bool 36 28 0 x";
let slice_0_36_28 = parse_core "\\(x : bitvector 64) -> slice Bool 0 36 28 x";
let slice_41_23_0 = parse_core "\\(x : bitvector 64) -> slice Bool 41 23 0 x";
let slice_0_41_23 = parse_core "\\(x : bitvector 64) -> slice Bool 0 41 23 x";
let slice_50_14_0 = parse_core "\\(x : bitvector 64) -> slice Bool 50 14 0 x";
let slice_0_50_14 = parse_core "\\(x : bitvector 64) -> slice Bool 0 50 14 x";
let slice_58_6_0  = parse_core "\\(x : bitvector 64) -> slice Bool 58 6 0 x";
let slice_0_58_6  = parse_core "\\(x : bitvector 64) -> slice Bool 0 58 6 x";
let slice_59_5_0  = parse_core "\\(x : bitvector 64) -> slice Bool 59 5 0 x";
let slice_0_59_5  = parse_core "\\(x : bitvector 64) -> slice Bool 0 59 5 x";
let slice_60_4_0  = parse_core "\\(x : bitvector 64) -> slice Bool 60 4 0 x";
let slice_0_60_4  = parse_core "\\(x : bitvector 64) -> slice Bool 0 60 4 x";


// Helper function for proving theorems
let prove_folding_theorem t = prove_print abc (rewrite (cryptol_ss ()) t);

// rotate<N>_thm proves that left rotations of size N are equivalent to two
// slices concatenated together
rotate8_thm  <- prove_folding_theorem {{ \x -> (slice_8_56_0  x) # (slice_0_8_56  x) == x <<<  8 }};
rotate36_thm <- prove_folding_theorem {{ \x -> (slice_36_28_0 x) # (slice_0_36_28 x) == x <<< 36 }};
rotate41_thm <- prove_folding_theorem {{ \x -> (slice_41_23_0 x) # (slice_0_41_23 x) == x <<< 41 }};
rotate50_thm <- prove_folding_theorem {{ \x -> (slice_50_14_0 x) # (slice_0_50_14 x) == x <<< 50 }};
rotate58_thm <- prove_folding_theorem {{ \x -> (slice_58_6_0  x) # (slice_0_58_6  x) == x <<< 58 }};
rotate59_thm <- prove_folding_theorem {{ \x -> (slice_59_5_0  x) # (slice_0_59_5  x) == x <<< 59 }};
rotate60_thm <- prove_folding_theorem {{ \x -> (slice_60_4_0  x) # (slice_0_60_4  x) == x <<< 60 }};

// TODO: I don't know what the various rotate<X>_slice_add theorems do
rotate59_slice_add_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50) <<< 59
  }};

rotate59_slice_add_1_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54) <<< 59
  }};

rotate59_slice_add_2_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58) <<< 59
  }};

rotate59_slice_add_3_thm <- prove_folding_theorem
  {{ \x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 x16 x17 x18 x19 x20 x21 x22 x23 x24 x25 x26 x27 x28 x29 x30 x31 x32 x33 x34 x35 x36 x37 x38 x39 x40 x41 x42 x43 x44 x45 x46 x47 x48 x49 x50 x51 x52 x53 x54 x55 x56 x57 x58 x59 x60 x61 x62 ->
      (slice_59_5_0 (x0 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 + x61 + x62))
        # (slice_0_59_5 (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 + x61 + x62))
      == (x0 + (64 * x1) + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 + x10 + x11 + x12 + x13 + x14 + x15 + x16 + x17 + x18 + x19 + x20 + x21 + x22 + x23 + x24 + x25 + x26 + x27 + x28 + x29 + x30 + x31 + x32 + x33 + x34 + x35 + x36 + x37 + x38 + x39 + x40 + x41 + x42 + x43 + x44 + x45 + x46 + x47 + x48 + x49 + x50 + x51 + x52 + x53 + x54 + x55 + x56 + x57 + x58 + x59 + x60 + x61 + x62) <<< 59
  }};

// TODO: It's easy to see what this theorem does, but I don't know why it's
// necessary
xor_append_64_64_thm <- prove_folding_theorem
  {{ \(x : [64]) (y : [64]) u v -> (x # y) ^ (u # v) == (x ^ u) # (y ^ v) }};

// These prove that the various sigma functions are equivalent to sequences of
// ANDs, rotations, and shifts.
Sigma0_thm   <- prove_folding_theorem {{ \x -> (x ^ ((x ^ (x <<< 59)) <<< 58)) <<< 36 == S0 x }};
Sigma0_1_thm <- prove_folding_theorem {{ \x -> ((((x <<< 59) ^ x) <<< 58) ^ x) <<< 36 == S0 x }};
Sigma1_thm   <- prove_folding_theorem {{ \x -> (x ^ ((x ^ (x <<< 41)) <<< 60)) <<< 50 == S1 x }};
Sigma1_1_thm <- prove_folding_theorem {{ \x -> ((((x <<< 41) ^ x) <<< 60) ^ x) <<< 50 == S1 x }};
sigma0_thm <- prove_folding_theorem
  {{ \x -> (bvShr1 x) ^ (bvShr7 x) ^ (bvShl56 x) ^ (bvShr7 (bvShr1 x)) ^ (bvShl7 (bvShl56 x)) == s0 x }};
sigma1_thm <- prove_folding_theorem
  {{ \x -> (bvShr6 x) ^ (bvShl3 x) ^ (bvShr19 x) ^ (bvShl42 (bvShl3 x)) ^ (bvShr42 (bvShr19 x)) == s1 x }};

// Prove that the Ch function is equivalent to various combinations of XOR and
// AND
Ch_thm   <- prove_folding_theorem {{ \x y z -> z ^ (x && (z ^ y)) == Ch x y z }};
Ch_1_thm <- prove_folding_theorem {{ \x y z -> z ^ (x && (y ^ z)) == Ch x y z }};
Ch_2_thm <- prove_folding_theorem {{ \x y z -> z ^ ((y ^ z) && x) == Ch x y z }};
Ch_3_thm <- prove_folding_theorem {{ \x y z -> z ^ ((y ^ z) && x) == Ch x y z }};
Ch_4_thm <- prove_folding_theorem {{ \x y z -> ((y ^ z) && x) ^ z == Ch x y z }};
Ch_5_thm <- prove_folding_theorem {{ \x y z -> ((z ^ y) && x) ^ z == Ch x y z }};
Ch_6_thm <- prove_folding_theorem {{ \x y z -> (x && (y ^ z)) ^ z == Ch x y z }};
Ch_7_thm <- prove_folding_theorem {{ \x y z -> (x && (z ^ y)) ^ z == Ch x y z }};

// Prove relationships between Ch and Maj
Maj_thm   <- prove_folding_theorem {{ \x y z -> Ch (x ^ y) z y == Maj x y z }};
Maj_1_thm <- prove_folding_theorem {{ \x y z -> Ch (y ^ x) z y == Maj x y z }};

// TODO: I'm not sure what bvult and cmp_sub_thm are for
let bvult = parse_core "\\(x y : bitvector 64) -> bvult 64 x y";
// replace (bvult x y) with (x - y <$ 0) in order for the semiring and abstract domain to work
cmp_sub_thm <- prove_folding_theorem
  {{ \x y -> bvult x y == if (x @ 0 == y @ 0) then (x - y <$ 0) else (x @ 0 < y @ 0) }};

let thms =
  [ rotate8_thm
  , rotate36_thm
  , rotate41_thm
  , rotate50_thm
  , rotate58_thm
  , rotate59_thm
  , rotate60_thm
  , rotate59_slice_add_thm
  , rotate59_slice_add_1_thm
  , rotate59_slice_add_2_thm
  , rotate59_slice_add_3_thm
  , xor_append_64_64_thm
  , Sigma0_thm
  , Sigma0_1_thm
  , Sigma1_thm
  , Sigma1_1_thm
  , sigma0_thm
  , sigma1_thm
  , Ch_thm
  , Ch_1_thm
  , Ch_2_thm
  , Ch_3_thm
  , Ch_4_thm
  , Ch_5_thm
  , Ch_6_thm
  , Ch_7_thm
  , Maj_thm
  , Maj_1_thm
  , cmp_sub_thm
  ];

// Prove concatenation is associative
concat_assoc_thm <- prove_folding_theorem
  {{ \(x0 : [8]) (x1 : [8]) (x2 : [8]) (x3 : [8]) (x4 : [8]) (x5 : [8]) (x6 : [8]) (x7 : [8]) -> x0 # (x1 # (x2 # (x3 # (x4 # (x5 # (x6 # x7)))))) == (((((((x0 # x1) # x2) # x3) # x4) # x5) # x6) # x7) }};


enable_what4_hash_consing;

sha512_block_data_order_spec <- crucible_llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "sha512_block_data_order"
// Verify the block data function assembly satisfies the
// `sha512_block_data_order_spec` specification
crucible_llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "sha512_block_data_order"
  [ ("K512", 5120) // immutable constants
  ]
  true
  sha512_block_data_order_spec
  (do {
    simplify (cryptol_ss ());
    simplify (addsimps thms empty_ss);
    simplify (addsimp concat_assoc_thm empty_ss);
    w4_unint_yices ["S0", "S1", "s0", "s1", "Ch"];
  });

disable_what4_hash_consing;

// Assume the `sha512_block_data_order` function satisfies the
// `sha512_block_data_order_spec`
sha512_block_data_order_spec <- crucible_llvm_unsafe_assume_spec m "sha512_block_data_order"
  (sha512_block_data_order_spec true);

// Verify the `EVP_SHA_INIT` C function satisfies the `EVP_sha_init_spec`
// specification
crucible_llvm_verify m EVP_SHA_INIT [] true EVP_sha_init_spec (w4_unint_yices []);


// Verify the `EVP_DigestInit` C function satisfies the `EVP_DigestInit_spec`
// specification
crucible_llvm_verify m "EVP_DigestInit"
  [ OPENSSL_malloc_ov
  , OPENSSL_free_null_ov
  ]
  true
  EVP_DigestInit_spec
  (w4_unint_yices []);

// Verify the `EVP_DigestUpdate` C function satisfies the
// `EVP_DigestUpdate_spec` specification.  There are 3 cases to consider to
// ensure the proof covers all possible code paths through the update function
crucible_llvm_verify m "EVP_DigestUpdate"
  [sha512_block_data_order_spec]
  true
  // num=0, len=240 covers the case with one call to the block function,
  // on one block from data, and the rest of data copied in c->data
  (EVP_DigestUpdate_spec 0 240)
  (w4_unint_yices ["SHA512Block"]);
crucible_llvm_verify m "EVP_DigestUpdate"
  [sha512_block_data_order_spec]
  true
  // num=0, len=127 covers the case without any calls to the block function,
  // and data copied in c->data
  (EVP_DigestUpdate_spec 0 127)
  (w4_unint_yices ["SHA512Block"]);
crucible_llvm_verify m "EVP_DigestUpdate"
  [sha512_block_data_order_spec]
  true
  // num=127, len=241 covers the case with two calls to the block function,
  // the first one on c->data, the second one on one block from data,
  // and the rest of data copied in c->data
  (EVP_DigestUpdate_spec 127 241)
  (w4_unint_yices ["SHA512Block"]);

// Verify the `EVP_DigestFinal` C function satisfies the
// `EVP_DigestFinal_spec` specification.  There are 2 cases to consider to
// ensure the proof covers all possible code paths through the update function
crucible_llvm_verify m "EVP_DigestFinal"
  [ sha512_block_data_order_spec
  , OPENSSL_free_nonnull_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // num=111 covers the case with one call to the block function
  (EVP_DigestFinal_spec 111)
  (w4_unint_yices ["SHA512Block"]);
crucible_llvm_verify m "EVP_DigestFinal"
  [ sha512_block_data_order_spec
  , OPENSSL_free_nonnull_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // num=112 covers the case with two calls to the block function
  (EVP_DigestFinal_spec 112)
  (w4_unint_yices ["SHA512Block"]);

// Verify the `EVP_Digest` C function satisfies the `EVP_Digest_spec`
// specification
crucible_llvm_verify m "EVP_Digest"
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ]
  true
  (EVP_Digest_spec 240)
  (w4_unint_yices ["SHA512Block"]);

