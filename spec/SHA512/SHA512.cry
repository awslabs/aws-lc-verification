/*
 * Copyright (c) 2020 Galois, Inc.
 * Distributed under the terms of the BSD3 license (see LICENSE file)
 *
 * This is a very simple implementation of SHA512, designed to be as clearly
 * mathced to the specification in NIST's FIPS-PUB-180-4 as possible
 *
 * * The output correctly matches on all test vectors from
 * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA512.pdf
 */

/*
 * SHA512 Functions : Section 4.1.3
 */

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ (~x && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

S0 : [64] -> [64]
S0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

S1 : [64] -> [64]
S1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

s0 : [64] -> [64]
s0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

s1 : [64] -> [64]
s1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

/*
 * SHA512 Constants : Section 4.2.3
 */

K : [80][64]
K = [ 0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
    ]

/*
 * Preprocessing (padding and parsing) for SHA512 : Section 5.1.2 and 5.2.2
 */
preprocess : {msgLen,contentLen,chunks,padding}
     ( fin msgLen
     , 128 >= width msgLen                              // message width fits in a word
     , contentLen == msgLen + 129                       // message + header
     , chunks     == (contentLen+1023) / 1024
     , padding    == (1024 - contentLen % 1024) % 1024  // prettier if type #'s could be < 0
     )
     => [msgLen] -> [chunks][1024]
preprocess msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[128]))

/*
 * SHA512 Initial Hash Value :  Section 5.3.5
 */

H0 : [8][64]
H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b,
       0xa54ff53a5f1d36f1, 0x510e527fade682d1, 0x9b05688c2b3e6c1f,
       0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

/*
 * The SHA512 Hash computation : Section 6.4.2
 *
 * We have split the computation into a message scheduling function, corresponding
 * to step 1 in the documents loop, and a compression function, corresponding to steps 2-4.
 */

SHA512MessageSchedule : [16][64] -> [80][64]
SHA512MessageSchedule M = W where
    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) |
              j <- [16 .. 79]:[_][8] ]

SHA512Compress : [8][64] -> [80][64] -> [8][64]
SHA512Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where
    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]
    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]
    hs = take `{81} ([H@7] # gs)
    gs = take `{81} ([H@6] # fs)
    fs = take `{81} ([H@5] # es)
    es = take `{81} ([H@4] # [d + t1 | d <- ds | t1 <- T1])
    ds = take `{81} ([H@3] # cs)
    cs = take `{81} ([H@2] # bs)
    bs = take `{81} ([H@1] # as)
    as = take `{81} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])

SHA512Block : [8][64] -> [16][64] -> [8][64]
SHA512Block H M = SHA512Compress H (SHA512MessageSchedule M)

//////// Functional/idiomatic top level ////////

/*
 * The SHA512' function hashes a preprocessed sequence of blocks with the
 * compression function.  The SHA512 function hashes a sequence of bytes, and
 * is more likely the function that will be similar to those seein in an
 * implementation to be verified.
 */

SHA512' : {a} (fin a) => [a][16][64] -> [8][64]
SHA512' blocks = hash!0 where
    hash = [H0] # [SHA512Block h b | h <- hash | b <- blocks]

SHA512 : {a} (fin a, 128 >= width (8*a)) => [a][8] -> [512]
SHA512 msg = join (SHA512' [ split x | x <- preprocess(join msg)])

//////// Imperative top level ////////

type SHA512State = { h : [8][64]
                   , block : [128][8]
                   , n : [32]
                   , sz : [64]
                   }

SHA512Init : SHA512State
SHA512Init = { h = H0
             , block = zero
             , n = 0
             , sz = 0
             }

SHA512Update1 : SHA512State -> [8] -> SHA512State
SHA512Update1 s b =
  if s.n == 128
    then { h = SHA512Block s.h (split (join s.block))
         , block = [b] # zero
         , n = 1
         , sz = s.sz + 8
         }
    else { h = s.h
         , block = update s.block s.n b
         , n = s.n + 1
         , sz = s.sz + 8
         }

SHA512Update : {n} (fin n) => SHA512State -> [n][8] -> SHA512State
SHA512Update sinit bs = ss!0
  where ss = [sinit] # [ SHA512Update1 s b | s <- ss | b <- bs ]

// Add padding and size and process the final block.
SHA512Final : SHA512State -> [512]
SHA512Final s = join (SHA512Block h b')
  // Because the message is always made up of bytes, and the size is a
  // fixed number of bytes, the 1 pad will always be at least a byte.
  where s' = SHA512Update1 s 0x80
        // Don't need to add zeros. They're already there. Just update
        // the count of bytes in this block. After adding the 1 pad, there
        // are two possible cases: the size will fit in the current block,
        // or it won't.
        (h, b) = if s'.n <= 112 then (s'.h, s'.block)
                 else (SHA512Block s'.h (split (join s'.block)), zero)
        b' = split (join b || (zero # s.sz))

SHA512Imp : {n} (fin n) => [n][8] -> [512]
SHA512Imp msg = SHA512Final (SHA512Update SHA512Init msg)

