/*
 * Copyright (c) 2020 Galois, Inc.
 * Distributed under the terms of the BSD3 license (see LICENSE file)
 *
 * This is a very simple implementation of SHA512 and SHA384, designed to be as
 * clearly matched to the specification in NIST's FIPS-PUB-180-4 as possible
 *
 * * The output correctly matches on all test vectors from
 * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA512.pdf and
 * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA384.pdf
 */
module SHA512 where

/*
 * SHA512 Functions : Section 4.1.3
 */

Ch : [64] -> [64] -> [64] -> [64]
Ch x y z = (x && y) ^ (~x && z)

Maj : [64] -> [64] -> [64] -> [64]
Maj x y z = (x && y) ^ (x && z) ^ (y && z)

S0 : [64] -> [64]
S0 x = (x >>> 28) ^ (x >>> 34) ^ (x >>> 39)

S1 : [64] -> [64]
S1 x = (x >>> 14) ^ (x >>> 18) ^ (x >>> 41)

s0 : [64] -> [64]
s0 x = (x >>> 1) ^ (x >>> 8) ^ (x >> 7)

s1 : [64] -> [64]
s1 x = (x >>> 19) ^ (x >>> 61) ^ (x >> 6)

/*
 * SHA512 Constants : Section 4.2.3
 */

K : [80][64]
K = [ 0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f, 0xe9b5dba58189dbbc,
      0x3956c25bf348b538, 0x59f111f1b605d019, 0x923f82a4af194f9b, 0xab1c5ed5da6d8118,
      0xd807aa98a3030242, 0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,
      0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235, 0xc19bf174cf692694,
      0xe49b69c19ef14ad2, 0xefbe4786384f25e3, 0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65,
      0x2de92c6f592b0275, 0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,
      0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f, 0xbf597fc7beef0ee4,
      0xc6e00bf33da88fc2, 0xd5a79147930aa725, 0x06ca6351e003826f, 0x142929670a0e6e70,
      0x27b70a8546d22ffc, 0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,
      0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6, 0x92722c851482353b,
      0xa2bfe8a14cf10364, 0xa81a664bbc423001, 0xc24b8b70d0f89791, 0xc76c51a30654be30,
      0xd192e819d6ef5218, 0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,
      0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99, 0x34b0bcb5e19b48a8,
      0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb, 0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3,
      0x748f82ee5defb2fc, 0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,
      0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915, 0xc67178f2e372532b,
      0xca273eceea26619c, 0xd186b8c721c0c207, 0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178,
      0x06f067aa72176fba, 0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,
      0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc, 0x431d67c49c100d4c,
      0x4cc5d4becb3e42b6, 0x597f299cfc657e2a, 0x5fcb6fab3ad6faec, 0x6c44198c4a475817
    ]

/*
 * Preprocessing (padding and parsing) for SHA512 : Section 5.1.2 and 5.2.2
 */
preprocess : {msgLen,contentLen,chunks,padding}
     ( fin msgLen
     , 128 >= width msgLen                              // message width fits in a word
     , contentLen == msgLen + 129                       // message + header
     , chunks     == (contentLen+1023) / 1024
     , padding    == (1024 - contentLen % 1024) % 1024  // prettier if type #'s could be < 0
     )
     => [msgLen] -> [chunks][1024]
preprocess msg = split (msg # [True] # (zero:[padding]) # (`msgLen:[128]))

/*
 * SHA512 Initial Hash Value :  Section 5.3.5
 */

SHA512H0 : [8][64]
SHA512H0 = [ 0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b,
             0xa54ff53a5f1d36f1, 0x510e527fade682d1, 0x9b05688c2b3e6c1f,
             0x1f83d9abfb41bd6b, 0x5be0cd19137e2179 ]

/*
 * SHA384 Initial Hash Value : Section 5.3.4
 */

SHA384H0 : [8][64]
SHA384H0 = [ 0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17,
             0x152fecd8f70e5939, 0x67332667ffc00b31, 0x8eb44a8768581511,
             0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4 ]

/*
 * The SHA512 Hash computation : Section 6.4.2
 *
 * We have split the computation into a message scheduling function, corresponding
 * to step 1 in the documents loop, and a compression function, corresponding to steps 2-4.
 */

SHA512MessageSchedule : [16][64] -> [80][64]
SHA512MessageSchedule M = W where
    W = M # [ s1 (W@(j-2)) + (W@(j-7)) + s0 (W@(j-15)) + (W@(j-16)) | j <- [16 .. 79]:[_][8] ]

SHA512Compress : [8][64] -> [80][64] -> [8][64]
SHA512Compress H W = [as!0 + H@0, bs!0 + H@1, cs!0 + H@2, ds!0 + H@3, es!0 + H@4, fs!0 + H@5, gs!0 + H@6, hs!0 + H@7] where
    T1 = [h + S1 e + Ch e f g  + k + w | h <- hs | e <- es | f <- fs | g <- gs | k <- K | w <- W]
    T2 = [S0 a  + Maj a b c  | a <- as | b <- bs | c <- cs]
    hs = take `{81} ([H@7] # gs)
    gs = take `{81} ([H@6] # fs)
    fs = take `{81} ([H@5] # es)
    es = take `{81} ([H@4] # [d + t1 | d <- ds | t1 <- T1])
    ds = take `{81} ([H@3] # cs)
    cs = take `{81} ([H@2] # bs)
    bs = take `{81} ([H@1] # as)
    as = take `{81} ([H@0] # [t1 + t2 | t1 <- T1 | t2 <- T2])

SHA512Block : [8][64] -> [16][64] -> [8][64]
SHA512Block H M = SHA512Compress H (SHA512MessageSchedule M)

//////// Functional/idiomatic top level ////////

/*
 * The SHA512' function hashes a preprocessed sequence of blocks with the
 * compression function.  The SHA512 function hashes a sequence of bytes, and
 * is more likely the function that will be similar to those seein in an
 * implementation to be verified.
 */

SHA512' : {a} (fin a) => [a][16][64] -> [8][64] -> [8][64]
SHA512' blocks H0 = hash!0 where
    hash = [H0] # [SHA512Block h b | h <- hash | b <- blocks]

SHA512 : {a} (fin a, 128 >= width (8*a)) => [a][8] -> [512]
SHA512 msg = join (SHA512' [ split x | x <- preprocess(join msg)] SHA512H0)

/*
 * The SHA384 function uses the same algorithm as SHA512 with a different H0,
 * then drops all but the first 384 bits
 */

SHA384 : {a} (fin a, 128 >= width (8*a)) => [a][8] -> [384]
SHA384 msg = join (take`{6} (SHA512' [ split x | x <- preprocess(join msg)]
                                     SHA384H0))

//////// Imperative top level ////////

type SHA512State = { h : [8][64]
                   , block : [128][8]
                   , n : [32]
                   , sz : [128]
                   }

// Initial state for SHA512
SHA512Init : SHA512State
SHA512Init = { h = SHA512H0
             , block = zero
             , n = 0
             , sz = 0
             }

// Initial state for SHA384.  Uses same state structure as SHA512.
SHA384Init : SHA512State
SHA384Init = { h = SHA384H0
             , block = zero
             , n = 0
             , sz = 0
             }

// SHA512Update1 updates a single byte at position s.n in s.block and return a
// new state to pass to subsequent updates.  If s.n is 128, updates position 0
// to b and zeros the remainder of the block, setting s.n to 1 for the next
// update.
SHA512Update1 : SHA512State -> [8] -> SHA512State
SHA512Update1 s b =
  if s.n == 127
    then { h = SHA512Block s.h (split (join (update s.block s.n b)))
         , block = zero
         , n = 0
         , sz = s.sz + 8
         }
    else { h = s.h
         , block = update s.block s.n b
         , n = s.n + 1
         , sz = s.sz + 8
         }

// Process message being hashed, iteratively updating the SHA state with the
// input message.
SHA512Update : {n} (fin n) => SHA512State -> [n][8] -> SHA512State
SHA512Update sinit bs = ss!0
  where ss = [sinit] # [ SHA512Update1 s b | s <- ss | b <- bs ]

// Add padding and size and process the final block.
SHA512Final : SHA512State -> [512]
SHA512Final s = join (SHA512Block h b')
  // Because the message is always made up of bytes, and the size is a
  // fixed number of bytes, the 1 pad will always be at least a byte.
  where s' = SHA512Update1 s 0x80
        // Don't need to add zeros. They're already there. Just update
        // the count of bytes in this block. After adding the 1 pad, there
        // are two possible cases: the size will fit in the current block,
        // or it won't.
        (h, b) = if s'.n <= 112 then (s'.h, s'.block)
                 else (SHA512Block s'.h (split (join s'.block)), zero)
        b' = split (join b || (zero # s.sz))

// Drop all but the first 384 bytes of the result of applying SHA512Final to s
// to get the SHA384 digest.
SHA384Final : SHA512State -> [384]
SHA384Final s = join (take`{6} (split`{8} (SHA512Final s)))

// Imperative SHA512 implementation
SHA512Imp : {n} (fin n) => [n][8] -> [512]
SHA512Imp msg = SHA512Final (SHA512Update SHA512Init msg)

// Imperative SHA384 implementation
SHA384Imp : {n} (fin n) => [n][8] -> [384]
SHA384Imp msg = SHA384Final (SHA512Update SHA384Init msg)

