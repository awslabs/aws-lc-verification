/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

module HASH::HMAC where

import Primitive::Keyless::Hash::HMAC
import Primitive::Keyless::Hash::SHA384
import Array
import Common::ByteArray
import HASH::SHA384

type HMACState_Array = { i_ctx  : SHAState_Array
                       , o_ctx  : SHAState
                       , md_ctx : SHAState_Array
                       }

HMACState_zeroized : HMACState_Array
HMACState_zeroized = { i_ctx = SHAInit_Array_zeroized
                     , o_ctx = SHAInit_zeroized
                     , md_ctx = SHAInit_Array_zeroized }

key_helper1 : ByteArray -> [64] -> [128][8]
key_helper1 key key_len =
  (arrayRangeLookup`{n=128} (arrayCopy (arrayConstant 0) 0 key 0 key_len) 0)

key_helper2 : HMACState_Array -> ByteArray -> [64] -> [128][8]
key_helper2 state key key_len =
  (split`{48} (SHAImp_Array2 state.md_ctx key key_len)) # (zero : [128-48][8])

key_init_Array : HMACState_Array -> ByteArray -> [64] -> [128][8]
key_init_Array state key key_len =
   ( if key_len <= 128
     then key_helper1 key key_len
     else key_helper2 state key key_len)

ipad : [128][8] -> [128][8]
ipad key = [ k ^ 0x36 | k <- key ]

opad : [128][8] -> [128][8]
opad key = [ k ^ 0x5c | k <- key ]

istate : HMACState_Array -> [128][8] -> SHAState_Array
istate state key = SHAUpdate_Array (SHAInit_Array2 state.i_ctx) (arrayRangeUpdate (arrayConstant 0) 0 (ipad key)) 128

ostate : [128][8] -> SHAState
ostate key = SHAUpdate SHAInit (opad key)

HMACInit_Array : HMACState_Array -> ByteArray -> [64] -> HMACState_Array
HMACInit_Array state key key_len =
  { i_ctx = i_state
  , o_ctx = o_state
  , md_ctx = i_state }
  where
    key' = (key_init_Array state key key_len)
    i_state = istate state key'
    o_state = ostate key'

istate' : HMACState_Array -> ByteArray -> [64] -> SHAState_Array
istate' state key key_len =
  if key_len <= 128 then i_state_1 else i_state_2
  where key_1 = (key_helper1 key key_len)
        key_2 = (key_helper2 state key key_len)
        i_state_1 = SHAUpdate_Array (SHAInit_Array2 state.i_ctx)
                                    (arrayRangeUpdate (arrayConstant 0) 0 (ipad key_1)) 128
        i_state_2 = SHAUpdate_Array (SHAInit_Array2 state.i_ctx)
                                    (arrayRangeUpdate (arrayConstant 0) 0 (ipad key_2)) 128

ostate' : HMACState_Array -> ByteArray -> [64] -> SHAState
ostate' state key key_len =
  if key_len <= 128 then o_state_1 else o_state_2
  where o_state_1 = SHAUpdate SHAInit (opad (key_helper1 key key_len))
        o_state_2 = SHAUpdate SHAInit (opad (key_helper2 state key key_len))

ipad' : [128][8] -> [128][8]
ipad' key = (split`{128} (join ([ join (reverse (split`{8} ((join (reverse (split`{8} k))) ^ 0x3636363636363636))) | k <- (split`{16} (join key)) ])))

opad' : [128][8] -> [128][8]
opad' key = (split`{128} (join ([ join (reverse (split`{8} ((join (reverse (split`{8} k))) ^ 0x5c5c5c5c5c5c5c5c))) | k <- (split`{16} (join key)) ])))

istate'' : HMACState_Array -> ByteArray -> [64] -> SHAState_Array
istate'' state key key_len =
  if key_len <= 128 then i_state_1 else i_state_2
  where key_1 = (key_helper1 key key_len)
        key_2 = (key_helper2 state key key_len)
        i_state_1 = SHAUpdate_Array (SHAInit_Array2 state.i_ctx)
                                    (arrayRangeUpdate (arrayConstant 0) 0 (ipad' key_1)) 128
        i_state_2 = SHAUpdate_Array (SHAInit_Array2 state.i_ctx)
                                    (arrayRangeUpdate (arrayConstant 0) 0 (ipad' key_2)) 128

ostate'' : HMACState_Array -> ByteArray -> [64] -> SHAState
ostate'' state key key_len =
  if key_len <= 128 then o_state_1 else o_state_2
  where o_state_1 = SHAUpdate SHAInit (opad' (key_helper1 key key_len))
        o_state_2 = SHAUpdate SHAInit (opad' (key_helper2 state key key_len))

HMACInit_Array3 : HMACState_Array -> ByteArray -> [64] -> HMACState_Array
HMACInit_Array3 state key key_len =
  { i_ctx = i_state
  , o_ctx = o_state
  , md_ctx = i_state }
  where
    i_state = istate'' state key key_len
    o_state = ostate'' state key key_len

HMACUpdate_Array : HMACState_Array -> ByteArray -> [64] -> HMACState_Array
HMACUpdate_Array state data len = { i_ctx = state.i_ctx
                                  , o_ctx = state.o_ctx
                                  , md_ctx = SHAUpdate_Array state.md_ctx data len
                                  }

HMACFinal_Array : HMACState_Array -> [48][8]
HMACFinal_Array state = split`{48} (SHAFinal o_ctx')
  where o_ctx' = SHAUpdate state.o_ctx buf
        buf = split`{48} (SHAFinal_Array state.md_ctx)

HMAC_Array : HMACState_Array -> ByteArray -> [64] -> ByteArray -> [64] -> [48][8]
HMAC_Array state key key_len data data_len = HMACFinal_Array (HMACUpdate_Array (HMACInit_Array state key key_len) data data_len)

HMACState_Array_eq : HMACState_Array -> HMACState_Array -> Bool
HMACState_Array_eq state1 state2 =
     SHAState_Array_eq state1.i_ctx state2.i_ctx
  /\ SHAState_Array_eq state1.md_ctx state2.md_ctx
  /\ SHAState_eq state1.o_ctx state2.o_ctx
