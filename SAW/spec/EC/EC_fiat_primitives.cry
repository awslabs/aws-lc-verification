/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

module EC_fiat_primitives where

type bit_length = 384

type limb_size = 64
type nlimbs = bit_length / 64

type limb = [limb_size]
type felem = [nlimbs][64]

type scalar = [bit_length]

type point = [3]felem
type JacobianBVPoint = { X : [bit_length], Y : [bit_length], Z : [bit_length] }

zero_felem: felem
zero_felem = repeat 0

primitive fiat_field_zero : felem

primitive fiat_field_one : felem

primitive fiat_field_square : felem -> felem

primitive fiat_field_mul : felem -> felem -> felem

primitive fiat_field_add : felem -> felem -> felem

primitive fiat_field_sub : felem -> felem -> felem

primitive fiat_field_opp : felem -> felem

constant_time_is_zero_w : limb -> limb
constant_time_is_zero_w x = if (x == zero) then 0xFFFFFFFFFFFFFFFF else 0

fiat_field_cmovznz : limb -> felem -> felem -> felem
fiat_field_cmovznz t f1 f2 = if (t == zero) then f1 else f2

fiat_field_nz : felem -> limb
fiat_field_nz f = foldl (||) 0 f

fiat_point_double : point -> point
fiat_point_double p = p'
  where
    x = p@0
    y = p@1
    z = p@2

    delta = (fiat_field_square z)
    gamma = (fiat_field_square y)
    beta = (fiat_field_mul x gamma)

    xminusdelta = (fiat_field_sub x delta)
    xplusdelta = (fiat_field_add x delta)
    twoxplusdelta = (fiat_field_add xplusdelta xplusdelta)
    threexplusdelta = (fiat_field_add xplusdelta twoxplusdelta)
    alpha = (fiat_field_mul xminusdelta threexplusdelta)

    twobeta = (fiat_field_add beta beta)
    fourbeta = (fiat_field_add twobeta twobeta)
    eightbeta = (fiat_field_add fourbeta fourbeta)
    x' = (fiat_field_sub (fiat_field_square alpha) eightbeta)

    yplusz = (fiat_field_add y z)
    ypluszsquared = (fiat_field_square yplusz)
    z' = (fiat_field_sub (fiat_field_sub ypluszsquared gamma) delta)

    fourgammasquared = (fiat_field_square (fiat_field_add gamma gamma))
    eightgammasquared = (fiat_field_add fourgammasquared fourgammasquared)
    y' = (fiat_field_sub (fiat_field_mul alpha (fiat_field_sub fourbeta x')) eightgammasquared)

    p' = [x', y', z']

testForDouble_ct : felem -> felem -> felem -> felem -> Bit
testForDouble_ct p1z p2z h r = res
  where
    z1nz = (fiat_field_nz p1z)
    z2nz = (fiat_field_nz p2z)
    xneq = (fiat_field_nz h)
    yneq = (fiat_field_nz r)

    res = ((constant_time_is_zero_w (xneq || yneq)) &&
            (~(constant_time_is_zero_w z1nz)) &&
            (~(constant_time_is_zero_w z2nz))
            ) != zero

testForDouble : felem -> felem -> felem -> felem -> Bit
testForDouble p1z p2z h r = ((h==zero) && (r==zero) && (p1z != zero) && (p2z != zero))

property testForDoubleEquiv (f1, f2, f3, f4) = (testForDouble_ct f1 f2 f3 f4) == (testForDouble f1 f2 f3 f4)

fiat_point_add : Bit -> point -> point -> point
fiat_point_add mixed p1 p2 = p
  where
    x1 = p1@0
    y1 = p1@1
    z1 = p1@2

    x2 = p2@0
    y2 = p2@1
    z2 = p2@2

    z1z1 = (fiat_field_square z1)

    // Jacobian arithmetic
    z2z2 = (fiat_field_square z2)
    u1_jac = (fiat_field_mul x1 z2z2)
    two_z1z2_jac = (fiat_field_sub (fiat_field_sub (fiat_field_square (fiat_field_add z1 z2)) z1z1) z2z2)
    s1_jac = (fiat_field_mul (fiat_field_mul z2 z2z2) y1)

    // mixed arithmetic
    u1_mixed = x1
    two_z1z2_mixed = (fiat_field_add z1 z1)
    s1_mixed = y1

    u1 = if mixed then u1_mixed else u1_jac
    two_z1z2 = if mixed then two_z1z2_mixed else two_z1z2_jac
    s1 = if mixed then s1_mixed else s1_jac

    u2 = (fiat_field_mul x2 z1z1)
    h = (fiat_field_sub u2 u1)

    z_out = (fiat_field_mul h two_z1z2)
    z1z1z1 = (fiat_field_mul z1 z1z1)
    s2 = (fiat_field_mul y2 z1z1z1)
    r = (fiat_field_add (fiat_field_sub s2 s1) (fiat_field_sub s2 s1))


    is_nontrivial_double = (testForDouble z1 z2 h r)

    i = (fiat_field_square (fiat_field_add h h))
    j = (fiat_field_mul h i)
    v = (fiat_field_mul u1 i)

    x_out = (fiat_field_sub (fiat_field_sub (fiat_field_sub (fiat_field_square r) j) v) v)
    y_out = (fiat_field_sub (fiat_field_sub (fiat_field_mul (fiat_field_sub v x_out) r) (fiat_field_mul s1 j)) (fiat_field_mul s1 j))

    z1nz = (fiat_field_nz z1)
    z2nz = (fiat_field_nz z2)
    x3 = (fiat_field_cmovznz z2nz x1 (fiat_field_cmovznz z1nz x2 x_out))
    y3 = (fiat_field_cmovznz z2nz y1 (fiat_field_cmovznz z1nz y2 y_out))
    z3 = (fiat_field_cmovznz z2nz z1 (fiat_field_cmovznz z1nz z2 z_out))

    p = if is_nontrivial_double then (fiat_point_double p1) else [x3, y3, z3]

/*
fiat_get_bit_ct : scalar -> [32] -> [64]
fiat_get_bit_ct s i = ((zero:[32]) # r)
  where
    s' = reverse (split`{48} s)
    byte = (zero:[24]) # (s'@(i >>$ 3))
    b = (byte >> (i && 7)) && 1
    r = if (i > 383) then zero else b
    */

fiat_get_bit : scalar -> [32] -> [64]
fiat_get_bit s i = (drop (s >> i)) && (1 : [64])

sign_extend_16_64 : [16] -> [64]
sign_extend_16_64 x = (if (x@0) then (~zero:[48]) else (zero:[48])) # x

sign_extend_16_32 : [16] -> [32]
sign_extend_16_32 x = (if (x@0) then (~zero:[16]) else (zero:[16])) # x

sign_extend_8_16 : [8] -> [16]
sign_extend_8_16 x = (if (x@0) then (~zero:[8]) else (zero:[8])) # x

sign_extend_8_32 : [8] -> [32]
sign_extend_8_32 x = (if (x@0) then (~zero:[24]) else (zero:[24])) # x

sign_extend : {a, b} (fin b) => [a] -> [a+b]
sign_extend x = (if (x@0) then (~zero:[b]) else (zero:[b])) # x


byte_to_limb : [8] -> limb
byte_to_limb x = (0:[56]) # (x)

conditional_subtract_if_even_ct : point -> scalar -> point -> point
conditional_subtract_if_even_ct p1 t p2 = r where
  t_limb = (byte_to_limb ((drop`{bit_length-8} t) && 1))
  tmp1 = [p2@0, (fiat_field_opp (p2@1)), p2@2]
  tmp2 = fiat_point_add 0 p1 tmp1
  r = [(fiat_field_cmovznz t_limb (tmp2@0) (p1@0)),
      (fiat_field_cmovznz t_limb (tmp2@1) (p1@1)),
      (fiat_field_cmovznz t_limb (tmp2@2) (p1@2))]

primitive fiat_from_bytes : [bit_length] -> felem
primitive fiat_to_bytes : felem -> [bit_length]

