/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

module AES_GCM where

import Array

import Primitive::Symmetric::Cipher::Block::AES
import Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM
import X86


/*
 * Helpers.
 */
swap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a
swap8 x = join`{each=8} (reverse (split`{each=8} x))

swap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a
swap128 x = join`{each=128} (reverse (split`{each=128} x))

hi_bits : {n} (fin n) => [2 * n] -> [n]
hi_bits = take

lo_bits : {n} (fin n) => [2 * n] -> [n]
lo_bits = drop


/*
 * AES specifications.
 */
aes_key_to_schedule : [Nr + 1][128] -> KeySchedule
aes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)
  where
    key' = map msgToState_x86 key

aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]
aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))
  where
    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])

inv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]
inv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))
  where
    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])

aes_hw_decrypt : [16][8] -> [32][8] -> [16][8]
aes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))

aes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]
aes_hw_ctr32_encrypt_blocks in key (iv # ctr) =
  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]

aes_hw_ctr32_encrypt_blocks_array : Array [64] [8] -> [32][8] -> [16][8] -> [64] -> [64] -> Array [64] [8] -> Array [64] [8]
aes_hw_ctr32_encrypt_blocks_array inp key (iv # ctr) i blocks buf =
  if i < blocks then
    aes_hw_ctr32_encrypt_blocks_array inp key (iv # ctr) (i+1) blocks buf'
      where
        blk  = arrayRangeLookup inp (i*16) : [16][8]
	blk' = blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key)
	buf' = arrayRangeUpdate buf (i*16) blk'
  else
    buf

EK_byte : AES_GCM_Ctx -> [8]
EK_byte ctx = (EKi ctx i) @ j
  where
    i : [32]
    i = take`{32} (drop`{28} ctx.len) + 1

    j : [4]
    j = drop`{60} ctx.len

cipher_update_array : AES_GCM_Ctx -> Array [64] [8] -> [64] -> [64] -> AES_GCM_Ctx
cipher_update_array ctx in i len =
  { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len + len }
 where
   Xi' = cipher_update_Xi_array ctx in i len ctx.Xi

cipher_update_Xi_array :
  AES_GCM_Ctx -> Array [64] [8] -> [64] -> [64] -> [16][8] -> [16][8]
cipher_update_Xi_array ctx in i len Xi =
  if i < len then
    cipher_update_Xi_array ctx in (i+1) len Xi''
      where
        H    = join (get_H ctx)
	n    = (ctx.len+i) % 16
        Xi'  = update Xi n ((Xi@n)^b)
	Xi'' = if (ctx.len+(i+1))%16 == 0
	        then split (gcm_pmult_pmod H (join Xi'))
	        else Xi'
        b    = arrayLookup in i
  else
    Xi

/*
 * GCM specifications.
 */
gcm_init : [2][64] -> [12][128]
gcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))

gcm_init_Htable : [128] -> [12][128]
gcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]
  where
    h1 = gcm_polyval h0 h0
    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))
    h3 = gcm_polyval h0 h1
    h4 = gcm_polyval h0 h3
    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))
    h6 = gcm_polyval h0 h4
    h7 = gcm_polyval h0 h6
    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))
    h9 = gcm_polyval h0 h7
    h10 = gcm_polyval h0 h9
    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))

gcm_gmult : [128] -> [16][8] -> [16][8]
gcm_gmult H Xi = split (gcm_polyval H (join Xi))

gcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]
gcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)

gcm_ghash_array : [128] -> [16][8] -> Array [64] [8] -> [64] -> [64] -> [16][8]
gcm_ghash_array H Xi inp i blocks =
  if i < blocks then
    gcm_ghash_array H (gcm_ghash_block H Xi (arrayRangeLookup inp (i * 16) : [16][8])) inp (i+1) blocks
  else
    Xi

gcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]
gcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))


/*
 * AES_GCM context specification helpers.
 */
get_Htable : AES_GCM_Ctx -> [12][128]
get_Htable ctx = gcm_init (get_H ctx)

get_i : AES_GCM_Ctx -> [32]
get_i ctx = drop ((ctx.len + 15) / 16)

get_Yi : AES_GCM_Ctx -> [16][8]
get_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))

get_EKi : AES_GCM_Ctx -> [16][8]
get_EKi ctx = EKi ctx (get_i ctx)

get_EK0 : AES_GCM_Ctx -> [16][8]
get_EK0 ctx = EKi ctx 0

update_enc_array_buf :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  Array [64] [8]
update_enc_array_buf in ctx buf i len =
  (update_enc_array in ctx buf i len).1

update_enc_array_ctx :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  AES_GCM_Ctx
update_enc_array_ctx in ctx buf i len =
  (update_enc_array in ctx buf i len).0

update_enc_array :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  (AES_GCM_Ctx, Array [64] [8])
update_enc_array in ctx buf i len =
  update_bulk_encrypt in ctx buf i len

  //  if n != 0 then
  //    update_enc_prephase in ctx buf n 15 i len
  //  else
  //    update_bulk_encrypt in ctx buf i len

  // where
  //  n = ctx.len % 16


update_enc_prephase :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] -> // concrete bound to force termination
  [64] ->
  [64] ->
  (AES_GCM_Ctx, Array [64] [8])
update_enc_prephase in ctx buf n bnd i len =
  if (n > 0 /\ len > 0 /\ bnd > 0) then
    update_enc_prephase in
      { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len + 1 }
      buf'
      ((n+1)%16) (bnd-1) (i+1) (len-1)
     where
       Xi'  = update ctx.Xi n (ctx.Xi@n ^ b)
       buf' = arrayUpdate buf i b
       b    = arrayLookup in i ^ EK_byte ctx

   | n == 0 then update_bulk_encrypt in ctx buf i len

   else (ctx, buf)


update_bulk_encrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  (AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
update_bulk_encrypt in ctx buf i len =
   update_postbulk_encrypt
     in 
     { key = ctx.key, iv = ctx.iv, Xi = Xi_final, len = ctx.len + res_len }
     out_data
     (i + res_len)
     (len - res_len)

  where
    out_data = aes_hw_ctr32_encrypt_blocks_array in ctx.key (get_Yi ctx) i (res_len/16) buf
    Xi_final = cipher_update_Xi_array ctx out_data 0 res_len ctx.Xi

    bulk_len = max `(18 * 16)
                    ((len / `(6 * 16)) * `(6 * 16))
    do_bulk  = len / bulk_len
    res_len  = do_bulk * bulk_len
    
update_postbulk_encrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  (AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
// len < 18*AES_BLOCK_SIZE
update_postbulk_encrypt in ctx buf i len =
  (if len_blocks != 0 then
     update_cleanup_encrypt in
       { key = ctx.key, iv = ctx.iv, Xi = Xi_final, len = ctx.len + len_blocks }
       out_data
       (i + len_blocks)
       (len - len_blocks)
       15

      where
        out_data = aes_hw_ctr32_encrypt_blocks_array
	              in ctx.key (get_Yi ctx) i (len_blocks/16) buf
        Xi_final = gcm_ghash_array (join (get_H ctx)) ctx.Xi in i (len_blocks/16)

   else
     update_cleanup_encrypt in ctx buf i len 15)

  where
    len_blocks = len && 0xFFFFFFFFFFFFFFF0
    
update_cleanup_encrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  [64] -> // concrete bound to force termination
  (AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
// len < 16
update_cleanup_encrypt in ctx buf i len bnd = (ctx, buf)

  // if len != 0 /\ bnd > 0 then
  //   update_cleanup_encrypt in
  //     { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len+1 }
  //     buf' (i+1) (len-1) (bnd-1)
  //    where
  //     Xi'  = update ctx.Xi n (ctx.Xi@n ^ b)
  //     buf' = arrayUpdate buf i b
  //     b    = arrayLookup in i ^ EK_byte ctx
  //     n    = ctx.len % 16

  // else
  //   (ctx, buf)
