/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

module AES_GCM where

import Array

import Primitive::Symmetric::Cipher::Block::AES
import Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM
import X86


/*
 * Helpers.
 */
swap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a
swap8 x = join`{each=8} (reverse (split`{each=8} x))

swap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a
swap128 x = join`{each=128} (reverse (split`{each=128} x))

hi_bits : {n} (fin n) => [2 * n] -> [n]
hi_bits = take

lo_bits : {n} (fin n) => [2 * n] -> [n]
lo_bits = drop


/*
 * AES specifications.
 */
aes_key_to_schedule : [Nr + 1][128] -> KeySchedule
aes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)
  where
    key' = map msgToState_x86 key

aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]
aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))
  where
    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])

inv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]
inv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))
  where
    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])

aes_hw_decrypt : [16][8] -> [32][8] -> [16][8]
aes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))

aes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]
aes_hw_ctr32_encrypt_blocks in key (iv # ctr) =
  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]

aes_hw_ctr32_encrypt_blocks_array : Array [64] [8] -> [32][8] -> [16][8] -> [64] -> [64] -> Array [64] [8] -> Array [64] [8]
aes_hw_ctr32_encrypt_blocks_array inp key (iv # (ctr:[4][8])) i blocks buf =
  if i < blocks then
    aes_hw_ctr32_encrypt_blocks_array inp key (iv # ctr) (i+1) blocks buf'
      where
        blk  = arrayRangeLookup inp (i*16) : [16][8]
	blk' = blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + drop`{32} i))) key)
	buf' = arrayRangeUpdate buf (i*16) blk'
  else
    buf

aes_hw_ctr32_eq_property : {blocks} (fin blocks, width (16*blocks) <= 64) =>
  (Array [64] [8] -> Array [64] [8] -> Bool) ->
  Array [64] [8] -> [32][8] -> [16][8] -> Array [64] [8] -> Bool
aes_hw_ctr32_eq_property f in key iv out =
  f (aes_hw_ctr32_encrypt_blocks_array in key iv 0 `blocks out)
    (arrayRangeUpdate out 0 (aes_hw_ctr32_encrypt_blocks (arrayRangeLookup`{n=16*blocks} in 0) key iv))


aes_hw_ctr32_copy_property : {blocks} (fin blocks, width (16*blocks) <= 64) =>
  (Array [64] [8] -> Array [64] [8] -> Bool) ->
  Array [64] [8] -> [32][8] -> [16][8] -> Array [64] [8] -> Bool
aes_hw_ctr32_copy_property f in key iv out =
  f (arrayCopy out 0 (aes_hw_ctr32_encrypt_blocks_array in key iv 0 `blocks out) 0 `(16*blocks))
    (aes_hw_ctr32_encrypt_blocks_array in key iv 0 `blocks out)

EK_byte : AES_GCM_Ctx -> [8]
EK_byte ctx = (EKi ctx i) @ j
  where
    i : [32]
    i = take`{32} (drop`{28} ctx.len) + 1

    j : [4]
    j = drop`{60} ctx.len

cipher_update_array : AES_GCM_Ctx -> Array [64] [8] -> [64] -> [64] -> AES_GCM_Ctx
cipher_update_array ctx in i len =
  { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len + len }
 where
   Xi' = cipher_update_Xi_array ctx in i len ctx.Xi

cipher_update_Xi_array :
  AES_GCM_Ctx -> Array [64] [8] -> [64] -> [64] -> [16][8] -> [16][8]
cipher_update_Xi_array ctx in i len Xi =
  if i < len then
    cipher_update_Xi_array ctx in (i+1) len Xi''
      where
        H    = gcm_init_H (join (get_H ctx))
	n    = (ctx.len+i) % 16
        Xi'  = update Xi n ((Xi@n)^b)
	Xi'' = if (ctx.len+(i+1))%16 == 0
	        then split (gcm_pmult_pmod H (join Xi'))
	        else Xi'
        b    = arrayLookup in i
  else
    Xi

/*
 * GCM specifications.
 */
gcm_init : [2][64] -> [12][128]
gcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))

gcm_init_Htable : [128] -> [12][128]
gcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]
  where
    h1 = gcm_polyval h0 h0
    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))
    h3 = gcm_polyval h0 h1
    h4 = gcm_polyval h0 h3
    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))
    h6 = gcm_polyval h0 h4
    h7 = gcm_polyval h0 h6
    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))
    h9 = gcm_polyval h0 h7
    h10 = gcm_polyval h0 h9
    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))

gcm_gmult : [128] -> [16][8] -> [16][8]
gcm_gmult H Xi = split (gcm_polyval H (join Xi))

gcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]
gcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))

gcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]
gcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)

gcm_ghash_array : [128] -> [16][8] -> Array [64] [8] -> [64] -> [64] -> [16][8]
gcm_ghash_array H Xi inp i blocks =
  if i < blocks then
    gcm_ghash_array H (gcm_ghash_block H Xi (arrayRangeLookup inp (i * 16) : [16][8])) inp (i+1) blocks
  else
    Xi

gcm_ghash_array_eq_property : {blocks} (fin blocks, width (blocks*16) < 64 )  => [128] -> [16][8] -> Array [64] [8] -> Bool
gcm_ghash_array_eq_property H Xi inp =
  gcm_ghash_array H Xi inp 0 `blocks ==
  gcm_ghash`{n=blocks} H Xi (arrayRangeLookup`{n=blocks*16} inp 0)


// Restatement of gcm_ghash_array, useful for stating/proving
// the fixpoint lemma
gcm_ghash_array_unfold : [128] -> [16][8] -> Array [64] [8] -> [64] -> [64] -> [16][8]
gcm_ghash_array_unfold H Xi inp i blocks =
  if i < blocks then
    gcm_ghash_array H (gcm_ghash_block H Xi (arrayRangeLookup inp (i * 16) : [16][8])) inp (i+1) blocks
  else
    Xi

/*
 * AES_GCM context specification helpers.
 */
get_Htable : AES_GCM_Ctx -> [12][128]
get_Htable ctx = gcm_init (get_H ctx)

get_i : AES_GCM_Ctx -> [32]
get_i ctx = drop ((ctx.len + 15) / 16)

get_Yi : AES_GCM_Ctx -> [16][8]
get_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))

get_EKi : AES_GCM_Ctx -> [16][8]
get_EKi ctx = EKi ctx (get_i ctx)

get_EK0 : AES_GCM_Ctx -> [16][8]
get_EK0 ctx = EKi ctx 0


zeroByteArray : Array [64] [8]
zeroByteArray = arrayConstant 0

update_enc_array :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
update_enc_array in ctx buf i len =
//    if (prephase_len != len) then
      (prephase_len + bulk_len + len_blocks, ctx2, buf2)
//    else
//      (prephase_len, ctx0, buf0)

  where
    // TODO!
    (prephase_len, ctx0, buf0) = (0, ctx, buf)
      // update_enc_prephase in ctx buf (ctx.len%16) i len

    (bulk_len, ctx1, buf1) = update_bulk_encrypt in ctx0 buf0 (i + prephase_len) (len - prephase_len)

    (len_blocks, ctx2, buf2) =
      update_postbulk_encrypt in ctx1 buf1 (i + (prephase_len + bulk_len)) (len - (prephase_len + bulk_len))

    // TODO! postphase


update_enc_prephase :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
update_enc_prephase in0 ctx0 buf0 n0 i0 len0 =
  if (n0 > 0) then
    loop in0 ctx0 buf0 n0 0 16 i0 len0
  else
    (0, ctx0, buf0)

 where
  // bnd is a conrete upper bound to force symbolic termination
  loop in ctx buf n count bnd i len =
    if (n > 0 /\ len > 0 /\ bnd > 0) then
       loop
         in
         { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len + 1 }
         buf'
         ((n+1)%16) (count+1) (bnd-1) (i+1) (len-1)
    else
      if (n == 0) then
        (count, { key = ctx.key, iv = ctx.iv, Xi = gcm_gmult H ctx.Xi, len = ctx.len }, buf)
      else
        (count, ctx, buf)

   where
     H    = gcm_init_H (join (get_H ctx))

     Xi'  = update ctx.Xi n (ctx.Xi@n ^ b)
     buf' = arrayUpdate buf i b
     b    = arrayLookup in i ^ EK_byte ctx
   
update_bulk_encrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
update_bulk_encrypt in ctx buf i len =

    ( res_len
    , { key = ctx.key, iv = ctx.iv, Xi = Xi_final, len = ctx.len + res_len }
    , arrayCopy buf i out_data 0 res_len
    )

  where
    out_data = aes_hw_ctr32_encrypt_blocks_array
                  in // (arrayCopy zeroByteArray 0 in i res_len)
		  ctx.key
		  (get_Yi ctx)
		  0
		  (res_len/16)
		  buf // (arrayCopy zeroByteArray 0 buf i res_len)

    Xi_final = cipher_update_Xi_array ctx out_data 0 res_len ctx.Xi

    len32 = drop`{32} len
    bulk_len = max `(3 * 6 * 16)
                    ( (len32 / `(6 * 16)) * `(6 * 16))
    do_bulk  = len32 / bulk_len
    res_len  = zext (do_bulk * bulk_len)


update_postbulk_encrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
// len < 18*AES_BLOCK_SIZE
update_postbulk_encrypt in ctx buf i len =
  (if len_blocks == 0 then
    (0, ctx, buf)
   else
    ( len_blocks
    , { key = ctx.key, iv = ctx.iv, Xi = Xi_final, len = ctx.len + len_blocks }
    , arrayCopy buf i out_data 0 len_blocks
    )
      where
        out_data = aes_hw_ctr32_encrypt_blocks_array
                      (arrayCopy zeroByteArray 0 in i len_blocks)
	              ctx.key (get_Yi ctx) 0 (len_blocks/16)
		      (arrayCopy zeroByteArray 0 buf i len_blocks)
        Xi_final = gcm_ghash_array (gcm_init_H (join (get_H ctx)))
	              ctx.Xi
	              (arrayCopy zeroByteArray 0 (arrayCopy buf i out_data 0 len_blocks) i len_blocks)
		      0
		      (len_blocks/16)
   )

  where
    len_blocks = len && 0xFFFFFFFFFFFFFFF0
    
update_cleanup_encrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  [64] -> // concrete bound to force termination
  (AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
// len < 16
update_cleanup_encrypt in ctx buf i len bnd = (ctx, buf)

  // if len != 0 /\ bnd > 0 then
  //   update_cleanup_encrypt in
  //     { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len+1 }
  //     buf' (i+1) (len-1) (bnd-1)
  //    where
  //     Xi'  = update ctx.Xi n (ctx.Xi@n ^ b)
  //     buf' = arrayUpdate buf i b
  //     b    = arrayLookup in i ^ EK_byte ctx
  //     n    = ctx.len % 16

  // else
  //   (ctx, buf)



update_dec_array :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
update_dec_array in ctx buf i len =
//    if (prephase_len != len) then
      (prephase_len + bulk_len + len_blocks, ctx2, buf2)
//    else
//      (prephase_len, ctx0, buf0)

  where
    // TODO!
    (prephase_len, ctx0, buf0) = (0, ctx, buf)
      // update_dec_prephase in ctx buf (ctx.len%16) i len

    (bulk_len, ctx1, buf1) = update_bulk_decrypt in ctx0 buf0 (i + prephase_len) (len - prephase_len)

    (len_blocks, ctx2, buf2) =
      update_postbulk_decrypt in ctx1 buf1 (i + (prephase_len + bulk_len)) (len - (prephase_len + bulk_len))

    // TODO! postphase


update_bulk_decrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
update_bulk_decrypt in ctx buf i len =

    ( res_len
    , { key = ctx.key, iv = ctx.iv, Xi = Xi_final, len = ctx.len + res_len }
    , arrayCopy buf i out_data 0 res_len
    )

  where
    out_data = aes_hw_ctr32_encrypt_blocks_array
                  in // (arrayCopy zeroByteArray 0 in i res_len)
		  ctx.key
		  (get_Yi ctx)
		  0
		  (res_len/16)
		  buf // (arrayCopy zeroByteArray 0 buf i res_len)

    Xi_final = cipher_update_Xi_array ctx in 0 res_len ctx.Xi // TODO? array copy from in?

    len32 = drop`{32} len
    bulk_len = max `(6 * 16)
                    ( (len32 / `(6 * 16)) * `(6 * 16))
    do_bulk  = len32 / bulk_len
    res_len  = zext (do_bulk * bulk_len)


update_postbulk_decrypt :
  Array [64] [8] ->
  AES_GCM_Ctx ->
  Array [64] [8] ->
  [64] ->
  [64] ->
  ([64], AES_GCM_Ctx, Array [64] [8])
// Precondition ctx.len is a multiple of 16
// len < 18*AES_BLOCK_SIZE
update_postbulk_decrypt in ctx buf i len =
  (if len_blocks == 0 then
    (0, ctx, buf)
   else
    ( len_blocks
    , { key = ctx.key, iv = ctx.iv, Xi = Xi_final, len = ctx.len + len_blocks }
    , arrayCopy buf i out_data 0 len_blocks
    )
      where
        out_data = aes_hw_ctr32_encrypt_blocks_array
                      (arrayCopy zeroByteArray 0 in i len_blocks)
	              ctx.key (get_Yi ctx) 0 (len_blocks/16)
		      (arrayCopy zeroByteArray 0 buf i len_blocks)
        Xi_final = gcm_ghash_array (gcm_init_H (join (get_H ctx)))
	              ctx.Xi
	              (arrayCopy zeroByteArray 0 in i len_blocks)
		      0
		      (len_blocks/16)
   )

  where
    len_blocks = len && 0xFFFFFFFFFFFFFFF0
