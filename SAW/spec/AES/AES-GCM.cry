/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

module AES_GCM where

import Array

import Primitive::Symmetric::Cipher::Block::AES
import Primitive::Symmetric::Cipher::Authenticated::AES_256_GCM
import X86


/*
 * Helpers.
 */
swap8 : {parts, a} (fin parts) => [parts * 8]a -> [parts * 8]a
swap8 x = join`{each=8} (reverse (split`{each=8} x))

swap128 : {parts, a} (fin parts) => [parts * 128]a -> [parts * 128]a
swap128 x = join`{each=128} (reverse (split`{each=128} x))

hi_bits : {n} (fin n) => [2 * n] -> [n]
hi_bits = take

lo_bits : {n} (fin n) => [2 * n] -> [n]
lo_bits = drop


/*
 * AES specifications.
 */
aes_key_to_schedule : [Nr + 1][128] -> KeySchedule
aes_key_to_schedule key = (key' @ 0, key' @@ [1 .. (Nr - 1)], key' @ `Nr)
  where
    key' = map msgToState_x86 key

aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]
aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (key' @@ [2 .. Nr])))
  where
    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])

inv_aes_key_from_schedule : KeySchedule -> [4 * (Nr - 1)][32]
inv_aes_key_from_schedule (init_key, middle_keys, final_key) = join (map reverse (map split (reverse (key' @@ [2 .. Nr]))))
  where
    key' = map stateToMsg_x86 ([init_key] # middle_keys # [final_key])

aes_hw_decrypt : [16][8] -> [32][8] -> [16][8]
aes_hw_decrypt in key = split (aesDecrypt ((join in), (join key)))

aes_hw_ctr32_encrypt_blocks : {n} (fin n) => [16*n][8] -> [32][8] -> [16][8] -> [16*n][8]
aes_hw_ctr32_encrypt_blocks in key (iv # ctr) =
  join [ blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + i))) key) | blk <- split in | i <- [(0 : [32]) ...]]

aes_hw_ctr32_encrypt_blocks_array : Array [64] [8] -> [32][8] -> [16][8] -> [64] -> [64] -> Array [64] [8] -> Array [64] [8]
aes_hw_ctr32_encrypt_blocks_array inp key (iv # (ctr:[4][8])) i blocks buf =
  if i < blocks then
    aes_hw_ctr32_encrypt_blocks_array inp key (iv # ctr) (i+1) blocks buf'
      where
        blk  = arrayRangeLookup inp (i*16) : [16][8]
	blk' = blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + drop`{32} i))) key)
	buf' = arrayRangeUpdate buf (i*16) blk'
  else
    buf

aes_hw_ctr32_encrypt_blocks_array_unfold : Array [64] [8] -> [32][8] -> [16][8] -> [64] -> [64] -> Array [64] [8] -> Array [64] [8]
aes_hw_ctr32_encrypt_blocks_array_unfold inp key (iv # (ctr:[4][8])) i blocks buf =
  if i < blocks then
    aes_hw_ctr32_encrypt_blocks_array inp key (iv # ctr) (i+1) blocks buf'
      where
        blk  = arrayRangeLookup inp (i*16) : [16][8]
	blk' = blk ^ (aes_hw_encrypt (iv # (split ((join ctr) + drop`{32} i))) key)
	buf' = arrayRangeUpdate buf (i*16) blk'
  else
    buf


aes_hw_ctr32_eq_property : {blocks} (fin blocks, width (16*blocks) <= 64) =>
  (Array [64] [8] -> Array [64] [8] -> Bool) ->
  Array [64] [8] -> [32][8] -> [16][8] -> Array [64] [8] -> Bool
aes_hw_ctr32_eq_property f in key iv out =
  f (aes_hw_ctr32_encrypt_blocks_array in key iv 0 `blocks out)
    (arrayRangeUpdate out 0 (aes_hw_ctr32_encrypt_blocks (arrayRangeLookup`{n=16*blocks} in 0) key iv))


aes_hw_ctr32_copy_property : {blocks} (fin blocks, width (16*blocks) <= 64) =>
  (Array [64] [8] -> Array [64] [8] -> Bool) ->
  Array [64] [8] -> [32][8] -> [16][8] -> Array [64] [8] -> Bool
aes_hw_ctr32_copy_property f in key iv out =
  f (arrayCopy out 0 (aes_hw_ctr32_encrypt_blocks_array in key iv 0 `blocks out) 0 `(16*blocks))
    (aes_hw_ctr32_encrypt_blocks_array in key iv 0 `blocks out)

EK_byte : AES_GCM_Ctx -> [8]
EK_byte ctx = (EKi ctx i) @ j
  where
    i : [32]
    i = take`{32} (drop`{28} ctx.len) + 1

    j : [4]
    j = drop`{60} ctx.len

cipher_update_array : AES_GCM_Ctx -> Array [64] [8] -> [64] -> [64] -> AES_GCM_Ctx
cipher_update_array ctx in i len =
  { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len + len }
 where
   Xi' = cipher_update_Xi_array ctx in i len ctx.Xi

cipher_update_Xi_array :
  AES_GCM_Ctx -> Array [64] [8] -> [64] -> [64] -> [16][8] -> [16][8]
cipher_update_Xi_array ctx in i len Xi =
  if i < len then
    cipher_update_Xi_array ctx in (i+1) len Xi''
      where
        H    = gcm_init_H (join (get_H ctx))
	n    = (ctx.len+i) % 16
        Xi'  = update Xi n ((Xi@n)^b)
	Xi'' = if (ctx.len+(i+1))%16 == 0
	        then split (gcm_pmult_pmod H (join Xi'))
	        else Xi'
        b    = arrayLookup in i
  else
    Xi

/*
 * GCM specifications.
 */
gcm_init : [2][64] -> [12][128]
gcm_init Xi = gcm_init_Htable (gcm_init_H (join Xi))

gcm_init_Htable : [128] -> [12][128]
gcm_init_Htable h0 = [h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11]
  where
    h1 = gcm_polyval h0 h0
    h2 = ((hi_bits h1) ^ (lo_bits h1)) # ((hi_bits h0) ^ (lo_bits h0))
    h3 = gcm_polyval h0 h1
    h4 = gcm_polyval h0 h3
    h5 = ((hi_bits h4) ^ (lo_bits h4)) # ((hi_bits h3) ^ (lo_bits h3))
    h6 = gcm_polyval h0 h4
    h7 = gcm_polyval h0 h6
    h8 = ((hi_bits h7) ^ (lo_bits h7)) # ((hi_bits h6) ^ (lo_bits h6))
    h9 = gcm_polyval h0 h7
    h10 = gcm_polyval h0 h9
    h11 = ((hi_bits h9) ^ (lo_bits h9)) # ((hi_bits h10) ^ (lo_bits h10))

gcm_gmult : [128] -> [16][8] -> [16][8]
gcm_gmult H Xi = split (gcm_polyval H (join Xi))

gcm_ghash_block : [128] -> [16][8] -> [16][8] -> [16][8]
gcm_ghash_block H Xi inp = split (gcm_polyval H ((join Xi) ^ (join inp)))

gcm_ghash : {n} (fin n) => [128] -> [16][8] -> [n * 16][8] -> [16][8]
gcm_ghash H Xi inp = foldl (gcm_ghash_block H) Xi (split inp)

gcm_ghash_array : [128] -> [16][8] -> Array [64] [8] -> [64] -> [64] -> [16][8]
gcm_ghash_array H Xi inp i blocks =
  if i < blocks then
    gcm_ghash_array H (gcm_ghash_block H Xi (arrayRangeLookup inp (i * 16) : [16][8])) inp (i+1) blocks
  else
    Xi

gcm_ghash_array_eq_property : {blocks} (fin blocks, width (blocks*16) < 64 )  => [128] -> [16][8] -> Array [64] [8] -> Bool
gcm_ghash_array_eq_property H Xi inp =
  gcm_ghash_array H Xi inp 0 `blocks ==
  gcm_ghash`{n=blocks} H Xi (arrayRangeLookup`{n=blocks*16} inp 0)


// Restatement of gcm_ghash_array, useful for stating/proving
// the fixpoint lemma
gcm_ghash_array_unfold : [128] -> [16][8] -> Array [64] [8] -> [64] -> [64] -> [16][8]
gcm_ghash_array_unfold H Xi inp i blocks =
  if i < blocks then
    gcm_ghash_array H (gcm_ghash_block H Xi (arrayRangeLookup inp (i * 16) : [16][8])) inp (i+1) blocks
  else
    Xi

/*
 * AES_GCM context specification helpers.
 */
get_Htable : AES_GCM_Ctx -> [12][128]
get_Htable ctx = gcm_init (get_H ctx)

get_i : AES_GCM_Ctx -> [32]
get_i ctx = drop ((ctx.len + 15) / 16)

get_Yi : AES_GCM_Ctx -> [16][8]
get_Yi ctx = ctx.iv # (split ((get_i ctx) + 2))

get_EKi : AES_GCM_Ctx -> [16][8]
get_EKi ctx = EKi ctx (get_i ctx)

get_EK0 : AES_GCM_Ctx -> [16][8]
get_EK0 ctx = EKi ctx 0


zeroByteArray : Array [64] [8]
zeroByteArray = arrayConstant 0

