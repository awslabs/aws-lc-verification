/* 
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

// Include HMAC helper functions.
include "HMAC-common.saw";

// Specification of the HMAC_Final function
let HMAC_Final_spec withLength num = do {
  // Precondition: The function uses the AVX+shrd code path
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `digest_ptr` is a pointer to a const `env_md_st` satisfying the
  // `points_to_env_md_st` specification
  digest_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st digest_ptr;

  // Precondition: `hmac_ctx_ptr` is a pointer to an `hmac_ctx_st`
  hmac_ctx_ptr <- crucible_alloc (llvm_struct "struct.hmac_ctx_st");
  // Precondition: `hmac_ctx` is a fresh Cryptol HMACState
  hmac_ctx <- fresh_hmac_state_st "hmac_ctx" num;
  // Precondition: `i_ctx_ptr`, `o_ctx_ptr`, and `md_ctx_ptr` are
  // `sha512_state_st` structs
  (i_ctx_ptr, o_ctx_ptr, md_ctx_ptr) <- alloc_sha512_state_sts;
  // Precondition: `hmac_ctx_ptr` matches `hmac_ctx`
  points_to_hmac_ctx_st hmac_ctx_ptr digest_ptr hmac_ctx num i_ctx_ptr o_ctx_ptr md_ctx_ptr;

  // Precondition: out_ptr is allocated and correct length, and 
  // out_len_ptr is null or points to an int.
  (out_ptr, out_len_ptr) <- digestOut_pre withLength;

  // Call function with `hmac_ctx_ptr`, `out_ptr`, and `out_len_ptr`
  crucible_execute_func [ hmac_ctx_ptr , out_ptr , out_len_ptr ];

  // Postcondition: The function has not changed the variable that decides the
  // AVX+shrd code path
  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The contents of the array pointed to by `out_ptr` match the
  // result returned by the HMACFinal cryptol spec.
  // If length output is used, out_len_ptr points to correct length.
  digestOut_post withLength out_ptr out_len_ptr (crucible_term {{ HMACFinal hmac_ctx }});

  // Postcondition: The function returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

// Verify the `HMAC_Final` C function satisfies the `HMAC_Final_spec`
// specification.
let HMAC_Final_ovs =
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ];

let verify_HMAC_Final_spec withLength num = do {
  print (str_concat "Verifying HMAC_Final_spec at num=" (show num));
  crucible_llvm_verify m "HMAC_Final"
    HMAC_Final_ovs
    true
    (HMAC_Final_spec withLength num)
    (w4_unint_yices ["processBlock_Common"]);
};

let verify_final_with_length withLength = do {
  // There are 2 cases to consider to ensure the proof covers all possible code
  // paths through the update function
  // Case 1: num=111 covers the case with one call to the block function
  (verify_HMAC_Final_spec withLength 111);
  // Case 2: num=112 covers the case with two calls to the block function
  (verify_HMAC_Final_spec withLength 112);
};

let verify_final_with_num target_num = do {
  (verify_HMAC_Final_spec false target_num);
  (verify_HMAC_Final_spec true target_num);
};

if HMAC_quick_check then do {
  for [false, true] verify_final_with_length;
  return();
} else do {
  // range of valid indices in the internal block ([0 .. (SHA512_CBLOCK - 1)])
  // nums <- for (eval_list {{ [0 .. (SHA512_CBLOCK - 1)] : [SHA512_CBLOCK][64] }})
  //  (\x -> (return (eval_int x)) : (TopLevel Int));
  // for nums verify_final_with_num;
  verify_final_with_num HMAC_target_num;
  return();
};
