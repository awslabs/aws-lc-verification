/* 
* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
* SPDX-License-Identifier: Apache-2.0
*/

enable_experimental;

// The following lists are used to compute identifiers for digest functions
// and structs. Using parallel lists is the simplest way to do this in SAW.
// The lists below must be kept in sync.
let MDS = ["SHA256", "SHA1", "SHA384", "SHA512", "MD5", "SHA224", "SHA512_256"];
let EVP_MDS = ["EVP_sha256", "EVP_sha1", "EVP_sha384", "EVP_sha512", "EVP_md5", "EVP_sha224", "EVP_sha512_256"];
let MD_INDICES = [0, 1, 2, 3, 4, 5, 6];

let HMAC_MD = (nth MDS HMAC_MD_INDEX);
let HMAC_MD_TRAMPOLINE = (str_concat "AWS_LC_TRAMPOLINE_" HMAC_MD);
let HMAC_MD_INIT = (str_concat HMAC_MD_TRAMPOLINE "_Init");
let HMAC_MD_UPDATE = (str_concat HMAC_MD_TRAMPOLINE "_Update");
let HMAC_MD_FINAL = (str_concat HMAC_MD_TRAMPOLINE "_Final");

let md_storage index = (str_concat (nth EVP_MDS index) "_storage");
let md_once index = (str_concat (nth EVP_MDS index) "_once");
let md_init index = (str_concat (nth EVP_MDS index) "_init");

let HMAC_METHODS = "AWSLC_hmac_in_place_methods";
let HMAC_METHODS_STORAGE = (str_concat HMAC_METHODS "_storage");
let HMAC_METHODS_ONCE = (str_concat HMAC_METHODS "_once");
let HMAC_METHODS_INIT = (str_concat HMAC_METHODS "_init");

// The specs for the globals used with digests and CRYPTO_once
// For the digest that is being verified, this spec states that 
// "storage" global is set correctly after the function returns.
// The init functions are verified, and then we assume a similar
// spec on CRYPTO_once.

// The init function spec states that the function produces the 
// correct struct for the digests used with HMAC. For other digests,
// the spec says nothing about the content of the struct.
let evp_md_methods_init_spec index = do {

  crucible_alloc_global (md_storage index);
  crucible_alloc_global (md_once index);
  
  crucible_execute_func [];

  if (eval_bool {{`index == `HMAC_MD_INDEX}}) then do {
    points_to_env_md_st (crucible_global (md_storage index));
  } else do {
    return ();
  };
};

// This is the spec for the invocation of CRYPTO_once that produces
// the digest structs. It matches the spec of the init function.
let evp_md_methods_spec index = do {
  crucible_alloc_global (md_storage index);
  crucible_alloc_global (md_once index);
  crucible_execute_func
    [ (crucible_global (md_once index))
    , (crucible_global (md_init index))
    ];

  if (eval_bool {{`index == `HMAC_MD_INDEX}}) then do {
    points_to_env_md_st (crucible_global (md_storage index));
  } else do {
    return ();
  };
  
};

let points_to_md_methods md ptr md_ptr = do {

  crucible_points_to (crucible_elem ptr 0) md_ptr;

  if md then do {
    crucible_points_to (crucible_elem ptr 1) (crucible_global HMAC_MD_INIT);
    crucible_points_to (crucible_elem ptr 2) (crucible_global HMAC_MD_UPDATE);
    crucible_points_to (crucible_elem ptr 3) (crucible_global HMAC_MD_FINAL);
  } else do {
    return ();
  };
};


let alloc_md_global index = do {
  crucible_alloc_global (md_storage index);
  crucible_alloc_global (md_once index);
};

let alloc_md_globals = do {
  for MD_INDICES alloc_md_global;
};

let alloc_hmac_globals = do {
  crucible_alloc_global HMAC_METHODS_STORAGE;
  crucible_alloc_global HMAC_METHODS_ONCE;
};

let points_to_md_methods_index ptr index = do {
  points_to_md_methods 
    (eval_bool {{`index == `HMAC_MD_INDEX}}) 
    (crucible_elem ptr index) 
    (crucible_global (md_storage index));
};

let points_to_hmac_in_place_methods ptr = do {

  // The global for the digest that is actually used is correct
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX)); 

  // The evp_md pointers are used as identifiers, and we search through them in order.
  // So we need a spec stating that the pointer values do not equal
  // the value for which we are searching.
  // Because these pointers have separate allocations, they must have different values.

  for MD_INDICES (\x -> points_to_md_methods_index ptr x);
  return ();

};

// The spec of the init function that produces the HMAC in place methods struct
let hmac_in_place_methods_init_spec = do {

  alloc_md_globals;
  alloc_hmac_globals;

  crucible_execute_func [];

  points_to_hmac_in_place_methods (crucible_elem (crucible_global HMAC_METHODS_STORAGE) 0);
};

// The spec for the invocation of CRYPTO_once that produces the HMAC in place
// methods struct. This spec matches the spec for the init function that
// produces this struct.
let hmac_in_place_methods_spec = do {
  alloc_md_globals;
  alloc_hmac_globals;

  crucible_execute_func
    [ (crucible_global HMAC_METHODS_ONCE)
    , (crucible_global HMAC_METHODS_INIT)
    ];
  points_to_hmac_in_place_methods (crucible_elem (crucible_global HMAC_METHODS_STORAGE) 0);
};

let global_md_methods = (crucible_elem (crucible_field (crucible_global HMAC_METHODS_STORAGE) "methods") HMAC_MD_INDEX);

let points_to_AWSLC_hmac_in_place_methods md_ptr = do {
  points_to_md_methods true global_md_methods md_ptr;
};

let GetInPlaceMethods_spec = do {

  alloc_md_globals;
  alloc_hmac_globals;

  crucible_execute_func [(crucible_global (md_storage HMAC_MD_INDEX))];

  points_to_hmac_in_place_methods (crucible_elem (crucible_global HMAC_METHODS_STORAGE) 0);

  crucible_return global_md_methods;
};

// Size of the hmac_ctx_st struct
let HMAC_CTX_SIZE = llvm_sizeof m (llvm_struct "struct.hmac_ctx_st");

// Specify that the fields of an `hmac_ctx_st` are null
let zeroed_hmac_ctx_st ptr = do {
  crucible_points_to (crucible_field ptr "md") crucible_null;
  crucible_points_to (crucible_field ptr "methods") crucible_null;

  crucible_points_to (crucible_field ptr "state") (crucible_term {{0:[8]}});
};

let points_to_hmac_ctx_state ptr = do {
  state <- crucible_fresh_var "state" (llvm_int 8);
  crucible_points_to (crucible_field ptr "state") (crucible_term state);

  return {{ state }};
};

let hmac_ctx_is_initialized ptr = do {
  state <- points_to_hmac_ctx_state ptr;
  crucible_precond {{state == 1 \/ state == 2}};
};

// Make a symbolic hmac_state_st
let fresh_hmac_state_st_array name = do {
  i_ctx <- fresh_sha512_state_st_array_n32 (str_concat name ".i_ctx");
  o_ctx <- fresh_sha512_state_st (str_concat name ".o_ctx") 0;
  md_ctx <- fresh_sha512_state_st_array_n32 (str_concat name ".md_ctx");

  return {{ { i_ctx = i_ctx, o_ctx = o_ctx, md_ctx = md_ctx } }};
};

let fresh_hmac_state_st_array_uninitialized name = do {
  i_ctx <- fresh_sha512_state_st_array_n32_uninitialized (str_concat name ".i_ctx");
  o_ctx <- fresh_sha512_state_st_uninitialized (str_concat name ".o_ctx");
  md_ctx <- fresh_sha512_state_st_array_n32_uninitialized (str_concat name ".md_ctx");

  return {{ { i_ctx = i_ctx, o_ctx = o_ctx, md_ctx = md_ctx } }};
};

// The points-to for i_ctx, o_ctx and md_ctx inside a hmac_ctx_st
let points_to_hmac_ctx_st_sha_ctx_array ptr context = do {
  let i_ctx_ptr = llvm_cast_pointer (llvm_field ptr "i_ctx") (llvm_alias "struct.sha512_state_st");
  let o_ctx_ptr = llvm_cast_pointer (llvm_field ptr "o_ctx") (llvm_alias "struct.sha512_state_st");
  let md_ctx_ptr = llvm_cast_pointer (llvm_field ptr "md_ctx") (llvm_alias "struct.sha512_state_st");

  points_to_sha512_state_st_array_n32 i_ctx_ptr {{ context.i_ctx }};
  points_to_sha512_state_st o_ctx_ptr {{ context.o_ctx }} 0;
  points_to_sha512_state_st_array_n32 md_ctx_ptr {{ context.md_ctx }};
};

let points_to_hmac_ctx_st_sha_ctx_array_uninitialized ptr context = do {
  let i_ctx_ptr = llvm_cast_pointer (llvm_field ptr "i_ctx") (llvm_alias "struct.sha512_state_st");
  let o_ctx_ptr = llvm_cast_pointer (llvm_field ptr "o_ctx") (llvm_alias "struct.sha512_state_st");
  let md_ctx_ptr = llvm_cast_pointer (llvm_field ptr "md_ctx") (llvm_alias "struct.sha512_state_st");

  points_to_sha512_state_st_array_n32_uninitialized i_ctx_ptr {{ context.i_ctx }};
  points_to_sha512_state_st_uninitialized o_ctx_ptr {{ context.o_ctx }} 0;
  points_to_sha512_state_st_array_n32_uninitialized md_ctx_ptr {{ context.md_ctx }};
};

// The points-to for hmac_ctx_st
let points_to_hmac_ctx_st_array ptr context = do {
  points_to_hmac_ctx_st_sha_ctx_array ptr context;

  crucible_points_to (crucible_field ptr "md") (crucible_global (md_storage HMAC_MD_INDEX));

  crucible_alloc_global HMAC_METHODS_STORAGE;
  points_to_AWSLC_hmac_in_place_methods (crucible_global (md_storage HMAC_MD_INDEX));
  crucible_points_to (crucible_field ptr "methods") global_md_methods;
};

let points_to_hmac_ctx_st_array_uninitialized ptr context = do {
  points_to_hmac_ctx_st_sha_ctx_array_uninitialized ptr context;
  zeroed_hmac_ctx_st ptr;
};

// hmac_ctx has been initialized and state is either 1 or 2
let hmac_ctx_has_been_initialized ptr = do {
  state <- points_to_hmac_ctx_state ptr;
  crucible_postcond {{state == 1 \/ state == 2}};
};

// hmac_ctx is ready for use but still need HMAC_Init_ex called
let hmac_ctx_ready_precond ptr = do {
  state <- points_to_hmac_ctx_state ptr;
  crucible_precond {{state == 3}};
};

let hmac_ctx_ready_postcond ptr = do {
  state <- points_to_hmac_ctx_state ptr;
  crucible_postcond {{state == 3}};
};

// The invariable that internal buffer offsets n are less than SHA512_CBLOCK and
// the internal buffer offset for o_ctx equal 0
let hmac_ctx_n_inv ctx = {{
  ctx.i_ctx.n < `SHA512_CBLOCK /\
  ctx.o_ctx.n == 0 /\
  ctx.md_ctx.n < `SHA512_CBLOCK
}};
let hmac_ctx_n_precond ctx = crucible_precond (hmac_ctx_n_inv ctx);
let hmac_ctx_n_postcond ctx = crucible_postcond (hmac_ctx_n_inv ctx);

let hmac_precond ptr ctx = do {
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));
  hmac_ctx_is_initialized ptr;
  hmac_ctx_n_precond ctx;
};

let hmac_postcond ptr ctx = do {
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));
  hmac_ctx_has_been_initialized ptr;
  hmac_ctx_n_postcond ctx;
};

let hmac_ready_precond ptr ctx = do {
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));
  hmac_ctx_ready_precond ptr;
  hmac_ctx_n_precond ctx;
};

let hmac_ready_postcond ptr ctx = do {
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));
  hmac_ctx_ready_postcond ptr;
  hmac_ctx_n_postcond ctx;
};

// Specification for HMAC_CTX_init
let HMAC_CTX_init_array_spec = do {
  hmac_ctx_ptr <- crucible_alloc (llvm_struct "struct.hmac_ctx_st");

  crucible_execute_func [hmac_ctx_ptr];

  hmac_ctx <- fresh_hmac_state_st_array_uninitialized "hmac_ctx";
  points_to_hmac_ctx_st_array_uninitialized hmac_ctx_ptr hmac_ctx;
};

// Specification for HMAC_Init_ex_array
let HMAC_Init_ex_arrayRangeEq_i_ctx = "HMAC_Init_ex.arrayRangeEq.i_ctx";
let HMAC_Init_ex_arrayRangeEq_md_ctx = "HMAC_Init_ex.arrayRangeEq.md_ctx";

let HMAC_Init_ex_array_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;
  alloc_hmac_globals;
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  hmac_ctx_ptr <- llvm_alloc (llvm_struct "struct.hmac_ctx_st");
  hmac_ctx <- fresh_hmac_state_st_array_uninitialized "hmac_ctx";
  points_to_hmac_ctx_st_array_uninitialized hmac_ctx_ptr hmac_ctx;

  key_len <- crucible_fresh_var "key_len" i64;
  (key, key_ptr) <- ptr_to_fresh_array_readonly "key" key_len;

  // The ENGINE input is not used in the body of function HMAC_Init_ex
  // (The assertion is optimized away by LLVM).
  // Due to LLVM optimizations, the ENGINE input argument is optimized to be `undef`.
  // When conducting an override with HMAC_Init_ex, `crucible_null` will not match
  // with `undef`. Making engine_ptr a crucible_fresh_var allows the override to succeed.
  engine_ptr <- crucible_fresh_var "engine_ptr" i64;

  crucible_execute_func
  [ hmac_ctx_ptr
  , key_ptr
  , (crucible_term key_len)
  , (crucible_global (md_storage HMAC_MD_INDEX))
  , (crucible_term engine_ptr)
  ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  let res = {{ HMACInit_Array hmac_ctx key key_len }};
  // There exists a ByteArray called res_i_ctx_block, satisfying the constraint that
  // its first 128 bytes is equal to the first 128 bytes of the result res.i_ctx.block returned from the spec,
  // such that the result of the C function HMAC_Init_ex points to it.
  res_i_ctx_block <- crucible_fresh_cryptol_var "res_i_ctx_block" {| ByteArray |};
  res_md_ctx_block <- crucible_fresh_cryptol_var "res_md_ctx_block" {| ByteArray |};
  points_to_hmac_ctx_st_array
    hmac_ctx_ptr
    {{ { i_ctx = { h = res.i_ctx.h, block = res_i_ctx_block, n = res.i_ctx.n, sz = res.i_ctx.sz }
       , o_ctx = res.o_ctx
       , md_ctx = { h = res.md_ctx.h, block = res_md_ctx_block, n = res.md_ctx.n, sz = res.md_ctx.sz } } }};
  // llvm_setup_with_tag tags this postcondition with the name "HMAC_Init_ex.arrayRangeEq.i_ctx"
  // so that the proof script can refer to this subgoal
  llvm_setup_with_tag HMAC_Init_ex_arrayRangeEq_i_ctx
    (crucible_postcond {{ arrayRangeEq res_i_ctx_block 0 res.i_ctx.block 0 `SHA512_CBLOCK }});
  llvm_setup_with_tag HMAC_Init_ex_arrayRangeEq_md_ctx
    (crucible_postcond {{ arrayRangeEq res_md_ctx_block 0 res.md_ctx.block 0 `SHA512_CBLOCK }});

  hmac_postcond hmac_ctx_ptr res;

  crucible_return (crucible_term {{ 1 : [32] }});
};

let HMAC_Init_ex_null_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;

  hmac_ctx_ptr <- llvm_alloc (llvm_struct "struct.hmac_ctx_st");
  hmac_ctx <- fresh_hmac_state_st_array "hmac_ctx";
  points_to_hmac_ctx_st_array hmac_ctx_ptr hmac_ctx;
  hmac_ready_precond hmac_ctx_ptr hmac_ctx;

  // The ENGINE input is not used in the body of function HMAC_Init_ex
  // (The assertion is optimized away by LLVM).
  // Due to LLVM optimizations, the ENGINE input argument is optimized to be `undef`.
  // When conducting an override with HMAC_Init_ex, `crucible_null` will not match
  // with `undef`. Making engine_ptr a crucible_fresh_var allows the override to succeed.
  engine_ptr <- crucible_fresh_var "engine_ptr" i64;

  crucible_execute_func
  [ hmac_ctx_ptr
  , crucible_null
  , (crucible_term {{ 0 : [64] }})
  , crucible_null
  , (crucible_term engine_ptr)
  ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};
  points_to_hmac_ctx_st_array hmac_ctx_ptr hmac_ctx;
  hmac_postcond hmac_ctx_ptr hmac_ctx;

  crucible_return (crucible_term {{ 1 : [32] }});
};

// Specification for HMAC_Update_Array
let HMAC_Update_array_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;

  hmac_ctx_ptr <- llvm_alloc (llvm_struct "struct.hmac_ctx_st");
  hmac_ctx <- fresh_hmac_state_st_array "hmac_ctx";
  points_to_hmac_ctx_st_array hmac_ctx_ptr hmac_ctx;
  hmac_precond hmac_ctx_ptr hmac_ctx;

  len <- crucible_fresh_var "len" i64;
  (data, data_ptr) <- ptr_to_fresh_array_readonly "data" len;

  crucible_execute_func [ hmac_ctx_ptr , data_ptr , (crucible_term len) ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  let res = {{ HMACUpdate_Array hmac_ctx data len }};
  res_md_ctx_block <- crucible_fresh_cryptol_var "res_md_ctx_block" {| ByteArray |};
  points_to_hmac_ctx_st_array
    hmac_ctx_ptr
    {{ { i_ctx = res.i_ctx
       , o_ctx = res.o_ctx
       , md_ctx = { h = res.md_ctx.h, block = res_md_ctx_block, n = res.md_ctx.n, sz = res.md_ctx.sz } } }};
  // There exists a ByteArray called res_i_ctx_block, satisfying the constraint that
  // its first 128 bytes is equal to the first 128 bytes of the result res.md_ctx.block returned from the spec,
  // such that the result of the C function HMAC_Update points to it
  crucible_postcond {{ arrayRangeEq res_md_ctx_block 0 res.md_ctx.block 0 `SHA512_CBLOCK }};

  hmac_postcond hmac_ctx_ptr res;

  crucible_return (crucible_term {{ 1 : [32] }});
};

// Specification for HMAC_Final_Array
let HMAC_Final_array_spec withLength = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;

  hmac_ctx_ptr <- llvm_alloc (llvm_struct "struct.hmac_ctx_st");
  hmac_ctx <- fresh_hmac_state_st_array "hmac_ctx";
  points_to_hmac_ctx_st_array hmac_ctx_ptr hmac_ctx;
  hmac_precond hmac_ctx_ptr hmac_ctx;

  (md_out_ptr, s_ptr) <- digestOut_pre withLength;

  crucible_execute_func [ hmac_ctx_ptr , md_out_ptr, s_ptr ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  digestOut_post withLength md_out_ptr s_ptr (crucible_term {{ HMACFinal_Array hmac_ctx }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

// Specification for HMAC_Final_Array with postcond on hmac_ctx
let HMAC_Final_array_with_hmac_ctx_spec withLength = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;

  hmac_ctx_ptr <- llvm_alloc (llvm_struct "struct.hmac_ctx_st");
  hmac_ctx <- fresh_hmac_state_st_array "hmac_ctx";
  points_to_hmac_ctx_st_array hmac_ctx_ptr hmac_ctx;
  hmac_precond hmac_ctx_ptr hmac_ctx;

  (md_out_ptr, s_ptr) <- digestOut_pre withLength;

  crucible_execute_func [ hmac_ctx_ptr , md_out_ptr, s_ptr ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  let res = {{ { i_ctx = hmac_ctx.i_ctx , o_ctx = hmac_ctx.o_ctx , md_ctx = hmac_ctx.i_ctx } }};
  res_md_ctx_block <- crucible_fresh_cryptol_var "res_md_ctx_block" {| ByteArray |};
  points_to_hmac_ctx_st_array
    hmac_ctx_ptr
    {{ { i_ctx = res.i_ctx
       , o_ctx = res.o_ctx
       , md_ctx = { h = res.md_ctx.h, block = res_md_ctx_block, n = res.md_ctx.n, sz = res.md_ctx.sz } } }};
  // We say the hmac_ctx.md_ctx.block points to some block res_md_ctx_block.
  // Since the content in block doesn't matter, this postcondition is enough for
  // satisfying the preconditions of the next HMAC_Init_ex call.
  hmac_ready_postcond hmac_ctx_ptr res;

  digestOut_post withLength md_out_ptr s_ptr (crucible_term {{ HMACFinal_Array hmac_ctx }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

// Specification for HMAC_array
let HMAC_md_out = "HMAC.md_out";

let HMAC_array_spec withLength = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;
  alloc_hmac_globals;
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  key_len <- crucible_fresh_var "key_len" i64;
  (key, key_ptr) <- ptr_to_fresh_array_readonly "key" key_len;
  data_len <- crucible_fresh_var "data_len" i64;
  (data, data_ptr) <- ptr_to_fresh_array_readonly "data" data_len;

  (md_out_ptr, md_out_len_ptr) <- digestOut_pre withLength;

  crucible_execute_func
  [ (crucible_global (md_storage HMAC_MD_INDEX))
  , key_ptr
  , (crucible_term key_len)
  , data_ptr
  , (crucible_term data_len)
  , md_out_ptr
  , md_out_len_ptr
  ];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  // llvm_setup_with_tag tags this postcondition with the name "HMAC.md_out"
  // so that the proof script can refer to this subgoal
  llvm_setup_with_tag HMAC_md_out
    (digestOut_post withLength md_out_ptr md_out_len_ptr (crucible_term {{ HMAC_Array (HMACState_zeroized) key key_len data data_len }}));

  crucible_return md_out_ptr;
};
