enable_experimental;

import "../../../cryptol-specs/Primitive/Keyless/Hash/HMAC.cry";

// Load LLVM bytecode
m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";

// Include helper functions
include "../common/helpers.saw";

// Include SHA512-384 proof
include "../SHA512/verify-SHA512-384-quickcheck.saw";

// Recursively specify that the fields of an `hmac_ctx_st` are null
let zeroed_hmac_ctx_st ptr = do {
  crucible_points_to (crucible_field ptr "md") crucible_null;
  points_to_env_md_ctx_st (crucible_field ptr "i_ctx") crucible_null crucible_null;
  points_to_env_md_ctx_st (crucible_field ptr "o_ctx") crucible_null crucible_null;
  points_to_env_md_ctx_st (crucible_field ptr "md_ctx") crucible_null crucible_null;
};

// Specification of the HMAC_CTX_init function
let HMAC_CTX_init_spec = do {
  // Precondition: `ctx_ptr` points to an `hmac_ctx_st` struct
  ctx_ptr <- crucible_alloc (llvm_struct "struct.hmac_ctx_st");

  // Call function with `ctx_ptr`
  crucible_execute_func [ctx_ptr];

  // Postcondition: The struct pointed to by `ctx_ptr` has been zeroed out
  zeroed_hmac_ctx_st ctx_ptr;
};

// Specify the relation between  hmac_ctx_st and HMACState
let points_to_hmac_ctx_st ptr md_ptr context = do {
  // Allocate state structs for `i_ctx`, `o_ctx`, and `md_ctx` fields in `ptr`
  i_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  o_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");
  md_ctx_ptr <- crucible_alloc (llvm_struct "struct.sha512_state_st");

  // Check that `i_ctx`, `o_ctx`, and `md_ctx` match the spec.  We set the
  // `num` argument to 0 because HMAC_Init_ex pads or hashes the key to make it
  // exactly 128 bytes, so the `block` field of these structs is uninitialized
  // by the SHA384 update function
  points_to_sha512_state_st i_ctx_ptr {{ context.i_ctx }} 0;
  points_to_sha512_state_st o_ctx_ptr {{ context.o_ctx }} 0;
  points_to_sha512_state_st md_ctx_ptr {{ context.md_ctx }} 0;

  // Specify that the struct pointed by `ptr` references `i_ctx`, `o_ctx`, and
  // `md_ctx`.  The `md_data` field of these structs are all the same.
  points_to_env_md_ctx_st (crucible_field ptr "i_ctx") md_ptr i_ctx_ptr;
  points_to_env_md_ctx_st (crucible_field ptr "o_ctx") md_ptr o_ctx_ptr;
  points_to_env_md_ctx_st (crucible_field ptr "md_ctx") md_ptr md_ctx_ptr;

  // Specify that `ptr.md` matches `md_ptr`
  crucible_points_to (crucible_field ptr "md") md_ptr;
};

// Specification of the HMAC_Init_ex function
let HMAC_Init_ex_spec key_len = do {
  // Precondition: The function uses the AVX+shrd code path
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Precondition: `ctx_ptr` points to a zeroed out `hmac_ctx_st`
  ctx_ptr <- crucible_alloc (llvm_struct "struct.hmac_ctx_st");
  zeroed_hmac_ctx_st ctx_ptr;

  // Precondition: `key` is an array of `key_len` bytes.  `key_ptr` points to
  // `key`.
  (key, key_ptr) <- ptr_to_fresh_readonly "key" (llvm_array key_len (llvm_int 8));

  // Precondition: `md_ptr` points to a const `env_md_st` struct satisfying the
  // `env_md_st` specification.
  md_ptr <- crucible_alloc_readonly (llvm_struct "struct.env_md_st");
  points_to_env_md_st md_ptr;

  // Call function with `ctx_ptr`, `key_ptr`, `key_len`, `md_ptr`, and NULL
  crucible_execute_func
    [ ctx_ptr
    , key_ptr
    , crucible_term {{ `key_len : [64] }}
    , md_ptr
    , crucible_null
    ];

  // Postcondition: The function has not changed the variable that decides the
  // AVX+shrd code path
  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  // Postcondition: The data pointed to by `ctx_ptr` matches the context
  // returned by the cryptol function `HMACInit` when applied to `key`.
  points_to_hmac_ctx_st ctx_ptr md_ptr {{ HMACInit key }};

  // Postcondition: The function returns 1
  crucible_return (crucible_term {{ 1 : [32] }});
};

// Verify the `HMAC_CTX_init` C function satisfies the `HMAC_CTX_init_spec`
// specification
crucible_llvm_verify m "HMAC_CTX_init"
  []
  true
  HMAC_CTX_init_spec
  (w4_unint_yices []);

// Verify the `HMAC_Init_ex` C function satisfies the `HMAC_Init_ex_spec`
// specification.  There are two cases to consider.
crucible_llvm_verify m "HMAC_Init_ex"
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // key_len=128 covers the case where the key is less than or equal to 128
  // bytes long and will be used as-is when XORed to create the pad inputs to
  // the SHA384 update function calls
  (HMAC_Init_ex_spec 128)
  (w4_unint_yices []);
crucible_llvm_verify m "HMAC_Init_ex"
  [ sha512_block_data_order_spec
  , OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  ]
  true
  // key_len=129 covers the case where the key is greater than 128 bytes long
  // and will be hashed before being XORed to create the pad inputs to the
  // SHA384 update function calls
  (HMAC_Init_ex_spec 129)
  (w4_unint_yices []);
