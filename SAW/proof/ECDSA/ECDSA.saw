/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/


import "../../../cryptol-specs/Common/EC/EC_P384.cry";
import "../../../cryptol-specs/Common/utils.cry";


include "../SHA512/SHA512-384-common.saw";
include "../common/internal.saw";


include "goal-rewrites.saw";


/*
 * Verification parameters.
 */
let r_bits = 383;
let s_bits = 383;
let r_bytes = eval_size {| r_bits / 8 + 1 |};
let s_bytes = eval_size {| s_bits / 8 + 1 |};
// compute the ASN1 signature length (in bytes)
let compute_asn1_sig_len r_len s_len = eval_size {| 1 /* sequence tag */ + 1 /* sequence len */ + 1 /* integer tag */ + 1 /* integer len */ + r_len + 1 /* integer tag */ + 1 /* integer len */ + s_len |};
let sig_len = compute_asn1_sig_len r_bytes s_bytes;


let EVP_PKEY_OP_SIGN = 8; // (1 << 3)
let EVP_PKEY_OP_VERIFY = 16; // (1 << 4)


let ecdsa_sig_st = "struct.DSA_SIG_st";


include "../BN/BN.saw";
include "../EC/EC.saw";
include "memory.saw";


let max_ec_bytes = eval_size {| ec_bits / 8 + 1 |};
let max_sig_len = compute_asn1_sig_len max_ec_bytes max_ec_bytes;


let digest_to_scalar_spec = do {
  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  out_ptr <- crucible_alloc (llvm_array EC_MAX_WORDS i64);
  (digest, digest_ptr) <- ptr_to_fresh_readonly "digest" (llvm_array SHA_DIGEST_LENGTH i8);

  crucible_execute_func [ec_group_ptr, out_ptr, digest_ptr, (crucible_term {{ `SHA_DIGEST_LENGTH : [64] }})];

  crucible_points_to_untyped out_ptr (crucible_term {{ scalarToBV ((scalarFromBV (join digest)) % `P384_n) }});
};


let points_to_ecdsa_sig_st ptr r_ptr s_ptr = do {
  crucible_points_to (crucible_field ptr "r") r_ptr;
  crucible_points_to (crucible_field ptr "s") s_ptr;
};

let points_to_fresh_asn1_sig ptr = do {
  r <- crucible_fresh_var "r" (llvm_array r_bytes i8);
  s <- crucible_fresh_var "s" (llvm_array s_bytes i8);
  let seq_len = eval_size {| 1 + 1 + r_bytes + 1 + 1 + s_bytes |};
  crucible_points_to_untyped ptr
    (crucible_struct
      [ crucible_term {{ 0x30 : [8] }} // ASN1 sequence tag
      , crucible_term {{ `seq_len : [8] }}
      , crucible_term {{ 0x02 : [8] }} // ASN1 integer tag
      , crucible_term {{ `r_bytes : [8] }}
      , crucible_term r
      , crucible_term {{ 0x02 : [8] }} // ASN1 integer tag
      , crucible_term {{ `s_bytes : [8] }}
      , crucible_term s
      ]);
  return (r, s);
};


let {{
is_num_bits_bn : {m} (m <= P384_w) => [P384_w] -> Bit
is_num_bits_bn x = if `m == `P384_w
  then x @ 0
  else take`{P384_w - m} x == 0 /\ x @ (`P384_w - `m)
}};


// Create a symbolic integer to be used as the random integer `k` by the sign
// operation. Assume that the signature of `digest` with `priv_key` using `k`
// is valid, that is, that `r` and `s` are non-zero. Assume that the bitwidth
// of `r` is `r_bits` and the bitwidth of `s` is `s_bits`.
let nondeterministic_valid_k priv_key digest = do {
  k <- crucible_fresh_cryptol_var "k" {| Integer |};
  crucible_precond {{ k % `P384_n != 0 }};
  let sig = {{ ECDSA_sign (scalarFromBV priv_key) (scalarFromBV (join digest)) (k % `P384_n) }};
  crucible_precond {{ sig.r != 0 }};
  crucible_precond {{ sig.s != 0 }};
  crucible_precond {{ is_num_bits_bn`{r_bits} (scalarToBV sig.r) }};
  crucible_precond {{ is_num_bits_bn`{s_bits} (scalarToBV sig.s) }};
  crucible_ghost_value ec_random_nonzero_scalar_out k;
  crucible_ghost_value bn_rand_range_words_out      k;
  return k;
};


let ECDSA_do_sign_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  (digest, digest_ptr) <- ptr_to_fresh_readonly "digest" (llvm_array SHA_DIGEST_LENGTH i8);

  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  (ec_key_ptr, _pub_key, priv_key) <- pointer_to_fresh_ec_key_st ec_group_ptr true;

  // the symbolic integer to be used as the random integer `k` by the sign
  // operation
  k <- nondeterministic_valid_k priv_key digest;

  crucible_execute_func [digest_ptr, (crucible_term {{ `SHA_DIGEST_LENGTH : [64] }}), ec_key_ptr];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  res_ptr <- crucible_alloc (llvm_struct ecdsa_sig_st);
  r_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (r, r_d_ptr) <- ptr_to_fresh "r" i384;
  points_to_p384_bignum_st r_ptr r_d_ptr BN_FLG_MALLOCED;
  s_ptr <- crucible_alloc (llvm_struct "struct.bignum_st");
  (s, s_d_ptr) <- ptr_to_fresh "s" i384;
  points_to_p384_bignum_st s_ptr s_d_ptr BN_FLG_MALLOCED;
  points_to_ecdsa_sig_st res_ptr r_ptr s_ptr;

  let res = {{ ECDSA_sign (scalarFromBV priv_key) (scalarFromBV (join digest)) (k % `P384_n) }};
  crucible_postcond {{ r == scalarToBV res.r }};
  crucible_postcond {{ s == scalarToBV res.s }};

  crucible_return res_ptr;
};


let ECDSA_do_verify_spec = do {
  (digest, digest_ptr) <- ptr_to_fresh_readonly "digest" (llvm_array SHA_DIGEST_LENGTH i8);

  sig_ptr <- crucible_alloc_readonly (llvm_struct ecdsa_sig_st);
  r_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (r, r_d_ptr) <- ptr_to_fresh_readonly "r" i384;
  points_to_p384_bignum_st r_ptr r_d_ptr BN_FLG_MALLOCED;
  s_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (s, s_d_ptr) <- ptr_to_fresh_readonly "s" i384;
  points_to_p384_bignum_st s_ptr s_d_ptr BN_FLG_MALLOCED;
  points_to_ecdsa_sig_st sig_ptr r_ptr s_ptr;

  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  (ec_key_ptr, pub_key, _priv_key) <- pointer_to_fresh_ec_key_st ec_group_ptr false;

  crucible_execute_func [digest_ptr, (crucible_term {{ `SHA_DIGEST_LENGTH : [64] }}), sig_ptr, ec_key_ptr];

  let ret = {{ ECDSA_verify (fromJacobian (jacobianFromMontBV pub_key)) (scalarFromBV (join digest)) { r = (scalarFromBV r), s = (scalarFromBV s) } }};
  crucible_return (crucible_term {{ if ret then 1 : [32] else 0 }});
};


// Specifications of the various EVP functions
include "evp-function-specs.saw";


////////////////////////////////////////////////////////////////////////////////
// Proof commands

BN_num_bits_r_bits_ov <- llvm_verify m "BN_num_bits"
  []
  true
  (BN_num_bits_spec r_bits)
  (w4_unint_yices []);
BN_num_bits_s_bits_ov <- llvm_verify m "BN_num_bits"
  []
  true
  (BN_num_bits_spec s_bits)
  (w4_unint_yices []);
BN_num_bits_ec_bits_ov <- llvm_verify m "BN_num_bits"
  []
  true
  (BN_num_bits_spec ec_bits)
  (w4_unint_yices []);


// digest_to_scalar_ov <- llvm_verify m "digest_to_scalar"
//   [ bn_reduce_once_in_place_false_ov
//   ]
//   true
//   digest_to_scalar_spec
//   (do {
//     goal_eval_unint [];
//     simplify (addsimp append_assoc_thm empty_ss);
//     simplify (addsimp append_assoc_thm2 empty_ss);
//     w4_unint_z3 [];
//   });


// assume (without proving) the equivalence of point operations in affine and
// jacobian coordinates
jacobian_affine_0_thm <- prove_print
  (do {
    assume_unsat;
  })
  (rewrite (cryptol_ss ()) {{ \k -> fromJacobian { x = ((ec_point_jacobian_scalar_mul (k % `P384_n) P384_G_Jacobian).x % `P384_p), y = ((ec_point_jacobian_scalar_mul (k % `P384_n) P384_G_Jacobian).y % `P384_p), z = ((ec_point_jacobian_scalar_mul (k % `P384_n) P384_G_Jacobian).z % `P384_p) } == ec_point_affine_scalar_mul (k % `P384_n) P384_G }});
jacobian_affine_1_thm <- prove_print
  (do {
    assume_unsat;
  })
  (rewrite (cryptol_ss ()) {{ \u1 u2 Q -> fromJacobian { x = ((ec_point_jacobian_add (ec_point_jacobian_scalar_mul (u1 % `P384_n) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (u2 % `P384_n) Q)).x % `P384_p), y = ((ec_point_jacobian_add (ec_point_jacobian_scalar_mul (u1 % `P384_n) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (u2 % `P384_n) Q)).y % `P384_p), z = ((ec_point_jacobian_add (ec_point_jacobian_scalar_mul (u1 % `P384_n) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (u2 % `P384_n) Q)).z % `P384_p) } == ec_point_affine_add (ec_point_affine_scalar_mul (u1 % `P384_n) P384_G) (ec_point_affine_scalar_mul (u2 % `P384_n) (fromJacobian Q)) }});

let prove_folding_theorem t = prove_print z3 (rewrite (cryptol_ss ()) t);
let prove_folding_theorem_w4 t = prove_print w4 (rewrite (cryptol_ss ()) t);
let assume_folding_theorem t = prove_print assume_unsat (rewrite (cryptol_ss ()) t);

append_slice_384_thm_0 <- prove_folding_theorem
  {{ \(x : [48][8]) -> ((x @ (0 : [8])) # ((x @ (1 : [8])) # ((x @ (2 : [8])) # ((x @ (3 : [8])) # ((x @ (4 : [8])) # ((x @ (5 : [8])) # ((x @ (6 : [8])) # (x @ (7 : [8]))))))))) == slice_0_64_320 (join x) }};
append_slice_384_thm_1 <- prove_folding_theorem
  {{ \(x : [48][8]) -> ((x @ (8 : [8])) # ((x @ (9 : [8])) # ((x @ (10 : [8])) # ((x @ (11 : [8])) # ((x @ (12 : [8])) # ((x @ (13 : [8])) # ((x @ (14 : [8])) # (x @ (15 : [8]))))))))) == slice_64_64_256 (join x) }};
append_slice_384_thm_2 <- prove_folding_theorem
  {{ \(x : [48][8]) -> ((x @ (16 : [8])) # ((x @ (17 : [8])) # ((x @ (18 : [8])) # ((x @ (19 : [8])) # ((x @ (20 : [8])) # ((x @ (21 : [8])) # ((x @ (22 : [8])) # (x @ (23 : [8]))))))))) == slice_128_64_192 (join x) }};
append_slice_384_thm_3 <- prove_folding_theorem
  {{ \(x : [48][8]) -> ((x @ (24 : [8])) # ((x @ (25 : [8])) # ((x @ (26 : [8])) # ((x @ (27 : [8])) # ((x @ (28 : [8])) # ((x @ (29 : [8])) # ((x @ (30 : [8])) # (x @ (31 : [8]))))))))) == slice_192_64_128 (join x) }};
append_slice_384_thm_4 <- prove_folding_theorem
  {{ \(x : [48][8]) -> ((x @ (32 : [8])) # ((x @ (33 : [8])) # ((x @ (34 : [8])) # ((x @ (35 : [8])) # ((x @ (36 : [8])) # ((x @ (37 : [8])) # ((x @ (38 : [8])) # (x @ (39 : [8]))))))))) == slice_256_64_64 (join x) }};
append_slice_384_thm_5 <- prove_folding_theorem
  {{ \(x : [48][8]) -> ((x @ (40 : [8])) # ((x @ (41 : [8])) # ((x @ (42 : [8])) # ((x @ (43 : [8])) # ((x @ (44 : [8])) # ((x @ (45 : [8])) # ((x @ (46 : [8])) # (x @ (47 : [8]))))))))) == slice_320_64_0 (join x) }};
mul_if_thm <- prove_folding_theorem
  {{ \(b : Bit) (x : [64]) t f -> x * (if b then t else f) == if b then (x * t) else (x * f) }};
and_if_zero_thm_0 <- prove_folding_theorem
  {{ \(x : [64]) (b : Bit) -> (if b then 0 else ~0) && x == if b then 0 else x }};
and_if_zero_thm_1 <- prove_folding_theorem
  {{ \(x : [64]) (b : Bit) -> x && (if b then 0 else ~0) == if b then 0 else x }};
xor_if_zero_thm <- prove_folding_theorem
  {{ \(x : [64]) (b : Bit) -> x ^ (if b then 0 else x) == if b then x else 0 }};
or_if_thm <- prove_folding_theorem
  {{ \(x1 : [64]) x2 y (b : Bit) -> (if b then x1 else y) || (if b then x2 else 0) == if b then (x1 || x2) else y }};
or_zero_thm <- prove_folding_theorem
  {{ \(x : [64]) -> 0 || x == x }};
append_if_thm_64_64 <- prove_folding_theorem
  {{ \(b : Bit) (x1 : [64]) (x2 : [64]) (y1 : [64]) (y2 : [64]) -> (if b then x1 else y1) # (if b then x2 else y2) == if b then (x1 # x2) else (y1 # y2) }};
append_if_thm_128_128 <- prove_folding_theorem
  {{ \(b : Bit) (x1 : [128]) (x2 : [128]) (y1 : [128]) (y2 : [128]) -> (if b then x1 else y1) # (if b then x2 else y2) == if b then (x1 # x2) else (y1 # y2) }};
append_if_thm_64_256 <- prove_folding_theorem
  {{ \(b : Bit) (x1 : [64]) (x2 : [256]) (y1 : [64]) (y2 : [256]) -> (if b then x1 else y1) # (if b then x2 else y2) == if b then (x1 # x2) else (y1 # y2) }};
append_if_thm_64_320 <- prove_folding_theorem
  {{ \(b : Bit) (x1 : [64]) (x2 : [320]) (y1 : [64]) (y2 : [320]) -> (if b then x1 else y1) # (if b then x2 else y2) == if b then (x1 # x2) else (y1 # y2) }};
append_slice_thm <- prove_folding_theorem
  {{ \x -> (slice_0_64_320 x) # ((slice_64_64_256 x) # (((slice_128_64_192 x) # (slice_192_64_128 x)) # ((slice_256_64_64 x) # (slice_320_64_0 x)))) == x }};

let append_slice_384_thms =
  [ append_slice_384_thm_0
  , append_slice_384_thm_1
  , append_slice_384_thm_2
  , append_slice_384_thm_3
  , append_slice_384_thm_4
  , append_slice_384_thm_5
  , mul_if_thm
  , and_if_zero_thm_0
  , and_if_zero_thm_1
  , xor_if_zero_thm
  , or_if_thm
  , or_zero_thm
  , append_if_thm_64_64
  , append_if_thm_128_128
  , append_if_thm_64_256
  , append_if_thm_64_320
  , append_slice_thm
  ];

complement_false_thm <- prove_folding_theorem
  {{ complement False == True }};
complement_true_thm <- prove_folding_theorem
  {{ complement True == False }};
or_false_thm <- prove_folding_theorem
  {{ \(x : Bit) -> False || x == x }};
or_true_thm <- prove_folding_theorem
  {{ \(x : Bit) -> True || x == True }};
and_true_thm <- prove_folding_theorem
  {{ \(x : Bit) -> True && x == x }};
and_same_thm <- prove_folding_theorem
  {{ \(x : Bit) -> x && x == x }};

let minor_touchup_thms =
  [ complement_false_thm
  , complement_true_thm
  , or_false_thm
  , or_true_thm
  , and_true_thm
  ];

let
{{
apply : {s, t} (s -> t) -> s -> t
apply f x = f x
}};

add_negate_thm <- prove_folding_theorem
  {{ \(x : Integer) (y : Integer) -> (x + negate y) == (x - y) }};
fromToInteger_thm <- prove_folding_theorem_w4
  {{ \(x : [384]) -> fromInteger (toInteger x) == x }};
eq_modulo_arith_thm <- prove_folding_theorem_w4
  {{ \(x : Integer) (y : Integer) (z : Integer) ->
    ((x * ((y - `P384_n) + z)) % `P384_n) == ((x * (y + z)) % `P384_n) }};

// These theorems are true, but every SMT solver I've tried takes a really long time to prove them.
// The uses of `apply` are to ensure that rewriting does not go into an infinite loop.
let intLe = parse_core "\\(x y : Integer) -> intLe x y";
toInteger_sub_thm0 <- assume_folding_theorem
  {{ \(x : [384]) ->
    (toInteger x - `P384_n) ==
    (if (intLe `P384_n (toInteger x)) then (toInteger (x - `P384_n)) else (apply (-) (toInteger x) `P384_n)) }};
toInteger_sub_thm1 <- assume_folding_theorem
  {{ \(x : [384]) ->
    (toInteger (x - `P384_n)) ==
    (if (intLe `P384_n (toInteger x)) then (toInteger x - `P384_n) else (apply toInteger (x - `P384_n))) }};

ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
  [ sha512_block_data_order_spec
  , ec_bignum_to_scalar_ov
  // , ec_scalar_to_montgomery_ov
  // , ec_scalar_to_montgomery_same_ov
  // , ec_scalar_from_montgomery_ov
  // , ec_scalar_from_montgomery_same_ov
  , ec_scalar_add_ov
  , ec_scalar_add_same_l_ov
  // , ec_scalar_mul_montgomery_ov
  // , ec_scalar_mul_montgomery_same_l_ov
  // , ec_scalar_mul_montgomery_same_r_ov
  , ec_simple_scalar_inv0_montgomery_ov
  , ec_random_nonzero_scalar_ov
  // , ec_point_mul_scalar_base_ov
  // , ec_point_mul_scalar_public_ov
  , ec_cmp_x_coordinate_ov
  , ec_get_x_coordinate_as_scalar_ov
  // , digest_to_scalar_ov
  , ec_scalar_is_zero_false_ov
  , BN_is_zero_false_ov
  , OPENSSL_malloc_ov
  , OPENSSL_cleanse_ov
  , bn_rand_range_words_ov
  , bn_sub_words_ov
  , bn_from_montgomery_small_ov
  , bn_from_montgomery_small_same_ov
  , bn_mod_mul_montgomery_small_ov
  , bn_mod_mul_montgomery_small_same_l_ov
  , bn_mod_mul_montgomery_small_same_r_ov
  , bn_mod_mul_montgomery_small_RR_d_ov
  , bn_mod_mul_montgomery_small_RR_d_same_ov
  , ec_GFp_mont_mul_base_ov
  , ec_GFp_simple_is_on_curve_ov
  , ec_GFp_mont_mul_public_batch_ov
  ]
  true
  ECDSA_do_sign_spec
  (do {
    unfolding ["ECDSA_sign"];
    unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
    simplify (cryptol_ss ());
    simplify (addsimp scalarBV_thm empty_ss);
    simplify (addsimp fieldElementBV_thm empty_ss);
    simplify (addsimps mont_thms empty_ss);
    simplify (addsimp jacobian_affine_0_thm empty_ss);
    simplify (addsimps mod_thms empty_ss);
    goal_eval_unint ["inv0", "ec_point_affine_scalar_mul"];

    // These are only needed when optimization is enabled
    simplify (addsimp append_assoc_thm empty_ss);
    simplify (addsimp append_assoc_thm2 empty_ss);
    simplify (addsimp append_at_thm empty_ss);
    simplify (addsimps append_slice_384_thms empty_ss);
    hoist_ifs_in_goal;
    simplify (addsimps minor_touchup_thms empty_ss);
    simplify (addsimps [add_negate_thm, toInteger_sub_thm0] empty_ss);
    hoist_ifs_in_goal;
    simplify (addsimps minor_touchup_thms empty_ss);
    simplify (addsimp fromToInteger_thm empty_ss);
    simplify (addsimp toInteger_sub_thm1 empty_ss);
    hoist_ifs_in_goal;
    simplify (addsimps minor_touchup_thms empty_ss);
    simplify (addsimp eq_modulo_arith_thm empty_ss);

    w4_unint_z3 ["inv0", "ec_point_affine_scalar_mul"];
  });

ECDSA_do_verify_ov <- llvm_verify m "ECDSA_do_verify"
  [ BN_is_zero_ov
  , ec_bignum_to_scalar_ov
  // , ec_scalar_to_montgomery_ov
  // , ec_scalar_to_montgomery_same_ov
  // , ec_scalar_from_montgomery_ov
  // , ec_scalar_from_montgomery_same_ov
  , ec_scalar_add_ov
  // , ec_scalar_mul_montgomery_ov
  // , ec_scalar_mul_montgomery_same_r_ov
  , ec_simple_scalar_inv0_montgomery_ov
  , ec_scalar_is_zero_ov
  , ec_random_nonzero_scalar_ov
  // , ec_point_mul_scalar_base_ov
  // , ec_point_mul_scalar_public_ov
  , ec_cmp_x_coordinate_ov
  , ec_get_x_coordinate_as_scalar_ov
  // , digest_to_scalar_ov
  , bn_reduce_once_in_place_false_ov
  , bn_from_montgomery_small_ov
  , bn_from_montgomery_small_same_ov
  , bn_mod_mul_montgomery_small_ov
  , bn_mod_mul_montgomery_small_same_r_ov
  , bn_mod_mul_montgomery_small_RR_d_ov
  , bn_mod_mul_montgomery_small_RR_d_same_ov
  , ERR_put_error_ov
  , ec_GFp_mont_mul_base_ov
  , ec_GFp_simple_is_on_curve_ov
  , ec_GFp_mont_mul_public_batch_ov
  ]
  true
  ECDSA_do_verify_spec
  (do {
    unfolding ["ECDSA_verify"];
    unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
    simplify (cryptol_ss ());
    simplify (addsimp scalarBV_thm empty_ss);
    simplify (addsimp fieldElementBV_thm empty_ss);
    simplify (addsimps mont_thms empty_ss);
    simplify (addsimp jacobian_affine_1_thm empty_ss);
    simplify (addsimps mod_thms empty_ss);
    goal_eval_unint ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian"];
    simplify (addsimp mod_2_384_thm empty_ss);
    w4_unint_z3 ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian"];
  });


llvm_verify m "EVP_DigestSignInit"
  [ OPENSSL_malloc_ov
  , CRYPTO_refcount_inc_ov
  ]
  true
  (EVP_DigestSignVerifyInit_spec true)
  (w4_unint_yices []);
llvm_verify m "EVP_DigestVerifyInit"
  [ OPENSSL_malloc_ov
  , CRYPTO_refcount_inc_ov
  ]
  true
  (EVP_DigestSignVerifyInit_spec false)
  (w4_unint_yices []);

llvm_verify m "EVP_DigestSignUpdate"
  [sha512_block_data_order_spec]
  true
  (EVP_DigestSignVerifyUpdate_spec true 127 241)
  (w4_unint_yices ["processBlock_Common"]);
llvm_verify m "EVP_DigestVerifyUpdate"
  [sha512_block_data_order_spec]
  true
  (EVP_DigestSignVerifyUpdate_spec false 127 241)
  (w4_unint_yices ["processBlock_Common"]);

llvm_verify m "EVP_DigestSignFinal"
  [ OPENSSL_malloc_ov
  , OPENSSL_free_nonnull_ov
  , OPENSSL_free_nonnull_ecdsa_sig_st_ov
  , OPENSSL_free_nonnull_cbb_buffer_st_ov
  , OPENSSL_free_null_ov
  , OPENSSL_cleanse_ov
  , CRYPTO_refcount_inc_ov
  , CRYPTO_refcount_dec_and_test_zero_ov
  , sha512_block_data_order_spec
  , BN_num_bits_r_bits_ov
  , BN_num_bits_s_bits_ov
  , BN_num_bits_ec_bits_ov
  , ECDSA_do_sign_ov
  ]
  true
  (EVP_DigestSignFinal_spec 112)
  (do {
    goal_eval_unint ["ECDSA_sign", "processBlock_Common"];
    w4_unint_z3 ["ECDSA_sign", "processBlock_Common"];
  });

llvm_verify m "EVP_DigestVerifyFinal"
  (concat
    [ OPENSSL_malloc_ov
    , OPENSSL_malloc_null_ov
    , OPENSSL_realloc_null_ov
    , OPENSSL_free_nonnull_ov
    , OPENSSL_free_nonnull_ecdsa_sig_st_ov
    , OPENSSL_free_nonnull_bignum_st_ov
    , OPENSSL_free_nonnull_cbb_buffer_st_ov
    , OPENSSL_free_null_ov
    , OPENSSL_cleanse_ov
    , CRYPTO_refcount_inc_ov
    , CRYPTO_refcount_dec_and_test_zero_ov
    , memcmp_ov
    , bcmp_ov
    , sha512_block_data_order_spec
    , BN_num_bits_r_bits_ov
    , BN_num_bits_s_bits_ov
    , ECDSA_do_verify_ov
    ]
    OPENSSL_realloc_ovs)
  true
  (EVP_DigestVerifyFinal_spec 112)
  (do {
    goal_eval_unint ["ECDSA_verify", "fromJacobian", "processBlock_Common"];
    w4_unint_z3 ["ECDSA_verify", "fromJacobian", "processBlock_Common"];
  });

