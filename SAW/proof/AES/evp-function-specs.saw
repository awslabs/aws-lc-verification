/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/


// Specification of aes_256_gcm_generic_init, the initialization function
// for aes_256_gcm_generic_storage.
let aes_256_gcm_generic_init_spec = do {
  crucible_alloc_global "aes_256_gcm_generic_storage";
  crucible_execute_func [];
  points_to_evp_cipher_st (crucible_global "aes_256_gcm_generic_storage");
};


/* == crypto/fipsmodule/cipher/e_aes.c ==
 *
 * static EVP_AES_GCM_CTX *aes_gcm_from_cipher_ctx(EVP_CIPHER_CTX *ctx) { ... }
 */
let aes_gcm_from_cipher_ctx_spec = do {
  cipher_data_ptr <- crucible_alloc_readonly_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");

  crucible_execute_func [cipher_data_ptr];

  crucible_return cipher_data_ptr;
};


/*
 * Specifications of EVP_CipherInit_ex, EVP_EncryptUpdate,
 * EVP_DecryptUpdate, EVP_EncryptFinal_ex, and EVP_DecryptFinal_ex functions
 * for AES-GCM.
 */


/*
 * == include/openssl/cipher.h:155 ==
 * == crypto/fipsmodule/cipher.c:135 ==
 *
 * // EVP_CipherInit_ex configures |ctx| for a fresh encryption (or decryption, if
 * // |enc| is zero) operation using |cipher|. If |ctx| has been previously
 * // configured with a cipher then |cipher|, |key| and |iv| may be |NULL| and
 * // |enc| may be -1 to reuse the previous values. The operation will use |key|
 * // as the key and |iv| as the IV (if any). These should have the correct
 * // lengths given by |EVP_CIPHER_key_length| and |EVP_CIPHER_iv_length|. It
 * // returns one on success and zero on error.
 * OPENSSL_EXPORT int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,
 *                                      const EVP_CIPHER *cipher, ENGINE *engine,
 *                                      const uint8_t *key, const uint8_t *iv,
 *                                      int enc);
 */
let EVP_CipherInit_ex_spec enc = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_cipher_ctx_st");
  crucible_points_to (crucible_field ctx_ptr "cipher") crucible_null;

  cipher_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_st");
  points_to_evp_cipher_st cipher_ptr;

  (key, key_ptr) <- ptr_to_fresh_readonly "key" (llvm_array aes_key_len (llvm_int 8));
  (iv, iv_ptr) <- ptr_to_fresh_readonly "iv" (llvm_array aes_iv_len (llvm_int 8));

  crucible_execute_func [ctx_ptr, cipher_ptr, crucible_null, key_ptr, iv_ptr, (crucible_term enc)];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  cipher_data_ptr <- crucible_alloc_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");

  let ctx = {{ { key = key, iv = iv, Xi = zero, len = 0 } : AES_GCM_Ctx }};
  points_to_EVP_AES_GCM_CTX cipher_data_ptr ctx {{ 1 : [32] }} 0xffffffff;

  points_to_evp_cipher_ctx_st ctx_ptr cipher_ptr cipher_data_ptr enc;
};


/* == include/openssl/cipher.h:227 ==
 * == crypto/fipmodule/cipher.c:509
 * // EVP_CipherUpdate calls either |EVP_EncryptUpdate| or |EVP_DecryptUpdate|
 * // depending on how |ctx| has been setup.
 * OPENSSL_EXPORT int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, uint8_t *out,
 *                                     int *out_len, const uint8_t *in,
 *                                     int in_len);
 */
let EVP_CipherUpdate_spec enc = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  cipher_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_st");
  points_to_evp_cipher_st cipher_ptr;

  len <- llvm_fresh_var "len" (llvm_int 32);

  cipher_data_ptr <- crucible_alloc_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");
  ctx <- fresh_aes_gcm_ctx;

  llvm_precond {{ len >$ 0 }};
  llvm_precond {{ ctx.len <= `TOTAL_MESSAGE_MAX_LENGTH }};
  // llvm_precond {{ ctx.len + (sext len) <= `TOTAL_MESSAGE_MAX_LENGTH }};
  llvm_precond {{ ctx.len + (sext len) <= 10000 }};
  
  // TODO, remove this restiction on full blocks
  llvm_setup_with_tag "16-byte aligned" do {
     llvm_precond {{ ctx.len % 16 == 0 }};
     llvm_precond {{ len % 16 == 0 }};
  };

  points_to_EVP_AES_GCM_CTX cipher_data_ptr ctx {{ 1 : [32] }} 0xffffffff;

  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_ctx_st");
  points_to_evp_cipher_ctx_st ctx_ptr cipher_ptr cipher_data_ptr enc;

  (in_, in_ptr) <- ptr_to_fresh_array_readonly "in" {{ (sext len):[64] }};

  /* TODO, this isn't great, we require that the caller initialize the output
   * buffer with bytes. We need to fix asMemAllocationArrayStore or somesuch
   * if we want to avoid this.
   */
  // out_ptr <- llvm_symbolic_alloc false 1 {{ (sext len):[64] }};
  (out_, out_ptr) <- ptr_to_fresh_array "out" {{ (sext len):[64] }};

  llvm_ghost_value update_initial_input_ghost in_;
  llvm_ghost_value update_initial_output_ghost out_;
  llvm_ghost_value update_initial_len_ghost {{ (sext len):[64] }};
  llvm_ghost_value update_initial_ctx_ghost {{ ctx }};

  out_len_ptr <- crucible_alloc (llvm_int 32);

  crucible_execute_func [ctx_ptr, out_ptr, out_len_ptr, in_ptr, crucible_term len];
  
  if eval_bool {{ enc == 0 }} then
    // TODO
    return ()
  else do {
    points_to_EVP_AES_GCM_CTX cipher_data_ptr
       {{ (update_enc_array in_ ctx out_ 0 (sext len)).1 }}
       {{ 1 : [32] }} 0xffffffff;
    llvm_setup_with_tag "update output buffer" 
     (crucible_points_to_array_prefix out_ptr
        {{ (update_enc_array in_ ctx out_ 0 (sext len)).2 }}
        {{ (sext len):[64] }});
  };

  llvm_setup_with_tag "out_len"
    (crucible_points_to out_len_ptr (crucible_term len));
  crucible_return (crucible_term {{ 1 : [32] }});
};


/* == include/openssl/cipher.h:187 ==
 * == crypto/fipmodule/cipher/cipher.c:324 ==
 * // EVP_EncryptFinal_ex writes at most a block of ciphertext to |out| and sets
 * // |*out_len| to the number of bytes written. If padding is enabled (the
 * // default) then standard padding is applied to create the final block. If
 * // padding is disabled (with |EVP_CIPHER_CTX_set_padding|) then any partial
 * // block remaining will cause an error. The function returns one on success and
 * // zero otherwise.
 * OPENSSL_EXPORT int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, uint8_t *out,
 *                                        int *out_len);
 */
let EVP_EncryptFinal_ex_spec = do {
  cipher_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_st");
  points_to_evp_cipher_st cipher_ptr;

  cipher_data_ptr <- crucible_alloc_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");
  ctx <- fresh_aes_gcm_ctx;
  llvm_precond {{ ctx.len <= `TOTAL_MESSAGE_MAX_LENGTH }};

  points_to_EVP_AES_GCM_CTX cipher_data_ptr ctx {{ 1 : [32] }} 0xffffffff;

  ctx_ptr <- crucible_alloc (llvm_struct "struct.evp_cipher_ctx_st");
  points_to_evp_cipher_ctx_st ctx_ptr cipher_ptr cipher_data_ptr {{ 1 : [32]}};

  out_ptr <- crucible_fresh_pointer (llvm_array AES_BLOCK_SIZE (llvm_int 8));
  out_len_ptr <- crucible_alloc (llvm_int 32);

  // TODO, remove this restiction on full blocks
  llvm_setup_with_tag "16-byte aligned" do {
     llvm_precond {{ ctx.len % 16 == 0 }};
  };

  crucible_execute_func [ctx_ptr, out_ptr, out_len_ptr];

  // We underspecify the final result of Xi
  Xi' <- llvm_fresh_var "Xi'" (llvm_array AES_BLOCK_SIZE (llvm_int 8));
  let ctx' = {{ { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len } : AES_GCM_Ctx }};
  points_to_EVP_AES_GCM_CTX cipher_data_ptr ctx' {{ 0 : [32] }} AES_BLOCK_SIZE;

  points_to_evp_cipher_ctx_st ctx_ptr cipher_ptr cipher_data_ptr {{ 1 : [32]}};

  let tag = {{ cipher_final ctx }};
  llvm_setup_with_tag "cipher final"
    (crucible_points_to_untyped (crucible_field ctx_ptr "buf") (crucible_term tag));

  crucible_points_to out_len_ptr (crucible_term {{ 0 : [32] }});
  crucible_return (crucible_term {{ 1 : [32] }});
};

/* == include/openssl/cipher.h:204 ==
 * == crypto/fipmodule/cipher.c:436 ==
 * // EVP_DecryptFinal_ex writes at most a block of ciphertext to |out| and sets
 * // |*out_len| to the number of bytes written. If padding is enabled (the
 * // default) then padding is removed from the final block.
 * //
 * // WARNING: it is unsafe to call this function with unauthenticated
 * // ciphertext if padding is enabled.
 * OPENSSL_EXPORT int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, uint8_t *out,
 *                                        int *out_len);
 */
let EVP_DecryptFinal_ex_spec = do {
  cipher_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_st");
  points_to_evp_cipher_st cipher_ptr;

  cipher_data_ptr <- crucible_alloc_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");
  ctx <- fresh_aes_gcm_ctx;
  llvm_precond {{ ctx.len <= `TOTAL_MESSAGE_MAX_LENGTH }};

  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_ctx_st");
  points_to_evp_cipher_ctx_st ctx_ptr cipher_ptr cipher_data_ptr {{ 0 : [32] }};

  // This "buf" value contains the expected authentication tag.
  // It must be set using the EVP_CTRL_AEAD_SET_TAG command, which also
  // sets the tag_length field to AES_BLOCK_SIZE, seen below in the EVP_AES_GCM_CTX.
  buf <- crucible_fresh_var "buf" (llvm_array AES_BLOCK_SIZE (llvm_int 8));
  crucible_points_to_untyped (crucible_field ctx_ptr "buf") (crucible_term buf);

  points_to_EVP_AES_GCM_CTX cipher_data_ptr ctx {{ 1 : [32] }} AES_BLOCK_SIZE;

  out_ptr <- crucible_fresh_pointer (llvm_array AES_BLOCK_SIZE (llvm_int 8));
  out_len_ptr <- crucible_alloc (llvm_int 32);

  // TODO, remove this restiction on full blocks
  llvm_setup_with_tag "16-byte aligned" do {
     llvm_precond {{ ctx.len % 16 == 0 }};
  };

  crucible_execute_func [ctx_ptr, out_ptr, out_len_ptr];

  // TODO? Why can't I put these lets inside the Cryptol brackets?
  let tag_match = {{ buf == cipher_final ctx }};
  let ret    = {{ if tag_match then 1:[32] else 0:[32] }};
  let iv_set = {{ if tag_match then 0:[32] else 1:[32] }};

  // NB, we underspecify the results of Xi here.  We could probably put
  // the actual value instead, if we cared to figure it out.
  Xi' <- crucible_fresh_var "Xi" (llvm_array AES_BLOCK_SIZE (llvm_int 8));
  let ctx' = {{ { key = ctx.key, iv = ctx.iv, Xi = Xi', len = ctx.len } : AES_GCM_Ctx }};
  points_to_EVP_AES_GCM_CTX cipher_data_ptr ctx' {{ iv_set }} AES_BLOCK_SIZE;

  crucible_points_to out_len_ptr (crucible_term {{ 0 : [32] }});
  crucible_return (crucible_term {{ ret }});
};
