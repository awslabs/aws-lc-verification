
// The lemmas and definitions in this file are all
// helper operations for the purpose of proving the
// encryption routine postcondition regarding Xi.
// It is an especially complicated condition to prove,
// owing to the number of different blocks involved (18 blocks)
// in three separate groups, each group of which must
// be handled differently.

let {{
  // This is a somewhat cleaned-up version
  // of the lemma_func appearing below. The structure
  // of the computation starts to become more clear.
  lemma_func_alt :
    [12][128] -> // Htable
    [128] ->     // Xi_in
    [6][128] ->  // blocks
    [128]
  lemma_func_alt Htable Xi_in Blocks =
    gcm_polyval_red_pmult
      ( ( V            #   (0:[128])) ^
        ( (0:[64])  #  S  # (0:[64])) ^
        ( (0:[128])    #  T         )
      )

   where
     H1  # H7  = Htable@0
     H2  # H8  = Htable@1
     H14 # H13 = Htable@2
     H3  # H9  = Htable@3
     H4  # H10 = Htable@4
     H16 # H15 = Htable@5
     H5  # H11 = Htable@6
     H6  # H12 = Htable@7
     H18 # H17 = Htable@8

     B1_hi # B1_lo = Blocks@5
     B2_hi # B2_lo = Blocks@4
     B3_hi # B3_lo = Blocks@3
     B4_hi # B4_lo = Blocks@2
     B5_hi # B5_lo = Blocks@1
     U_hi  # U_lo  = Xi_in ^ Blocks@0

     S = T ^ V ^ W

     V = (clmul H1 B1_hi) ^
         (clmul H2 B2_hi) ^
         (clmul H3 B3_hi) ^
         (clmul H4 B4_hi) ^
         (clmul H5 B5_hi) ^
         (clmul H6 U_hi)

     T = (clmul H7  B1_lo) ^
         (clmul H8  B2_lo) ^
         (clmul H9  B3_lo) ^
         (clmul H10 B4_lo) ^
         (clmul H11 B5_lo) ^
         (clmul H12 U_lo)

     W = (clmul H13 (B1_hi ^ B1_lo)) ^
         (clmul H14 (B2_hi ^ B2_lo)) ^
         (clmul H15 (B3_hi ^ B3_lo)) ^
         (clmul H16 (B4_hi ^ B4_lo)) ^
         (clmul H17 (B5_hi ^ B5_lo)) ^
         (clmul H18 (U_hi  ^ U_lo))

  lemma_func :
    [12][128] -> // Htable
    [128] ->     // Xi_in
    [6][128] ->  // blocks
    [128]
  lemma_func Htable Xi_in Blocks =
     (A ^ B ^ C ^ D ^ E ^ F ^ (clmul Lpoly X) ^ (0 # S_hi) ^ (X#O))
    where
     Lpoly = 0xc200000000000000
     N = (clmul Lpoly R_lo) ^ (R_lo # R_hi)
     O#X = N

     A = clmul H1 B1_hi
     B = clmul H2 B2_hi
     C = clmul H3 B3_hi
     D = clmul H4 B4_hi
     E = clmul H5 B5_hi
     F = clmul H6 U_hi

     R_lo, R_hi, S_lo, S_hi, U_lo, U_hi : [64]

     R_hi # R_lo = R
     S_hi # S_lo = S
     U_hi # U_lo = U

     R = T ^ (S_lo # 0)

     H1  # H7  = Htable@0
     H2  # H8  = Htable@1
     H14 # H13 = Htable@2
     H3  # H9  = Htable@3
     H4  # H10 = Htable@4
     H16 # H15 = Htable@5
     H5  # H11 = Htable@6
     H6  # H12 = Htable@7
     H18 # H17 = Htable@8

     B1_hi # B1_lo = Blocks@5
     B2_hi # B2_lo = Blocks@4
     B3_hi # B3_lo = Blocks@3
     B4_hi # B4_lo = Blocks@2
     B5_hi # B5_lo = Blocks@1
     U = Xi_in ^ Blocks@0

     S2  = drop`{64} (Blocks@5 ^ (B1_hi # B1_hi))
     S5  = drop`{64} (Blocks@4 ^ (B2_hi # B2_hi))
     S8  = drop`{64} (Blocks@3 ^ (B3_hi # B3_hi))
     S11 = drop`{64} (Blocks@2 ^ (B4_hi # B4_hi))
     S14 = drop`{64} (Blocks@1 ^ (B5_hi # B5_hi))
     S17 = drop`{64} (U        ^ (U_hi  # U_hi))

     S = (clmul H7  B1_lo) ^ A ^ (clmul H13 S2)  ^
         (clmul H8  B2_lo) ^ B ^ (clmul H14 S5)  ^
         (clmul H9  B3_lo) ^ C ^ (clmul H15 S8)  ^
         (clmul H10 B4_lo) ^ D ^ (clmul H16 S11) ^
         (clmul H11 B5_lo) ^ E ^ (clmul H17 S14) ^
         (clmul H12 U_lo)  ^ F ^ (clmul H18 S17)

     T = (clmul H7  B1_lo) ^
         (clmul H8  B2_lo) ^
         (clmul H9  B3_lo) ^
         (clmul H10 B4_lo) ^
         (clmul H11 B5_lo) ^
         (clmul H12 U_lo)
}};

func_lemma_cong_stmt <- congruence_for {{ lemma_func }};
func_lemma_cong <-
  prove_extcore (w4_unint_z3 ["lemma_func"]) func_lemma_cong_stmt;

// At present, I'm not sure how to prove this. I think it relies on
// particular properties of the "gcm_init_Htable" setup routine, as
// well as particular propeties of the finite field representation polynomial.
// There are also Karatsuba reduction steps involved, and the solver just doesn't
// seem up to proving this all at on go.
//
// Random testing and the fact that the previous, bounded proof were able to navigate
// this step gives me confidence that this is correct; but we should find a way
// to finish the proof.


xor_append64_lemma  <-
 prove_print
   (w4_unint_yices [])
   {{ \ (a:[64]) (b:[64]) (c:[64]) (d:[64]) ->
         (a^b)#(c^d) == (a#c)^(b#d)
   }};

func_lemma_alt_eq <-
  prove_print
  do {
    w4_unint_yices ["pmult"];
  }
  {{ \Htable Xi blocks ->
       lemma_func     Htable Xi blocks ==
       lemma_func_alt Htable Xi blocks
  }};

gcm_polyval_red_pmult_cong_stmt <-
  congruence_for {{ gcm_polyval_red_pmult }};
gcm_polyval_red_pmult_cong <-
  prove_extcore (w4_unint_yices ["gcm_polyval_red_pmult"])
              gcm_polyval_red_pmult_cong_stmt;

clmul_xor_distribute <-
  prove_print
  rme
  (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
  {{ \ (x:[64]) (y:[64]) (z:[64]) (w:[64]) ->
       clmul (x ^ y) (z ^ w) ==
       clmul x z ^ clmul x w ^ clmul y z ^ clmul y w }}));

func_lemma_alt_eq2 <-
  prove_print
  do {
    H      <- goal_intro "H";
    Xi     <- goal_intro "Xi";
    blocks <- goal_intro "blocks";
    unfolding ["ecEq","lemma_func_alt","gcm_init_Htable","splitAt"];
    simplify (cryptol_ss ());

    goal_normalize ["EqTrue","aesni_gcm_cipher_block6","pmult","clmul","gcm_polyval_red_pmult","bvXor","gcm_polyval","gcm_init_H"];
    simplify (addsimps xor_slice_append_thms empty_ss);
    simplify (addsimp clmul_xor_distribute empty_ss);

    w4_unint_yices ["pmult","gcm_polyval_red_pmult"];
  }
  {{ \H Xi blocks ->
       lemma_func_alt (gcm_init_Htable (gcm_init_H H)) Xi blocks ==
       aesni_gcm_cipher_block6 (gcm_init_Htable (gcm_init_H H)) Xi blocks
  }};

func_lemma_eq <-
  prove_print
  do {
    simplify (addsimps [func_lemma_alt_eq,func_lemma_alt_eq2] empty_ss);
    w4_unint_yices ["aesni_gcm_cipher_block6"];
  }
  {{ \H Xi blocks ->
       lemma_func (gcm_init_Htable (gcm_init_H H)) Xi blocks ==
       aesni_gcm_cipher_block6 (gcm_init_Htable (gcm_init_H H)) Xi blocks
  }};

// What follows is some truly egregious proof hacking.
//
// In "extra_lemma_statements" we are building a pair of lemmas
// that will match _exactly_ the sequence of operations
// produced in the final stages of the "aesni_gcm_encrypt"
// operation, as it processes the authentication tag
// computation on the final 12 blocks. In order to get
// it to match exactly, we cannot state the lemma in
// Cryptol, as the syntax doesn't quite work out.
//
// The ultimate and penultimate group of blocks are consumed
// almost _but not quite_ the same way. We build two
// closely related lemma statements below to handle these
// two cases. The statement of these lemmas was essentially
// reverse-engineered from the results of the symbolic
// simulator, and may be fragile to changes in the code or
// the simulator itself.
//
// For reasons I don't quite understand, the solvers
// take far too long to show the equivelence we want
// without using these lemmas. It would be quite nice
// to find a way to do without these.

let eqTrue x = term_apply (parse_core "EqTrue") [x];

extra_lemma_statements <-
 do {
   Htable <- fresh_symbolic "Htable" {| [12][128] |};

   Q <- fresh_symbolic "Q" {| [128] |};

   U1 <- fresh_symbolic "U1" {| [128] |};
   U2 <- fresh_symbolic "U2" {| [128] |};

   B1_hi <- fresh_symbolic "B1_hi" {| [64] |};
   B2_hi <- fresh_symbolic "B2_hi" {| [64] |};
   B3_hi <- fresh_symbolic "B3_hi" {| [64] |};
   B4_hi <- fresh_symbolic "B4_hi" {| [64] |};
   B5_hi <- fresh_symbolic "B5_hi" {| [64] |};

   B1_lo <- fresh_symbolic "B1_lo" {| [64] |};
   B2_lo <- fresh_symbolic "B2_lo" {| [64] |};
   B3_lo <- fresh_symbolic "B3_lo" {| [64] |};
   B4_lo <- fresh_symbolic "B4_lo" {| [64] |};
   B5_lo <- fresh_symbolic "B5_lo" {| [64] |};

   B6 <- fresh_symbolic "B6" {| [128] |};

   V2  <- fresh_symbolic "V2" {| [128] |};
   V5  <- fresh_symbolic "V5" {| [128] |};
   V8  <- fresh_symbolic "V8" {| [128] |};
   V11 <- fresh_symbolic "V11" {| [128] |};
   V14 <- fresh_symbolic "V14" {| [128] |};

   let allvars = [
     Htable,
     U1,U2,

     V2,
     V5,
     V8,
     V11,
     V14,

     B1_hi,B2_hi,B3_hi,B4_hi,B5_hi,
     B1_lo,B2_lo,B3_lo,B4_lo,B5_lo,
     B6,

     Q];

   let Hlo i = term_apply (parse_core "slice Bool 0 64 64")
                [(term_apply (parse_core "at 12 (Vec 128 Bool)")
                  [Htable, nat_to_term i])];

   let Hhi i = term_apply (parse_core "slice Bool 64 64 0")
                [(term_apply (parse_core "at 12 (Vec 128 Bool)")
                  [Htable, nat_to_term i])];

   let H1  = Hlo 0;
   let H2  = Hlo 1;
   let H3  = Hlo 3;
   let H4  = Hlo 4;
   let H5  = Hlo 6;
   let H6  = Hlo 7;
   let H7  = Hhi 0;
   let H8  = Hhi 1;
   let H9  = Hhi 3;
   let H10 = Hhi 4;
   let H11 = Hhi 6;
   let H12 = Hhi 7;

   let H13 = Hhi 2;
   let H14 = Hlo 2;
   let H15 = Hhi 5;
   let H16 = Hlo 5;
   let H17 = Hhi 8;
   let H18 = Hlo 8;

   let U = {{ U1 ^ B6 ^ U2 }};
   let U_lo = term_apply (parse_core "slice Bool 64 64 0") [U];
   let U_hi = term_apply (parse_core "slice Bool 0 64 64") [U];

   let A = {{ clmul H1 B1_hi }};
   let B = {{ clmul H2 B2_hi }};
   let C = {{ clmul H3 B3_hi }};
   let D = {{ clmul H4 B4_hi }};
   let E = {{ clmul H5 B5_hi }};
   let F = {{ clmul H6 U_hi }};

   let Lpoly = {{ 0xc200000000000000 }};

   let W17 = term_apply (parse_core "slice Bool 0 64 64")
              [ {{ U1 ^ B6 ^ U2 }} ];

   let S2 = term_apply (parse_core "slice Bool 64 64 0")
              [ {{ V2 ^ (B1_hi # B1_hi)  }} ];
   let S5 = term_apply (parse_core "slice Bool 64 64 0")
              [ {{ V5 ^ (B2_hi # B2_hi )  }} ];
   let S8 = term_apply (parse_core "slice Bool 64 64 0")
              [ {{ V8 ^ (B3_hi # B3_hi)  }} ];
   let S11 = term_apply (parse_core "slice Bool 64 64 0")
              [ {{ V11 ^ (B4_hi # B4_hi)  }} ];
   let S14 = term_apply (parse_core "slice Bool 64 64 0")
              [ {{ V14 ^ (B5_hi # B5_hi )  }} ];
   let S17 = term_apply (parse_core "slice Bool 64 64 0")
              [ {{ (U1 ^ B6 ^ U2) ^ (W17 # W17 )  }} ];

   let S = {{ (clmul H7  B1_lo) ^ A ^ (clmul H13 S2)  ^
              (clmul H8  B2_lo) ^ B ^ (clmul H14 S5)  ^
              (clmul H9  B3_lo) ^ C ^ (clmul H15 S8)  ^
              (clmul H10 B4_lo) ^ D ^ (clmul H16 S11) ^
              (clmul H11 B5_lo) ^ E ^ (clmul H17 S14) ^
              (clmul H12 U_lo)  ^ F ^ (clmul H18 S17)
           }};

   let S_lo = term_apply (parse_core "slice Bool 64 64 0") [S];
   let S_hi = term_apply (parse_core "slice Bool 0 64 64") [S];

   let T = {{ (clmul H7  B1_lo) ^
              (clmul H8  B2_lo) ^
              (clmul H9  B3_lo) ^
              (clmul H10 B4_lo) ^
              (clmul H11 B5_lo) ^
              (clmul H12 U_lo) }};

   let R = {{ T ^ (S_lo # 0) }};

   let R_lo = term_apply (parse_core "slice Bool 64 64 0") [R];
   let R_hi = term_apply (parse_core "slice Bool 0 64 64") [R];

   let N = {{ (clmul Lpoly R_lo) ^ (R_lo # R_hi) }};
   let X = term_apply (parse_core "slice Bool 64 64 0") [N];
   let O = term_apply (parse_core "slice Bool 0 64 64") [N];

   let t1   = eqTrue {{ lemma_func Htable
                         (U1 ^ U2)
                         [ B6
                         , B5_hi # B5_lo
                         , B4_hi # B4_lo
                         , B3_hi # B3_lo
                         , B2_hi # B2_lo
                         , B1_hi # B1_lo
                         ]
                        == Q }};

   let t1'  = eqTrue {{ lemma_func Htable
                         (U1 ^ B6)
                         [ U2
                         , B5_hi # B5_lo
                         , B4_hi # B4_lo
                         , B3_hi # B3_lo
                         , B2_hi # B2_lo
                         , B1_hi # B1_lo
                         ]
                        == Q }};

   let t2   = eqTrue {{ [V2,V5,V8,V11,V14] ==
                        [ B1_hi # B1_lo
                        , B2_hi # B2_lo
                        , B3_hi # B3_lo
                        , B4_hi # B4_lo
                        , B5_hi # B5_lo
                        ]
                     }};

   let tend = eqTrue {{ (A ^ B ^ C ^ D ^ E ^ F ^
                             (clmul Lpoly X) ^ (0 # S_hi) ^ (X # O)) == Q }};
   let tfinal  = implies_term t2 (implies_term t1 tend);
   let tfinal' = implies_term t2 (implies_term t1' tend);

   let l1 = (generalize_term allvars
      (rewrite (cryptol_ss ()) (unfold_term ["ecEq"] tfinal)));
   let l2 = (generalize_term allvars
      (rewrite (cryptol_ss ()) (unfold_term ["ecEq"] tfinal')));

   return (l1,l2);
 };

// Now actually prove the lemmas.
//
// They are pretty easy (although, I feel
// they they should be essentially instant
// and I'm not sure why they are not).

extra_lemma1 <-
  prove_extcore
  do { go; }
  (extra_lemma_statements.0);

extra_lemma2 <-
  prove_extcore
  do { go; }
  (extra_lemma_statements.1);


// This is some additional nasty proof engineering.
// Basically, I'm constructing a lemma here whose
// sole purpose is to restate the Xi postcondition of
// the encryption algorithm sufficently that the solver can
// directly show that the result of simulation matches.
//
// To that end, the conclusion of this lemma requires an
// implication involving the loop invariant hypothesis. This is primarily
// a way to get enough values into scope here that I can use them
// to write down the intermediate values I need. Without doing something
// like this, it's very difficult to even figure out how to write down
// what I want to say. Essentialy, we are using pattern matching via
// the lemma conclusion to give names to the values we want.
//
// All the interesting reasoning is pushed back out to the calling
// context via hypotheses, except that we apply the lemma regarding
// modular arithmetic in the body of this proof. Thus, this proof
// goes through rather easily.

enc_Xi_post_lemma_statement <-
  do {
    b <- fresh_symbolic "b" {| Bool |};
    Xother <- fresh_symbolic "Xother" {| [8] |};
    X  <- fresh_symbolic "X" {| [128] |};

    let Xslice = term_apply (parse_core "slice Bool 0 8 120") [X];
    let A0 = {{ if b then Xother else Xslice }};

    A1 <- fresh_symbolic "A" {| [8] |};
    A2 <- fresh_symbolic "A" {| [8] |};
    A3 <- fresh_symbolic "A" {| [8] |};
    A4 <- fresh_symbolic "A" {| [8] |};
    A5 <- fresh_symbolic "A" {| [8] |};
    A6 <- fresh_symbolic "A" {| [8] |};
    A7 <- fresh_symbolic "A" {| [8] |};
    A8 <- fresh_symbolic "A" {| [8] |};
    A9 <- fresh_symbolic "A" {| [8] |};
    A10 <- fresh_symbolic "A" {| [8] |};
    A11 <- fresh_symbolic "A" {| [8] |};
    A12 <- fresh_symbolic "A" {| [8] |};
    A13 <- fresh_symbolic "A" {| [8] |};
    A14 <- fresh_symbolic "A" {| [8] |};
    A15 <- fresh_symbolic "A" {| [8] |};

    let AS = [b,X,Xother,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15];

    H  <- fresh_symbolic "H" {| [128] |};
    blocks <- fresh_symbolic "blocks" {| [64] |};

    len64 <- fresh_symbolic "len64" {| [64] |};
    key   <- fresh_symbolic "key"   {| [32][8] |};
    ivec  <- fresh_symbolic "ivec"  {| [16][8] |};
    Xi    <- fresh_symbolic "Xi"    {| [16][8] |};
    inp   <- fresh_symbolic "inp"   {| Array [64] [8] |};
    buf   <- fresh_symbolic "buf"   {| Array [64] [8] |};

    start_ivec <- fresh_symbolic "start_ivec" {| [12][8] |};
    start_ctr  <- fresh_symbolic "start_ctr"  {| [32] |};

    i_tuple <- fresh_symbolic "i_tuple" {| invariantTuple |};
    c_tuple <- fresh_symbolic "c_tuple" {| invariantTuple |};

    let allvars = concat AS
      [ H, Xi, blocks, len64, key, ivec, inp, buf
      , start_ivec, start_ctr
      , i_tuple, c_tuple
      ];

    let {{
           ( i_buf

           // stack values
           , _, _, _, _, _, _, _, _, _, _
           , _, _, _

           // XMM registers
           , _, _, _, _, _, _, _, _, _, _, _

           // GP registers
           , _, _, _, _, _, i_blocks) = i_tuple

           ( c_buf

           // stack values
           , _, _  // I think these two correspond to scratch space, and don't need an invariant

           , c_prefetch9, c_prefetch8, c_prefetch7, c_prefetch6
           , c_prefetch5, c_prefetch4, c_prefetch3, c_prefetch2

           , c_spill_Z3 // spill location for $Z3 = %xmm7
                        // part of the "modulo-scheduled" computation for Xi

           , c_prefetch1, c_prefetch0

           // XMM registers
           , c_rndkey, c_inout5, c_inout4, c_inout3, c_inout2
           , c_inout1, c_inout0, c_Xi, c_Z3, c_Z0, c_T1

           // GP registers
           , c_a, c_b, c_c, c_d, c_counter, c_blocks) = c_tuple

           processed_blocks = i_blocks - c_blocks
           offset = processed_blocks * 16

           rndkeys = aes_round_keys key

           // The value in the Xi register lags behind, so the actual
           // current Xi value appears to be c_Xi ^ c_Z0 ^ c_spill_Z3
           current_Xi : [128]
           current_Xi = c_spill_Z3 ^ (drop c_Z0 ^ drop c_Xi)

           iv : [128]
           iv = join (reverse (take`{12} ivec # split ctr))

           ctr : [32]
           ctr = i_ctr + drop`{32} processed_blocks

           i_ctr : [32]
           i_ctr = join (drop`{12} ivec) + 12

           // NB, while decryption requires only a minimum of 6 blocks,
           // the bulk encryption algorithm requires 18 blocks minimum.
           total_blocks =
             zext (bulk_result_length (18 * `AES_BLOCK_SIZE) len64) / `AES_BLOCK_SIZE
    }};

    let first_blocks = {{
                 [ (c_prefetch0 # c_prefetch1)
                 , (c_prefetch2 # c_prefetch3)
                 , (c_prefetch4 # c_prefetch5)
                 , (c_prefetch6 # c_prefetch7)
                 , (c_prefetch8 # c_prefetch9)
                 , drop`{512-128} c_Z3
                 ]
    }};

    let mid_blocks = {{
       [ join (arrayRangeLookup c_buf (c_a + 96 + j*16 ))
       | j <- [ 0 .. 5 ]
       ]:[6][128]
    }};

    let last_blocks = {{
       [ swap8
           ((enc_block (join (reverse (take`{12} ivec # split (ctr+j)))) rndkeys)
            ^
            join (reverse (arrayRangeLookup inp (c_c + (zext j)*16))))
       | j <- [ 0 .. 5 ]
       ]
    }};

    let enc_final_restated =
      {{ (if blocks >= 18 then
           lemma_func (gcm_init_Htable (gcm_init_H H))
             (lemma_func (gcm_init_Htable (gcm_init_H H))
               (aesni_gcm_cipher_block6 (gcm_init_Htable (gcm_init_H H))
                 current_Xi
                 first_blocks)
               mid_blocks)
             last_blocks
          else
           (join Xi))
      }};

    let out_data         = {{ gcm_enc_blocks_6x inp start_ivec start_ctr (aes_round_keys key) buf 0 blocks }};
    let out_data_fixed   = {{ gcm_enc_blocks_6x inp (take`{12} ivec) i_ctr rndkeys i_buf 12 total_blocks }};
    let out_data_varying = {{ gcm_enc_blocks_6x inp (take`{12} ivec) ctr rndkeys c_buf (processed_blocks + 12) total_blocks }};

    let t1 = eqTrue {{ [A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15] == split X }};

    let t2 = eqTrue {{ X == enc_final_restated }};

    let t3a = eqTrue {{ last_blocks  == [ join (arrayRangeLookup out_data_varying ((blocks-6+j) * 16 ))  | j <- [ 0 .. 5 ] ] }};
    let t3b = eqTrue {{ mid_blocks   == [ join (arrayRangeLookup out_data_varying ((blocks-12+j) * 16 )) | j <- [ 0 .. 5 ] ] }};
    let t3c = eqTrue {{ first_blocks == [ join (arrayRangeLookup out_data_varying ((blocks-18+j) * 16 )) | j <- [ 0 .. 5 ] ] }};
    let t3d = eqTrue {{ arrayEq out_data_fixed out_data }};
    let t3e = eqTrue {{ current_Xi   == gcm_ghash_array_6x H (join Xi) out_data_fixed 0 (blocks-18) }};

    let tend = eqTrue
         (term_apply (parse_core "implies")
         [ {{ aesni_gcm_encrypt_invariant len64 key ivec Xi inp i_tuple c_tuple }}
         , {{ [A0,A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13,A14,A15]
                 == split (gcm_ghash_array_6x_enc_final H (join Xi)
                            out_data
                            blocks) }}
         ]);

    let tfinal =
      (implies_term t1 (implies_term t2
         (implies_term t3a (implies_term t3b (implies_term t3c
           (implies_term t3d (implies_term t3e tend)))))));

    return (generalize_term allvars
      (rewrite (cryptol_ss ()) (unfold_term ["ecEq"] tfinal)));
  };


split_16_8_cong_stmt <- congruence_for (parse_core "split 16 8 Bool");
split_16_8_cong <- prove_extcore z3 split_16_8_cong_stmt;

aesni_gcm_cipher_block6_cong_stmt <- congruence_for {{ aesni_gcm_cipher_block6 }};
aesni_gcm_cipher_block6_cong <-
  prove_extcore (w4_unint_z3 ["aesni_gcm_cipher_block6"])
  aesni_gcm_cipher_block6_cong_stmt;

enc_Xi_post_lemma <-
  prove_extcore
  do {
    simplify (addsimp func_lemma_eq empty_ss);
    w4_unint_yices (concat go_unint ["aesni_gcm_cipher_block6"]);
  }
  enc_Xi_post_lemma_statement;
