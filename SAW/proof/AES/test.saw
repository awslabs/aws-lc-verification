enable_experimental;

import "../../spec/AES/AES-GCM.cry";
import "../../spec/AES/X86.cry";
import "../../spec/AES/AES-GCM-implementation.cry";
import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Block/AES.cry";
import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Authenticated/AES_256_GCM.cry";

include "../common/helpers.saw";

let do_prove = false;
include "goal-rewrites.saw";
include "Lemmas.saw";
let do_prove = true;

load_sawcore_from_file "test.sawcore";

let {{
  to_array : {n} (fin n) => [n][8] -> Array [64] [8]
  to_array inp = foldl (\a (idx, val) -> arrayUpdate a idx val) zeroByteArray (zip (take [0...]) inp)

  from_array : {n} (fin n) => Array [64] [8] -> [n][8]
  from_array arr = [ arrayLookup arr idx | idx <- take [0...] ]
}};

// test 1: cipher_update_array is equivalent to cipher_update, so we're confident that it's a good spec
/*
prove_print (quickcheck 1) {{ \(st : AES_GCM_Ctx) (inp : [1][8]) ->
  cipher_update 0 st inp == cipher_update_array 0 st (to_array inp) 0 1
}};

prove_print (quickcheck 1) {{ \(st : AES_GCM_Ctx) (inp : [1][8]) ->
  cipher_update 1 st inp == cipher_update_array 1 st (to_array inp) 0 1
}};
*/

// test 2: cipher_update_array is equivalent to update_enc_array / update_dec_array, so we're confident the implementation computes the spec
/*
prove_print (quickcheck 5) {{ \(key : [32][8]) (iv : [12][8]) (Xi : [16][8]) (inp : [16][8]) -> (
  cipher_update_array 1 st (to_array inp) 0 16 == (update_enc_array (to_array inp) st zeroByteArray 0 16).1
    where
      st = {key = key, iv = iv, Xi = Xi, len = 16}
)}};

prove_print (quickcheck 1) {{ \(key : [32][8]) (iv : [12][8]) (Xi : [16][8]) (inp : [16][8]) -> (
  cipher_update_array 0 st (to_array inp) 0 16 == (update_dec_array (to_array inp) st zeroByteArray 0 16).1
    where
      st = {key = key, iv = iv, Xi = Xi, len = 16}
)}};
*/


let pg = print_goal;
let simpl = do {
  simplify (cryptol_ss ());
  beta_reduce_goal;
};
let rw lemma = simplify (addsimp lemma empty_ss);
let rwh hyp = simplify_local [hyp] empty_ss;

ite_const_true_lemma <- prove_print w4
  {{ \(x : [16][8]) (y : [16][8]) -> (if True then x else y) == x }};
ite_const_false_lemma <- prove_print w4
  {{ \(x : [16][8]) (y : [16][8]) -> (if False then x else y) == y }};
ite_const_true_bool_lemma <- prove_print w4
  {{ \(x : Bit) (y : Bit) -> (if True then x else y) == x }};
ite_const_false_vec8_lemma <- prove_print w4
  {{ \(x : [8]) (y : [8]) -> (if False then x else y) == y }};
ite_const_true_vec32_lemma <- prove_print w4
  {{ \(x : [32]) (y : [32]) -> (if True then x else y) == x }};
ite_const_false_vec128_lemma <- prove_print w4
  {{ \(x : [128]) (y : [128]) -> (if False then x else y) == y }};
ite_const_true_ctx_lemma <- prove_print w4
  {{ \(x : AES_GCM_Ctx) y -> (if True then x else y) == x }};
ite_const_false_ctx_lemma <- prove_print w4
  {{ \(x : AES_GCM_Ctx) y -> (if False then x else y) == y }};
ite_const_true_Xi_lemma <- prove_print w4
  {{ \(x : [16][8]) (y : [16][8]) -> (if True then x else y) == x }};
ite_const_false_tuple_lemma <- prove_print w4
  {{ \(x : ([64], AES_GCM_Ctx, Array [64] [8])) y -> (if False then x else y).1 == y.1 }};
ecEq_elim_lemma <- prove_extcore w4
  (parse_core "EqTrue (boolEq (ecEq (Vec 64 Bool) (PEqWord 64) (bvNat 64 16) (bvNat 64 0)) False)");
intLe_refl_lemma <- prove_extcore w4
  (parse_core "(x : Integer) -> EqTrue (boolEq (intLe x x) True)");
intToNat_natToInt_lemma <- prove_extcore w4
  (parse_core "EqTrue (boolEq (at 32 Bool (reverse 32 Bool (bvNat 32 0)) (intToNat (natToInt 0))) False)");
recover_vecEq_lemma <- prove_extcore w4 (beta_reduce_term (unfold_term ["recover_vecEq"] (parse_core_mod "test" "recover_vecEq")));
recover_vecEq2_lemma <- prove_extcore w4 (beta_reduce_term (unfold_term ["recover_vecEq2"] (parse_core_mod "test" "recover_vecEq2")));
upd_collapse_lemma <- prove_extcore w4 (beta_reduce_term (unfold_term ["updxor"] (unfold_term ["upd_collapse"] (parse_core_mod "test" "upd_collapse"))));
arrayRangeLookup_arrayLookup_lemma <- prove_extcore w4 (beta_reduce_term (unfold_term ["arrayRangeLookup_arrayLookup"] (parse_core_mod "test" "arrayRangeLookup_arrayLookup")));
split_join_lemma <- prove_extcore w4
  (parse_core "(a : Vec 16 (Vec 8 Bool)) -> EqTrue (vecEq 16 (Vec 8 Bool) (bvEq 8) (split 16 8 Bool (join 16 8 Bool a)) a)");
join_split_lemma <- prove_extcore w4
  (parse_core "(a : Vec 128 Bool) -> EqTrue (bvEq 128 (join 16 8 Bool (split 16 8 Bool a)) a)");
bvEq_byte_refl_lemma <- prove_extcore w4
  (parse_core "(x : Vec 8 Bool) -> EqTrue (boolEq (bvEq 8 x x) True)");
bvult_64_refl_false_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> EqTrue (boolEq (bvult 64 x x) False)");
ite_tuple_lemma <- prove_extcore w4 (beta_reduce_term (unfold_term ["key_type", "iv_type", "Xi_type"] (unfold_term ["ctx_type"] (unfold_term ["ite_tuple"] (parse_core_mod "test" "ite_tuple")))));
ecEq_ctx_sym_lemma <- prove_extcore w4 (beta_reduce_term (unfold_term ["key_type", "iv_type", "Xi_type"] (unfold_term ["ctx_type"] (unfold_term ["ecEq_ctx_sym"] (parse_core_mod "test" "ecEq_ctx_sym")))));
bvSub_refl_zero_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> EqTrue (bvEq 64 (bvSub 64 x x) (bvNat 64 0))");
bvult_bvule_bvSub_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> (y : Vec 64 Bool) -> EqTrue (bvule 64 x y) -> EqTrue (boolEq (bvule 64 (bvNat 64 1) (bvSub 64 y x)) (bvult 64 x y))");
ite_bool_implies_lemma <- prove_extcore w4
  (parse_core "(h : Bool) -> (c : Bool) -> EqTrue (boolEq (ite Bool h c True) (implies h c))");
ite_bool_and_lemma <- prove_extcore w4
  (parse_core "(h : Bool) -> (c : Bool) -> EqTrue (boolEq (ite Bool h c False) (and h c))");
vecEq_refl_lemma <- prove_extcore w4
  (parse_core "(x : Vec 16 (Vec 8 Bool)) -> EqTrue (boolEq (vecEq 16 (Vec 8 Bool) (bvEq 8) x x) True)");
bvule_zero_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> EqTrue (boolEq (bvule 64 (bvNat 64 0) x) True)");
bvAdd_identity_zero_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> EqTrue (bvEq 64 (bvAdd 64 (bvNat 64 0) x) x)");
bvAdd_right_identity_zero_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> EqTrue (bvEq 64 (bvAdd 64 x (bvNat 64 0)) x)");
bvAdd_assoc_right_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> (y : Vec 64 Bool) -> (z : Vec 64 Bool) -> EqTrue (bvEq 64 (bvAdd 64 (bvAdd 64 x y) z) (bvAdd 64 x (bvAdd 64 y z)))");
bvSub_identity_zero_lemma <- prove_extcore w4
  (parse_core "(x : Vec 64 Bool) -> EqTrue (bvEq 64 (bvSub 64 x (bvNat 64 0)) x)");
at_zero_false_lemma <- prove_extcore w4
  (parse_core "EqTrue (boolEq (at 32 Bool (reverse 32 Bool (bvNat 32 0)) (intToNat (natToInt 0))) False)");
and_true_lemma <- prove_extcore w4
  (parse_core "(x : Bool) -> EqTrue (boolEq (and True x) x)");
or_false_lemma <- prove_extcore w4
  (parse_core "(x : Bool) -> EqTrue (boolEq (or False x) x)");
not_true_lemma <- prove_extcore w4
  (parse_core "EqTrue (boolEq (not True) False)");

n_sub_lemma <-
  prove_print
  w4
  {{
    \(n : [64]) ->
      (
        ((n <= (2^^32)) /\ (n % 96 == 0)) ==> ((n - x2) && 18446744073709551600) == 0
          where
            x2 = zext (((drop`{32} n) / x3) * x3)
            x3 = max x4 (((drop`{32} n) / x4) * x4)
            x4 = 96
      )
  }};

let {{
  n_div : [64] -> [64] -> Bit
  n_div n i = 
    (6 <= ((x2 / 16) - (i / 16))) == False
      where
        x2 = zext (((drop`{32} n) / x3) * x3)
        x3 = max x4 (((drop`{32} n) / x4) * x4)
        x4 = 96
}};

cipher_update_array_helper_unfolding_lemma <-
  prove_print
    do {
      unfolding ["ecEq","cipher_update_array_helper"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["cipher_update_array_helper_unfold","cipher_update_array_helper"];
      simpl;
      unfolding ["ecEq"];
      simpl;
      rw vecEq_refl_lemma;
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
      {{ \i enc ctx in len Xi ->
        cipher_update_array_helper enc ctx in i len Xi ==
        cipher_update_array_helper_unfold enc ctx in i len Xi
      }}
    ));

let {{
  cipher_update_array_ctx_16 : [32] -> AES_GCM_Ctx -> [64] -> Array [64] [8] -> [16][8] -> [16][8]
  cipher_update_array_ctx_16 enc ctx i inp Xi0 = Xi16
    where
      Xi1  = cipher_update_array_ctx enc ctx (i +  0) (arrayLookup inp (i +  0))  Xi0
      Xi2  = cipher_update_array_ctx enc ctx (i +  1) (arrayLookup inp (i +  1))  Xi1
      Xi3  = cipher_update_array_ctx enc ctx (i +  2) (arrayLookup inp (i +  2))  Xi2
      Xi4  = cipher_update_array_ctx enc ctx (i +  3) (arrayLookup inp (i +  3))  Xi3
      Xi5  = cipher_update_array_ctx enc ctx (i +  4) (arrayLookup inp (i +  4))  Xi4
      Xi6  = cipher_update_array_ctx enc ctx (i +  5) (arrayLookup inp (i +  5))  Xi5
      Xi7  = cipher_update_array_ctx enc ctx (i +  6) (arrayLookup inp (i +  6))  Xi6
      Xi8  = cipher_update_array_ctx enc ctx (i +  7) (arrayLookup inp (i +  7))  Xi7
      Xi9  = cipher_update_array_ctx enc ctx (i +  8) (arrayLookup inp (i +  8))  Xi8
      Xi10 = cipher_update_array_ctx enc ctx (i +  9) (arrayLookup inp (i +  9))  Xi9
      Xi11 = cipher_update_array_ctx enc ctx (i + 10) (arrayLookup inp (i + 10)) Xi10
      Xi12 = cipher_update_array_ctx enc ctx (i + 11) (arrayLookup inp (i + 11)) Xi11
      Xi13 = cipher_update_array_ctx enc ctx (i + 12) (arrayLookup inp (i + 12)) Xi12
      Xi14 = cipher_update_array_ctx enc ctx (i + 13) (arrayLookup inp (i + 13)) Xi13
      Xi15 = cipher_update_array_ctx enc ctx (i + 14) (arrayLookup inp (i + 14)) Xi14
      Xi16 = cipher_update_array_ctx enc ctx (i + 15) (arrayLookup inp (i + 15)) Xi15 
}};

lt_lemma <- prove_print w4 {{ \(i : [64]) (n : [64]) -> (i == n) \/ (n - (i + 1) < n - i) }};

cipher_update_array_ctx_ctx_lemma <-
  prove_print
    do {
      unfolding ["cipher_update_array_ctx"];
      simpl;
      unfolding ["get_H"];
      simpl;
      unfolding ["EKij"];
      simpl;
      unfolding ["EKi"];
      simpl;
      rw vecEq_refl_lemma;
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
      {{ \i enc key iv ctxXi ctxXi' byte Xi -> (
        cipher_update_array_ctx enc ctx i byte Xi ==
        cipher_update_array_ctx enc ctx' i byte Xi
          where
            ctx = {key = key, iv = iv, Xi = ctxXi, len = 0}
            ctx' = {key = key, iv = iv, Xi = ctxXi', len = 0}
      )}}
    ));

cipher_update_array_ctx_16_ctx_lemma <-
  prove_by_bv_induction
    do {
      i <- goal_intro "i";
      len <- goal_intro "len";
      key <- goal_intro "key";
      iv <- goal_intro "iv";
      ctxXi <- goal_intro "ctxXi";
      ctxXi' <- goal_intro "ctxXi'";
      Xi <- goal_intro "Xi";
      inp <- goal_intro "inp";
      normalize_sequent;
      unfolding ["/\\"];
      simpl;
      focus_concl 0;
      rw ite_bool_and_lemma;
      rw ite_bool_implies_lemma;
      normalize_sequent;

      unfocus;
      goal_insert_and_specialize lt_lemma [i, len];
      simpl;
      focus_hyp 3;
      split_goal;
      unfocus;

      focus_concl 0;
      rwh 4;
      rw cipher_update_array_helper_unfolding_lemma;
      unfolding ["cipher_update_array_helper_unfold"];
      simpl;

      rw bvult_64_refl_false_lemma;
      rw ite_const_false_lemma;
      rw vecEq_refl_lemma;
      trivial;

      focus_concl 0;
      rw cipher_update_array_helper_unfolding_lemma;
      unfolding ["cipher_update_array_helper_unfold"];
      simpl;
      focus_hyp 0;
      goal_specialize_hyp [ {{ i + 1 }}, len ];
      delete_hyps [0];

      goal_cut {{ i + 1 <= len }};

      focus_hyp 5;
      unfolding ["EqTrue"];
      simpl;
      focus_hyp 0;
      unfolding ["EqTrue"];
      simpl;
      focus_hyp 4;
      rwh 5;
      rwh 0;
      rw ite_bool_and_lemma;
      rw and_true_lemma;
      rw ite_const_true_bool_lemma;

      unfocus;
      simpl;
      focus_hyp 2;
      unfolding ["EqTrue"];
      simpl;
      focus_hyp 4;
      rwh 2;
      goal_specialize_hyp
        [ key, iv
        , ctxXi, ctxXi'
        , {{ cipher_update_array_ctx 0 {key = key, iv = iv, Xi = ctxXi, len = 0} i (arrayLookup inp i) Xi }}
        , inp
        , parse_core "Refl Bool True"
        ];

      focus_hyp 6;
      rwh 5;
      rw ite_const_true_bool_lemma;
      recover_eqtrue;
      rw recover_vecEq_lemma;
      unfocus;
      simpl;
      focus_concl 0;
      rwh 6;

      goal_insert_and_specialize cipher_update_array_ctx_ctx_lemma
        [ i
        , {{ 0 : [32] }}
        , key
        , iv
        , ctxXi
        , ctxXi'
        , {{ arrayLookup inp i }}
        , Xi
        ];
      focus_hyp 7;
      recover_eqtrue;
      rw recover_vecEq_lemma;
      simpl;

      focus_concl 0;
      rwh 7;
      rw vecEq_refl_lemma;
      trivial;

      delete_concl [0];
      delete_hyps [4];
      w4;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
      {{ \i len key iv ctxXi ctxXi' Xi inp ->
        ( len - i
        , ((len <= (2^^32)) /\ (i <= len)) ==>
            cipher_update_array_helper 0 ctx inp i len Xi
            == cipher_update_array_helper 0 ctx' inp i len Xi
            where
              ctx = {key = key, iv = iv, Xi = ctxXi, len = 0}
              ctx' = {key = key, iv = iv, Xi = ctxXi', len = 0}
        )
      }}
    ));

cipher_update_array_helper_unfold_16_lemma <-
  prove_print
    do {
      i <- goal_intro "i";
      len <- goal_intro "len";
      key <- goal_intro "key";
      iv <- goal_intro "iv";
      Xi <- goal_intro "Xi";
      inp <- goal_intro "inp";

      let unfold_where_i i_tm = do {
        goal_insert_and_specialize cipher_update_array_helper_unfolding_lemma [i_tm];
        focus_hyp 0;
        rw recover_vecEq_lemma;
        recover_eqtrue;
        simpl;
        focus_concl 0;
        rw bvAdd_assoc_right_lemma;
        simpl;
        rwh 0;
        unfolding ["cipher_update_array_helper_unfold"];
        simpl;
        delete_hyps [0];
      };

      unfold_where_i i;
      unfold_where_i {{ i + 1 }};
      unfold_where_i {{ i + 2 }};
      unfold_where_i {{ i + 3 }};
      unfold_where_i {{ i + 4 }};
      unfold_where_i {{ i + 5 }};
      unfold_where_i {{ i + 6 }};
      unfold_where_i {{ i + 7 }};
      unfold_where_i {{ i + 8 }};
      unfold_where_i {{ i + 9 }};
      unfold_where_i {{ i + 10 }};
      unfold_where_i {{ i + 11 }};
      unfold_where_i {{ i + 12 }};
      unfold_where_i {{ i + 13 }};
      unfold_where_i {{ i + 14 }};
      unfold_where_i {{ i + 15 }};

      unfolding ["cipher_update_array_ctx_16"];
      simpl;
      rw bvAdd_assoc_right_lemma;
      // trying to: goal_insert cipher_update_array_ctx_16_ctx_lemma
      proof_subshell ();
      w4_unint_z3 ["cipher_update_array_helper", "cipher_update_array_ctx"];
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
      {{ \i len key iv Xi inp -> (
        ((len <= (2^^32)) /\ (i <= len) /\ (i + 15 < len)) ==>
          cipher_update_array_helper 0 ctx inp i len Xi
          == cipher_update_array_helper 0 ctx' inp (i + 16) len Xi'
          where
            ctx = {key = key, iv = iv, Xi = Xi, len = 0}
            Xi' = cipher_update_array_ctx_16 0 ctx i inp Xi
            ctx' = {key = key, iv = iv, Xi = Xi', len = 0}
      )}}
    ));

cipher_update_ctx_lemma <-
  prove_print
    do {
      key <- goal_intro "key";
      iv <- goal_intro "iv";
      Xi <- goal_intro "Xi";
      inp <- goal_intro "inp";
      i <- goal_intro "i";
      unfolding ["cipher_update_array_ctx_16"];
      simpl;
      unfolding ["cipher_update_array_ctx"];
      simpl;
      rw gcm_ghash_array_internal_unfolding_lemma2;
      unfolding ["gcm_ghash_array_internal_unfold"];
      simpl;
      rw gcm_ghash_array_internal_unfolding_lemma2;
      unfolding ["gcm_ghash_array_internal_unfold"];
      simpl;
      rw bvSub_refl_zero_lemma;
      rw ite_const_false_vec128_lemma;
      unfolding ["arrayRangeLookup"];
      simpl;
      unfolding ["generate"];
      simpl;
      rw arrayRangeLookup_arrayLookup_lemma;
      w4_unint_yices ["gcm_polyval", "gcm_init_H", "aes_hw_encrypt"];
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
      {{ \key iv Xi inp i -> (
        (i % 16 == 0) ==>
          cipher_update_array_ctx_16 0 ctx i inp Xi
          == split (gcm_ghash_array_internal (join (get_H ctx)) (join Xi) inp (i / 16) ((i / 16) + 1))
          where
            ctx = {key = key, iv = iv, Xi = Xi, len = 0}
      )}}
    ));

gcm_ghash_array_unfolding_lemma <-
  prove_print
    do {
      unfolding ["ecEq","gcm_ghash_array"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_ghash_array_unfold","gcm_ghash_array"];
      simpl;
      rw vecEq_refl_lemma;
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
      {{ \H Xi inp i blocks ->
        gcm_ghash_array H Xi inp i blocks ==
        gcm_ghash_array_unfold H Xi inp i blocks
      }}
    ));

gcm_ghash_array_internal_lemma <-
  prove_by_bv_induction
  do {
    i <- goal_intro "i";
    blocks <- goal_intro "blocks";
    H <- goal_intro "H";
    Xi <- goal_intro "Xi";
    inp <- goal_intro "inp";
    goal_intro_hyp;
    rw gcm_ghash_array_internal_unfolding_lemma2;
    rw gcm_ghash_array_unfolding_lemma;
    unfolding ["gcm_ghash_array_unfold", "gcm_ghash_array_internal_unfold"];
    simpl;

    unfocus;
    goal_insert_and_specialize lt_lemma [i, blocks];
    simpl;
    focus_hyp 1;
    split_goal;
    unfocus;

    rwh 2;
    rw bvult_64_refl_false_lemma;
    rw ite_const_false_vec128_lemma;
    rw ite_const_false_lemma;
    simpl;
    rw bvSub_refl_zero_lemma;
    rw ite_const_false_vec128_lemma;
    simpl;
    delete_hyps [0, 1, 2];
    w4;

    focus_hyp 0;
    goal_specialize_hyp
      [ {{ i + 1 }}
      , blocks
      , H
      , {{ gcm_ghash_block (gcm_init_H H) Xi (arrayRangeLookup inp (i * 16) : [16][8]) }}
      , inp
      ];
    delete_hyps [0, 2];
    focus_hyp 0;
    unfolding ["EqTrue"];
    simpl;
    focus_hyp 1;
    simpl;
    rwh 0;
    goal_specialize_hyp [parse_core "Refl Bool True"];
    delete_hyps [0, 1];
    focus_hyp 0;
    rw recover_vecEq_lemma;
    unfolding ["ecMul"];
    simpl;
    w4_unint_yices ["gcm_ghash_array", "gcm_ghash_array_internal"];
  }
  {{ \(i : [64]) (blocks : [64]) (H : [128]) (Xi : [16][8]) (inp : Array [64] [8]) ->
    ( blocks - i
    , (i <= blocks) ==>
      gcm_ghash_array (gcm_init_H H) Xi inp i blocks == split (gcm_ghash_array_internal H (join Xi) inp i blocks)
    )
  }};

split_lemma <- prove_print w4 {{ \(i : [64]) (n : [64]) -> ((i + 15 < n) == False) \/ (i + 15 < n) }};

let update_dec_array_tactic = do {
  i <- goal_intro "i";
  n <- goal_intro "n";
  key <- goal_intro "key";
  iv <- goal_intro "iv";
  inp <- goal_intro "inp";
  Xi <- goal_intro "Xi";
  goal_intro_hyp;

  focus_hyp 0;
  goal_specialize_hyp [ {{ i + 16 }}, n, key, iv, inp];
  delete_hyps [0];

  // split the goal into the two convenient cases
  unfocus;
  goal_insert_and_specialize split_lemma [i, n];
  simpl;
  focus_hyp 1;
  split_goal;
  unfocus;

  // base case
  focus_concl 0;
  delete_hyps [0, 1];

  // pull preconditions into hypotheses
  unfolding ["==>", "/\\"];
  rw ite_bool_implies_lemma;
  rw ite_bool_and_lemma;
  normalize_sequent;
  focus_hyp 1;
  unfolding ["EqTrue"];
  simpl;
  focus_hyp 3;
  unfolding ["EqTrue"];
  simpl;
  unfocus;

  // unfold cipher_update_array_helper until one of the ite conditions is i + 16 < n
  unfolding ["cipher_update_array"];
  simpl;
  for (eval_list {{ [1..18] : [18][8] }}) (\i -> do {
    rw cipher_update_array_helper_unfolding_lemma;
    unfolding ["cipher_update_array_helper_unfold"];
    simpl;
  });
  rw bvAdd_assoc_right_lemma;
  
  // eliminate update_postbulk_decrypt ite
  focus_concl 0;
  rwh 0;
  rw ite_const_false_lemma;
  unfolding ["update_dec_array"];
  simpl;
  unfolding ["update_postbulk_decrypt"];
  simpl;
  unfolding ["update_bulk_decrypt"];
  simpl;
  rw ite_tuple_lemma;
  rw ghash_6x_unfolding_lemma2;
  unfolding ["gcm_ghash_array_6x_unfold"];
  simpl;

  goal_cut {{ n_div n i }};
  unfocus;
  unfolding ["n_div"];
  simpl;
  rw bvSub_identity_zero_lemma;
  rw bvAdd_right_identity_zero_lemma;
  focus_concl 0;
  rwh 5;
  rw ite_const_false_vec128_lemma;
  simpl;

  w4_unint_z3 ["arrayLookup", "gcm_ghash_array", "cipher_update_array_ctx", "gcm_init_Htable", "gcm_init_H", "aes_hw_encrypt"];
  delete_concl [0];
  w4; // discharge the {{ n_div n i }} cut

  // inductive case

  // pull preconditions out of conclusion
  unfocus;
  unfolding ["==>", "/\\"];
  rw ite_bool_implies_lemma;
  rw ite_bool_and_lemma;
  normalize_sequent;
  delete_concl [0];

  // simplify inductive hypothesis
  focus_hyp 2;
  unfolding ["EqTrue"];
  simpl;
  focus_hyp 3;
  unfolding ["EqTrue"];
  simpl;
  focus_hyp 0;
  rwh 2;
  rwh 3;
  goal_cut {{ (n - (i + 16)) < (n - i) }};
  focus_hyp 6;
  simpl;
  unfolding ["EqTrue"];
  simpl;
  focus_hyp 0;
  rwh 6;
  goal_specialize_hyp
    [ {{ cipher_update_array_ctx_16 0 {key = key, iv = iv, Xi = Xi, len = 0} i inp Xi }}
    , parse_core "Refl Bool True"
    ];
  goal_cut {{ (i + 16 <= n) /\ ((i + 16) % 16 == 0) }};
  delete_hyps [0];
  focus_hyp 7;
  simpl;
  unfolding ["/\\"];
  simpl;
  rw ite_bool_and_lemma;
  unfolding ["EqTrue"];
  simpl;
  focus_hyp 6;
  rwh 7;
  rw and_true_lemma;
  rw not_true_lemma;
  rw or_false_lemma;
  recover_eqtrue;
  unfocus;

  // work the conclusion until the inductive hypothesis matches
  unfocus;
  unfolding ["cipher_update_array"];
  simpl;
  focus_concl 0;
  goal_insert_and_specialize cipher_update_array_helper_unfold_16_lemma [i, n];
  goal_cut {{ ((n <= (2^^32)) /\ (i <= n) /\ (i + 15 < n)) }};
  focus_hyp 9;
  simpl;
  unfolding ["EqTrue"];
  simpl;
  focus_hyp 8;
  rwh 9;
  rw ite_const_true_bool_lemma;
  recover_eqtrue;
  focus_concl 0;
  rwh 8;

  pg;
  proof_subshell ();
};

prove_by_bv_induction update_dec_array_tactic {{ \(i : [64]) (n : [64]) (key : [32][8]) (iv : [12][8]) (inp : Array [64] [8]) (Xi : [16][8]) ->
  ( n - i
  , ((n <= 2^^32) /\ (n % 96 == 0) /\ (i <= n) /\ (i % 16 == 0)) ==>
     cipher_update_array 0 st inp i n == (update_dec_array inp st zeroByteArray i n).1
    where
      st = {key = key, iv = iv, Xi = Xi, len = 0}
  )
}};