
////////////////////////////////////////////////////////////////////////////////
// Proof commands

aes_gcm_from_cipher_ctx_ov <- crucible_llvm_unsafe_assume_spec
  m
  "aes_gcm_from_cipher_ctx"
  aes_gcm_from_cipher_ctx_spec;

llvm_verify m "aes_256_gcm_generic_init" [] true aes_256_gcm_generic_init_spec (w4_unint_yices []);


let evp_cipher_tactic = do {
  // unfolding ["cipher_update", "cipher_update_byte", "cipher_final", "cipher_update_array"];
  // simplify (addsimp gcm_pmult_pmod_thm empty_ss);
  // print_goal_summary;
  w4_unint_yices ["pmult", "pmod", "gcm_polyval", "aes_hw_encrypt","aes_hw_ctr32_encrypt_blocks_array", "cipher_update_Xi_array", "gcm_ghash_array" ];
};


let evp_cipher_ovs =
  [ OPENSSL_malloc_ov
  , aes_gcm_from_cipher_ctx_ov
  , aes_hw_set_encrypt_key_ov
  , aes_hw_encrypt_ov
  , aes_hw_encrypt_in_place_ov
  , aes_hw_ctr32_encrypt_blocks_ov
  , gcm_init_avx_ov
  , gcm_gmult_avx_ov
  , gcm_ghash_avx_ov
  , aesni_gcm_encrypt_ov
//  , aesni_gcm_decrypt_ov
  ];


llvm_verify m "EVP_CipherInit_ex"
  evp_cipher_ovs
  true
  (EVP_CipherInit_ex_spec {{ 1 : [32] }})
  evp_cipher_tactic;

llvm_verify m "EVP_CipherInit_ex"
  evp_cipher_ovs
  true
  (EVP_CipherInit_ex_spec {{ 0 : [32] }})
  evp_cipher_tactic;
 
enable_what4_hash_consing;

// iteprop <- parse_core "(n:Nat) -> (x : Vec n Bool) -> (z: Vec n Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq n Bool boolEq (ite (Vec n Bool) c1 x (ite (Vec n Bool) c2 x z)) (ite (Vec n Bool) (or c1 c2) x z))";

iteprop8 <- parse_core "(x : Vec 8 Bool) -> (z: Vec 8 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 8 Bool boolEq (ite (Vec 8 Bool) c1 x (ite (Vec 8 Bool) c2 x z)) (ite (Vec 8 Bool) (or c1 c2) x z))";
itethm8 <- prove_extcore z3 iteprop8;

iteprop32 <- parse_core "(x : Vec 32 Bool) -> (z: Vec 32 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 32 Bool boolEq (ite (Vec 32 Bool) c1 x (ite (Vec 32 Bool) c2 x z)) (ite (Vec 32 Bool) (or c1 c2) x z))";
itethm32 <- prove_extcore z3 iteprop32;

iteprop64 <- parse_core "(x : Vec 64 Bool) -> (z: Vec 64 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 64 Bool boolEq (ite (Vec 64 Bool) c1 x (ite (Vec 64 Bool) c2 x z)) (ite (Vec 64 Bool) (or c1 c2) x z))";
itethm64 <- prove_extcore z3 iteprop64;

iteprop128 <- parse_core "(x : Vec 128 Bool) -> (z: Vec 128 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 128 Bool boolEq (ite (Vec 128 Bool) c1 x (ite (Vec 128 Bool) c2 x z)) (ite (Vec 128 Bool) (or c1 c2) x z))";
itethm128 <- prove_extcore z3 iteprop128;


// gcm_pmult_pmod_thm <- prove_theorem rme
  (rewrite (cryptol_ss ())
  {{ \x y -> gcm_pmult_pmod x y == gcm_polyval (gcm_init_H x) y }});

// enable_what4_eval;
// disable_safety_proofs;

load_sawcore_from_file "LemmaStatements.sawcore";

let prove_lemma nm unfolds =
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term (concat [nm] unfolds) (parse_core_mod "LemmaStatements" nm)));

or_left  <- prove_lemma "or_left" [];
or_right <- prove_lemma "or_right" [];

arrayEq_ite_conguence <- prove_lemma
  "arrayEq_ite_congruence64_8" ["arrayEq_ite_congruence"];

arrayEq_arrayCopy_conguence <- prove_lemma
  "arrayEq_arrayCopy_congruence64_8" ["arrayEq_arrayCopy_congruence"];

arrayEq_ite_decompose_left <- prove_lemma
  "arrayEq_ite_decompose_left64_8" ["arrayEq_ite_decompose_left"];

arrayEq_ite_decompose_right <- prove_lemma
  "arrayEq_ite_decompose_right64_8" ["arrayEq_ite_decompose_right"];

arrayEq_arrayUpdate_congruence <- prove_lemma
  "arrayEq_arrayUpdate_congruence" [];

aes_hw_ctr32_congruence_tm <- congruence_for {{ aes_hw_ctr32_encrypt_blocks_array }};
aes_hw_ctr32_congruence <-
    prove_extcore (w4_unint_z3 ["aes_hw_ctr32_encrypt_blocks_array"]) aes_hw_ctr32_congruence_tm;

slice_xor_lemma <- prove_lemma
  "bvEq_slice_xor" ["bvEq_slice_xor"];

slice_cong_tm <- congruence_for (parse_core "slice Bool 120 8 0");
slice_cong <- prove_extcore (w4_unint_z3 []) slice_cong_tm;

gcm_polyval_cong_tm <- congruence_for {{ gcm_polyval }};
gcm_polyval_cong <- prove_extcore (w4_unint_z3 ["gcm_polyval"]) gcm_polyval_cong_tm;

at_16_15_bv8_congruence_tm <- congruence_for (parse_core " \\ (xs : Vec 16 (Vec 8 Bool)) -> at 16 (Vec 8 Bool) xs 15");
at_16_15_bv8_congruence <- prove_extcore (w4_unint_z3 []) (beta_reduce_term at_16_15_bv8_congruence_tm);

gcm_ghash_array_congruence_tm <- congruence_for {{ gcm_ghash_array }};
gcm_ghash_array_congruence <-
  prove_extcore (w4_unint_z3 ["gcm_ghash_array"]) gcm_ghash_array_congruence_tm;

bv8_ite_decompose_left <-
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term ["bv_ite_decompose_left"]
       (parse_core_mod "LemmaStatements" "bv_ite_decompose_left 8")));

bv8_ite_decompose_right <-
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term ["bv_ite_decompose_right"]
       (parse_core_mod "LemmaStatements" "bv_ite_decompose_right 8")));



let arraySolve = 
         w4_unint_z3
	   ["pmult", "pmod", "gcm_polyval", "aes_hw_encrypt","aes_hw_ctr32_encrypt_blocks_array",
	   "cipher_update_Xi_array", "gcm_ghash_array", "arrayCopy" ];

let crunchGoal = do
  { unfolding ["cipher_update", "cipher_update_byte", "cipher_final", "cipher_update_array", "get_Yi", "update_enc_array", "update_bulk_encrypt", "update_postbulk_encrypt" ];
    simplify (addsimps [gcm_pmult_pmod_thm, itethm8, itethm32, itethm64, itethm128] (cryptol_ss ()));
    goal_eval_unint ["pmult", "pmod", "gcm_pmult_pmod", "gcm_polyval", "aes_hw_encrypt","aes_hw_ctr32_encrypt_blocks_array", "cipher_update_Xi_array", "gcm_ghash_array", "arrayCopy" ]; };

llvm_verify m "EVP_EncryptFinal_ex"
  evp_cipher_ovs
  true
  EVP_EncryptFinal_ex_spec
  do {
    hard_goal <- goal_has_some_tag ["cipher final"];
    if hard_goal then do {
      crunchGoal;
      arraySolve;
    } else evp_cipher_tactic;
  };


llvm_verify m "EVP_DecryptFinal_ex"
  evp_cipher_ovs
  true
  EVP_DecryptFinal_ex_spec
  do { crunchGoal;
       arraySolve;
     };

enable_single_override_special_case;
enable_sequent_goals;


llvm_verify m "EVP_EncryptUpdate"
  evp_cipher_ovs
  true
  (EVP_CipherUpdate_spec {{ 1 : [32] }})
  do { n <- goal_num;
       hard_goal <- goal_has_some_tag
                    ["Yi value",
		     "Xi value",
		     "ctr value",
		     "update output buffer"];

       if hard_goal then do {
           crunchGoal;
	   arraySolve;
       } else evp_cipher_tactic;

     };

// llvm_verify m "EVP_DecryptUpdate"
//    evp_cipher_ovs
//    true
//    (EVP_CipherUpdate_spec {{ 0 : [32] }})
//    evp_cipher_tactic;

disable_what4_hash_consing;

