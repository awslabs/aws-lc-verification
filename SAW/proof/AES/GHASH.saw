/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/


////////////////////////////////////////////////////////////////////////////////
// Specifications

let gcm_init_avx_spec = do {
  (_Htable, Htable_ptr) <- ptr_to_fresh "Htable" (llvm_array 12 (llvm_int 128));
  (Xi, Xi_ptr) <- ptr_to_fresh_readonly "Xi" (llvm_array 2 (llvm_int 64));

  crucible_execute_func [Htable_ptr, Xi_ptr];

  crucible_points_to Htable_ptr (crucible_term {{ gcm_init Xi }});
};

let gcm_gmult_avx_spec = do {
  (Xi, Xi_ptr) <- ptr_to_fresh "Xi" (llvm_array 16 (llvm_int 8));
  Htable_ptr <- crucible_alloc_readonly (llvm_array 12 (llvm_int 128));
  Htable0 <- crucible_fresh_var "Htable0" (llvm_int 128);
  crucible_points_to_untyped (crucible_elem Htable_ptr 1) (crucible_term {{ drop`{1} (gcm_init_Htable Htable0) }});
  crucible_points_to_untyped (crucible_elem Htable_ptr 0) (crucible_term {{ Htable0 }});

  crucible_execute_func [Xi_ptr, Htable_ptr];

  crucible_points_to Xi_ptr (crucible_term {{ gcm_gmult Htable0 Xi }});
};

// len must be a multiple of 16
let gcm_ghash_avx_spec len = do {
  (Xi, Xi_ptr) <- ptr_to_fresh "Xi" (llvm_array 16 (llvm_int 8));
  Htable_ptr <- crucible_alloc_readonly (llvm_array 12 (llvm_int 128));
  Htable0 <- crucible_fresh_var "Htable0" (llvm_int 128);
  crucible_points_to_untyped (crucible_elem Htable_ptr 1) (crucible_term {{ drop`{1} (gcm_init_Htable Htable0) }});
  crucible_points_to_untyped (crucible_elem Htable_ptr 0) (crucible_term {{ Htable0 }});
  (inp, inp_ptr) <- ptr_to_fresh_readonly "in" (llvm_array len (llvm_int 8));

  crucible_execute_func [Xi_ptr, Htable_ptr, inp_ptr, (crucible_term {{ `len : [64] }})];

  crucible_points_to Xi_ptr (crucible_term {{ gcm_ghash Htable0 Xi inp }});
};

let gcm_ghash_avx_bounded_array_spec = do {
  (Xi, Xi_ptr) <- ptr_to_fresh "Xi" (llvm_array 16 (llvm_int 8));
  Htable_ptr <- crucible_alloc_readonly (llvm_array 12 (llvm_int 128));
  Htable0 <- crucible_fresh_var "Htable0" (llvm_int 128);
  crucible_points_to_untyped (crucible_elem Htable_ptr 1) (crucible_term {{ drop`{1} (gcm_init_Htable Htable0) }});
  crucible_points_to_untyped (crucible_elem Htable_ptr 0) (crucible_term {{ Htable0 }});

  len <- llvm_fresh_var "len" (llvm_int 64);
  crucible_precond {{ len % `AES_BLOCK_SIZE == 0 }};
  crucible_precond {{ 0 < len }};
  crucible_precond {{ len < `AES_BLOCK_SIZE * `MIN_BULK_BLOCKS }};

  (in_, in_ptr) <- ptr_to_fresh_array_readonly "in" len;

  crucible_execute_func [Xi_ptr, Htable_ptr, in_ptr, crucible_term len];

  crucible_points_to Xi_ptr (crucible_term {{ split`{each=8} (gcm_ghash_blocks_array Htable0 in_ (len / 16) 0 (join Xi)) }});
};


////////////////////////////////////////////////////////////////////////////////
// Proof commands

enable_what4_hash_consing;
gcm_init_avx_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "gcm_init_avx"
  // How to find clues for constructing the global symbol pair?
  // 1. Find the location of the function "gcm_init_avx" in the assembly
  //    using "nm crypto_test | grep gcm_init_avx"
  // 2. Find the instruction that uses the constant L0x1c2_polynomial
  //    using "objdump -S --start-address=... --stop-address=... crypto_test"
  // 3. If there is a comment, then the comment tells us where that constant is;
  //    else the address should be
  //      %rip ( which is current_instruction_addr + current_instruction_size ) + the displacement offset
  // 4. If one wants to confirm the location, try
  //      objdump -s -j .rodata crypto_test
  [ ("shufb_15_7", 384) // We need .L0x1c2_polynomial. Its location is <shufb_15_7+0x160>. 384 bytes is an offset that would be large enough to contain the right bytes after alignment.
  ]
  true
  gcm_init_avx_spec
  (do {
    unfolding ["gcm_init", "gcm_init_Htable"];
    simplify (addsimps [polyval_avx_thm] empty_ss);
    w4_unint_yices ["pmult"];
  });
disable_what4_hash_consing;

gcm_gmult_avx_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "gcm_gmult_avx"
  [ ("shufb_15_7", 384)
  ]
  true
  gcm_gmult_avx_spec
  rme;

enable_what4_hash_consing;

let gcm_ghash_avx_tactic = do {
  simplify (cryptol_ss ());
  simplify (addsimps gcm_ghash_avx_thms empty_ss);
  goal_eval_unint ["pmult", "gcm_polyval"];
  simplify (addsimps xor_slice_append_thms basic_ss);
  simplify (addsimps slice_slice_thms empty_ss);
  simplify (addsimps xor_slice_append_thms basic_ss);
  simplify (addsimps concat_assoc_0_thms empty_ss);
  simplify (addsimps concat_assoc_1_thms empty_ss);
  simplify (addsimps concat_assoc_2_thms empty_ss);
  w4_unint_z3 ["pmult", "gcm_polyval"];
};

gcm_ghash_avx_encrypt_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "gcm_ghash_avx"
  [ ("shufb_15_7", 384)
  ]
  true
  (gcm_ghash_avx_spec GHASH_length_blocks_encrypt)
  gcm_ghash_avx_tactic;

gcm_ghash_avx_decrypt_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "gcm_ghash_avx"
  [ ("shufb_15_7", 384)
  ]
  true
  (gcm_ghash_avx_spec GHASH_length_blocks_decrypt)
  gcm_ghash_avx_tactic;

enable_what4_eval;

gcm_ghash_avx_concrete_ovs <- for (eval_list {{ [ 1:[16] .. < MIN_BULK_BLOCKS ] }}) (\i -> do {
  let len = eval_int {{ i * 16 }};
  print (str_concat "gcm_ghash_avx len=" (show len));

  gcm_ghash_avx_thm <- prove_theorem
    (do {
      goal_eval_unint ["pmult", "pmod", "gcm_polyval", "gcm_polyval_mul", "gcm_polyval_mul_pmult3", "gcm_polyval_mul_pmult4", "gcm_polyval_red", "gcm_polyval_red_pmult"];
      simplify (addsimps gcm_polyval_thms empty_ss);
      simplify (addsimps [concat_assoc_0_thm] empty_ss);
      w4_unint_yices ["pmult", "pmod", "gcm_polyval"];
    })
    (rewrite (cryptol_ss ()) {{ \H Xi (in : [len][8]) -> gcm_ghash H Xi in == gcm_ghash_avx`{n=((len/16)-1)/8} H Xi in }});

  llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "gcm_ghash_avx"
    [ ("shufb_15_7", 384) ]
    true
    (gcm_ghash_avx_spec len)
    (do {
      simplify (cryptol_ss ());
      simplify (addsimps [gcm_ghash_avx_thm] empty_ss);
      goal_eval_unint ["pmult", "pmod", "gcm_polyval"];
      simplify (addsimps xor_slice_append_thms basic_ss);
      simplify (addsimps slice_slice_thms empty_ss);
      simplify (addsimps xor_slice_append_thms basic_ss);
      simplify (addsimps concat_assoc_0_thms empty_ss);
      simplify (addsimps concat_assoc_1_thms empty_ss);
      simplify (addsimps concat_assoc_2_thms empty_ss);
      goal_eval_unint ["pmult", "pmod", "gcm_polyval"];
      goal_eval_unint ["pmult", "pmod", "gcm_polyval"];
      goal_eval_unint ["pmult", "pmod", "gcm_polyval"];
      goal_eval_unint ["pmult", "pmod", "gcm_polyval"];
      goal_eval_unint ["pmult", "pmod", "gcm_polyval"];
      w4_unint_z3 ["pmult", "pmod", "gcm_polyval"];
    });
});

// Assemble the individual proofs at each concrete length
// into the overall specification
gcm_ghash_avx_bounded_array_ov <- llvm_refine_spec' m "gcm_ghash_avx"
  gcm_ghash_avx_concrete_ovs
  gcm_ghash_avx_bounded_array_spec
  (do {
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    unfolding_fix_once ["gcm_ghash_blocks_array"];
    goal_eval_unint ["gcm_ghash_blocks_array", "gcm_polyval"];
    w4_unint_z3 ["gcm_ghash_blocks_array", "gcm_polyval"];
  });


disable_what4_eval;
disable_what4_hash_consing;

