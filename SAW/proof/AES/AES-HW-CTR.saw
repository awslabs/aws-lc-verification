/*
 *
 * void aes_hw_ctr32_encrypt_blocks(const uint8_t *in, uint8_t *out, size_t len,
 *                                  const AES_KEY *key, const uint8_t ivec[16]);
 *
 * NOTE! len here is the number of _BLOCKS_
 */
let aes_hw_ctr32_encrypt_blocks_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  len <- llvm_fresh_var "len" (llvm_int 64);

  // HACK: force this override to fail in the cleanup loop in
  // CRYPTO_gcm128_encrypt_ctr32 (at gmc.c:567).
  // This ought to be OK because the bulk encryption phase will prevent
  // that loop from running any iterations.
  //
  // It would be better to find another way to make that loop symbolically
  // terminate, this is rather fragile.
  llvm_precond {{ len < `(3*1024/16) }};

  let {{ len' = len * `AES_BLOCK_SIZE }};

  (in_, in_ptr) <- ptr_to_fresh_array_readonly "in" {{ len' }};
  out_ptr <- llvm_symbolic_alloc false 1 {{ len' }};
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  key <- fresh_aes_key_st;
  points_to_aes_key_st key_ptr key;
  (ivec, ivec_ptr) <- ptr_to_fresh_readonly "ivec" (llvm_array AES_BLOCK_SIZE (llvm_int 8));

  crucible_execute_func [in_ptr, out_ptr, crucible_term len, key_ptr, ivec_ptr];

  // TODO! reenable!
  //crucible_points_to out_ptr (crucible_term {{ aes_hw_ctr32_encrypt_blocks in_ key ivec }});

  // for now, just make it point to something
  out_data <- crucible_fresh_cryptol_var "aes_hw_ctr32_encrypt_out" {| ByteArray |};
  crucible_points_to_array_prefix out_ptr out_data {{ len' }};

  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
};


/*
When verifying aes_hw_ctr32_encrypt_blocks, the binary analysis must locally
treat r11 as callee-preserved. This is necessary because this routine saves
the original stack pointer in r11 and then calls helper routines, preventing
the binary analysis from inferring that the return address is still on the stack
when the routine returns. The called helper routines do not modify r11.
*/

let aes_hw_ctr32_tactic = do {
  simplify (cryptol_ss ());
  simplify (addsimps slice_384_thms basic_ss);
  simplify (addsimps [cmp_sub_thm] empty_ss);
  goal_eval_unint ["AESRound", "AESFinalRound", "aesenc", "aesenclast"];
  simplify (addsimps add_xor_slice_thms basic_ss);
  simplify (addsimps aesenclast_thms basic_ss);
  w4_unint_yices ["AESRound", "AESFinalRound"];
};

add_x86_preserved_reg "r11";
aes_hw_ctr32_encrypt_blocks_encrypt_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "aes_hw_ctr32_encrypt_blocks"
  []
  true
  aes_hw_ctr32_encrypt_blocks_spec
  aes_hw_ctr32_tactic;

// aes_hw_ctr32_encrypt_blocks_decrypt_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "aes_hw_ctr32_encrypt_blocks"
//   []
//   true
//   aes_hw_ctr32_encrypt_blocks_spec
//   aes_hw_ctr32_tactic;
default_x86_preserved_reg;

