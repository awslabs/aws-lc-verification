load_sawcore_from_file "LemmaStatements.sawcore";

let prove_lemma nm unfolds =
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term (concat [nm] unfolds) (parse_core_mod "LemmaStatements" nm)));

Xi_ite_decompose_left_thm <-
  prove_lemma "Xi_ite_decompose_left" [];

Xi_ite_decompose_right_thm <-
  prove_lemma "Xi_ite_decompose_right" [];

gcm_ghash_6x_congruence_tm <- congruence_for {{ gcm_ghash_array_6x }};
gcm_ghash_6x_congruence <-
  prove_extcore (w4_unint_z3 ["gcm_ghash_array_6x"]) gcm_ghash_6x_congruence_tm;

gcm_enc_blocks_6x_congruence_tm <- congruence_for {{ gcm_enc_blocks_6x }};
gcm_enc_blocks_6x_congruence <-
  prove_extcore (w4_unint_z3 ["gcm_enc_blocks_6x"]) gcm_enc_blocks_6x_congruence_tm;

arrayUpdate_congruence_tm <- congruence_for {{ arrayUpdate`{[64],[8]} }};
arrayUpdate_congruence <-
  prove_extcore (w4_unint_z3 ["arrayUpdate"])
    (rewrite (cryptol_ss ()) (unfold_term ["ecArrayUpdate"] arrayUpdate_congruence_tm));

slice_0_8_120_congruence_tm <- congruence_for (parse_core "slice Bool 0 8 120");
slice_0_8_120_congruence <-
  prove_extcore (w4_unint_z3 []) slice_0_8_120_congruence_tm;

xor_128_congruence_tm <- congruence_for (parse_core "bvXor 128");
xor_128_congruence <-
  prove_extcore (w4_unint_z3 []) xor_128_congruence_tm;

aesenc_congruence_tm <- congruence_for {{ aesenc }};
aesenc_congruence <-
  prove_extcore (w4_unint_z3 ["aesenc"]) aesenc_congruence_tm;

aesenclast_congruence_tm <- congruence_for {{ aesenclast }};
aesenclast_congruence <-
  prove_extcore (w4_unint_z3 ["aesenclast"]) aesenclast_congruence_tm;

bv128_ite_decompose_left <-
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term ["bv_ite_decompose_left"]
       (parse_core_mod "LemmaStatements" "bv_ite_decompose_left 128")));

bv128_ite_decompose_right <-
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term ["bv_ite_decompose_right"]
       (parse_core_mod "LemmaStatements" "bv_ite_decompose_right 128")));

or_left  <- prove_lemma "or_left" [];
or_right <- prove_lemma "or_right" [];

arrayEq_ite_conguence <- prove_lemma
  "arrayEq_ite_congruence64_8" ["arrayEq_ite_congruence"];

arrayEq_arrayCopy_conguence <- prove_lemma
  "arrayEq_arrayCopy_congruence64_8" ["arrayEq_arrayCopy_congruence"];

arrayEq_ite_decompose_left <- prove_lemma
  "arrayEq_ite_decompose_left64_8" ["arrayEq_ite_decompose_left"];

arrayEq_ite_decompose_right <- prove_lemma
  "arrayEq_ite_decompose_right64_8" ["arrayEq_ite_decompose_right"];

arrayEq_arrayUpdate_congruence <- prove_lemma
  "arrayEq_arrayUpdate_congruence" [];

arrayEq_refl_thm <-
  prove_print
   (w4_unint_z3 [])
   (rewrite (cryptol_ss ())
     {{ \ (x : Array [64] [8]) -> arrayEq x x }});

custom_append_lemma <- prove_lemma
  "custom_append_lemma" [];

or_left  <- prove_lemma "or_left" [];
or_right <- prove_lemma "or_right" [];

bvEq128_trans_left <- prove_lemma
  "bvEq128_trans_left" [];

arrayEq_ite_conguence <- prove_lemma
  "arrayEq_ite_congruence64_8" ["arrayEq_ite_congruence"];

arrayEq_arrayCopy_conguence <- prove_lemma
  "arrayEq_arrayCopy_congruence64_8" ["arrayEq_arrayCopy_congruence"];

arrayEq_ite_decompose_left <- prove_lemma
  "arrayEq_ite_decompose_left64_8" ["arrayEq_ite_decompose_left"];

arrayEq_ite_decompose_right <- prove_lemma
  "arrayEq_ite_decompose_right64_8" ["arrayEq_ite_decompose_right"];

arrayEq_arrayUpdate_congruence <- prove_lemma
  "arrayEq_arrayUpdate_congruence" [];

arrayEq_swap_trans <- prove_lemma
  "arrayEq_swap_trans" [];

aes_hw_ctr32_congruence_tm <- congruence_for {{ aes_hw_ctr32_encrypt_blocks_array }};
aes_hw_ctr32_congruence <-
    prove_extcore (w4_unint_z3 ["aes_hw_ctr32_encrypt_blocks_array"]) aes_hw_ctr32_congruence_tm;

slice_xor_lemma <- prove_lemma
  "bvEq_slice_xor" ["bvEq_slice_xor"];

slice_cong_tm <- congruence_for (parse_core "slice Bool 120 8 0");
slice_cong <- prove_extcore (w4_unint_z3 []) slice_cong_tm;

gcm_polyval_cong_tm <- congruence_for {{ gcm_polyval }};
gcm_polyval_cong <- prove_extcore (w4_unint_z3 ["gcm_polyval"]) gcm_polyval_cong_tm;

at_16_15_bv8_congruence_tm <- congruence_for (parse_core " \\ (xs : Vec 16 (Vec 8 Bool)) -> at 16 (Vec 8 Bool) xs 15");
at_16_15_bv8_congruence <- prove_extcore (w4_unint_z3 []) (beta_reduce_term at_16_15_bv8_congruence_tm);

gcm_ghash_array_congruence_tm <- congruence_for {{ gcm_ghash_array }};
gcm_ghash_array_congruence <-
  prove_extcore (w4_unint_z3 ["gcm_ghash_array"]) gcm_ghash_array_congruence_tm;

bv8_ite_decompose_left <-
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term ["bv_ite_decompose_left"]
       (parse_core_mod "LemmaStatements" "bv_ite_decompose_left 8")));

bv8_ite_decompose_right <-
  prove_extcore (w4_unint_z3 [])
    (beta_reduce_term
      (unfold_term ["bv_ite_decompose_right"]
       (parse_core_mod "LemmaStatements" "bv_ite_decompose_right 8")));

iteprop8 <- parse_core "(x : Vec 8 Bool) -> (z: Vec 8 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 8 Bool boolEq (ite (Vec 8 Bool) c1 x (ite (Vec 8 Bool) c2 x z)) (ite (Vec 8 Bool) (or c1 c2) x z))";
itethm8 <- prove_extcore z3 iteprop8;

iteprop32 <- parse_core "(x : Vec 32 Bool) -> (z: Vec 32 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 32 Bool boolEq (ite (Vec 32 Bool) c1 x (ite (Vec 32 Bool) c2 x z)) (ite (Vec 32 Bool) (or c1 c2) x z))";
itethm32 <- prove_extcore z3 iteprop32;

iteprop64 <- parse_core "(x : Vec 64 Bool) -> (z: Vec 64 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 64 Bool boolEq (ite (Vec 64 Bool) c1 x (ite (Vec 64 Bool) c2 x z)) (ite (Vec 64 Bool) (or c1 c2) x z))";
itethm64 <- prove_extcore z3 iteprop64;

iteprop128 <- parse_core "(x : Vec 128 Bool) -> (z: Vec 128 Bool) -> (c1 : Bool) -> (c2 : Bool) -> EqTrue (vecEq 128 Bool boolEq (ite (Vec 128 Bool) c1 x (ite (Vec 128 Bool) c2 x z)) (ite (Vec 128 Bool) (or c1 c2) x z))";
itethm128 <- prove_extcore z3 iteprop128;

ite_lemma_term <- parse_core " (x : Bool) -> (y : Bool) -> (z : Bool) -> EqTrue (implies x y) -> EqTrue (implies (not x) z) -> EqTrue (ite Bool x y z)";
ite_lemma <- prove_extcore z3 ite_lemma_term;



// These lemmas are not currently used directly, but they represent
// important facts that are needed in both the AES-HW-CTR proofs and
// in the AESNI-GCM proofs.
key_expansion_prefix_lemma0 <-
  prove_print
  (w4_unint_yices ["NextWord"])
  {{ \ (key : [32][8]) ->
      (aes_round_keys key)@0 == join (reverse (take`{16} key))
  }};

key_expansion_prefix_lemma1 <-
  prove_print
  (w4_unint_yices ["NextWord"])
  {{ \ (key : [32][8]) ->
      (aes_round_keys key)@1 == join (reverse (drop`{16} key))
  }};

ghash_6x_unfolding_lemma <-
  prove_print
    do {
      unfolding ["ecEq","gcm_ghash_array_6x"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_ghash_array_6x_unfold","gcm_ghash_array_6x"];
      simplify (addsimp (core_thm "boolEq_same") (cryptol_ss ()));
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
     {{ \A H Xi inp i blocks ->
           (A == gcm_ghash_array_6x H Xi inp i blocks) ==
           (A == gcm_ghash_array_6x_unfold H Xi inp i blocks)
     }}));

ghash_6x_unfolding_lemma2 <-
  prove_print
    do {
      unfolding ["ecEq","gcm_ghash_array_6x"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_ghash_array_6x_unfold","gcm_ghash_array_6x"];
      simplify (addsimp (core_thm "bvEq_refl") (cryptol_ss ()));
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
     {{ \H Xi inp i blocks ->
           gcm_ghash_array_6x H Xi inp i blocks ==
           gcm_ghash_array_6x_unfold H Xi inp i blocks
     }}));


ghash_6x_test_unfold_lemma <-
  prove_theorem
    do {
      simplify (cryptol_ss ());
      simplify (addsimp_shallow ghash_6x_unfolding_lemma2 empty_ss);
      w4_unint_z3 ["gcm_ghash_array_6x","aesni_gcm_cipher_block6","gcm_init_Htable","gcm_init"];
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
     {{ \H Xi inp i blocks ->
           gcm_ghash_array_6x H Xi inp i blocks ==
           if blocks - i >= 6 then gcm_ghash_array_6x H Xi inp i blocks else Xi
     }}));


gcm_enc_blocks_6x_unfolding_lemma <-
  prove_print
    do {
      unfolding ["ecEq","gcm_enc_blocks_6x"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_enc_blocks_6x_unfold","gcm_enc_blocks_6x"];
      simplify (addsimp (core_thm "boolEq_same") (cryptol_ss ()));
      trivial;
    }
    (rewrite (cryptol_ss ())
     {{ \A in iv ctr key buf i blocks ->
           (arrayEq A (gcm_enc_blocks_6x in iv ctr key buf i blocks)) ==
           (arrayEq A (gcm_enc_blocks_6x_unfold in iv ctr key buf i blocks))
     }});

gcm_enc_blocks_6x_unfolding_lemma2 <-
  prove_print
    do {
      unfolding ["ecEq","gcm_enc_blocks_6x"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_enc_blocks_6x_unfold","gcm_enc_blocks_6x"];
      simplify (cryptol_ss ());
      goal_intro "in";
      goal_intro "iv";
      goal_intro "ctr";
      goal_intro "key";
      goal_intro "buf";
      goal_intro "i";
      goal_intro "blocks";
      goal_apply arrayEq_refl_thm;
    }
    (rewrite (cryptol_ss ())
     {{ \in iv ctr key buf i blocks ->
           (arrayEq (gcm_enc_blocks_6x in iv ctr key buf i blocks)
                    (gcm_enc_blocks_6x_unfold in iv ctr key buf i blocks))
     }});

gcm_enc_blocks_6x_test_unfold_lemma <-
  prove_theorem
  do {
    simplify (addsimp gcm_enc_blocks_6x_unfolding_lemma2 empty_ss);
    w4_unint_z3 ["gcm_enc_blocks_6x","aesenc","aesenclast","ExpandKey"];
  }
  (rewrite (cryptol_ss ())
  {{ \in iv ctr key buf i blocks ->
       arrayEq (gcm_enc_blocks_6x in iv ctr key buf i blocks)
        (if blocks - i >= 6 then (gcm_enc_blocks_6x in iv ctr key buf i blocks) else buf)
  }});


aes_hw_ctr32_encrypt_blocks_array_unfold_lemma2 <-
  prove_print
  do {
      unfolding ["ecEq","aes_hw_ctr32_encrypt_blocks_array"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["aes_hw_ctr32_encrypt_blocks_array_unfold","aes_hw_ctr32_encrypt_blocks_array"];
      simplify (cryptol_ss ());
      goal_intro "inp";
      goal_intro "key";
      goal_intro "iv";
      goal_intro "i";
      goal_intro "blocks";
      goal_intro "buf";
      goal_apply arrayEq_refl_thm;
  }
  (rewrite (cryptol_ss ())
    {{ \inp key iv i blocks buf ->
         arrayEq (aes_hw_ctr32_encrypt_blocks_array inp key iv i blocks buf)
                 (aes_hw_ctr32_encrypt_blocks_array_unfold inp key iv i blocks buf)
    }});


gcm_ghash_array_unfolding_lemma <-
  prove_print
    do {
      unfolding ["ecEq","gcm_ghash_array_internal"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_ghash_array_internal","gcm_ghash_array_internal_unfold"];
      simplify (addsimp (core_thm "boolEq_same") (cryptol_ss ()));
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
     {{ \A H Xi in i blocks ->
           (A == (gcm_ghash_array_internal H Xi in i blocks)) ==
           (A == (gcm_ghash_array_internal_unfold H Xi in i blocks))
     }}));

gcm_ghash_array_unfolding_lemma2 <-
  prove_print
    do {
      unfolding ["ecEq","gcm_ghash_array_internal"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_ghash_array_internal_unfold","gcm_ghash_array_internal"];
      simplify (addsimp (core_thm "bvEq_refl") (cryptol_ss ()));
      trivial;
    }
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
     {{ \H Xi inp i blocks ->
           gcm_ghash_array_internal H Xi inp i blocks ==
           gcm_ghash_array_internal_unfold H Xi inp i blocks
     }}));

gcm_enc_blocks_unfolding_lemma2 <-
  prove_print
    do {
      unfolding ["ecEq","gcm_enc_blocks"];
      simplify (addsimp_shallow (core_thm "fix_unfold") empty_ss);
      simplify (cryptol_ss ());
      unfolding ["gcm_enc_blocks_unfold","gcm_enc_blocks"];
      simplify (cryptol_ss ());
      goal_intro "in";
      goal_intro "iv";
      goal_intro "ctr";
      goal_intro "key";
      goal_intro "buf";
      goal_intro "i";
      goal_intro "blocks";
      goal_apply arrayEq_refl_thm;
    }
    (rewrite (cryptol_ss ())
     {{ \in iv ctr key buf i blocks ->
           (arrayEq (gcm_enc_blocks in iv ctr key buf i blocks)
                    (gcm_enc_blocks_unfold in iv ctr key buf i blocks))
     }});


gcm_ghash_array_compose_lemma <-
  prove_by_bv_induction
  do {
    H   <- goal_intro "H";
    Xi  <- goal_intro "Xi";
    inp <- goal_intro "inp";
    x   <- goal_intro "x";
    y   <- goal_intro "y";
    z   <- goal_intro "z";
    goal_intro_hyp;

    goal_cut
      {{ gcm_ghash_array_internal H Xi inp x y ==
         gcm_ghash_array_internal_unfold H Xi inp x y }};
    goal_cut
      {{ gcm_ghash_array_internal H Xi inp x z ==
         gcm_ghash_array_internal_unfold H Xi inp x z }};

    focus_hyp 0;
    goal_specialize_hyp [ H, {{ gcm_polyval (gcm_init_H H) (Xi ^ (join (arrayRangeLookup inp (x*16)))) }}
                        , inp, {{x+1}}, y, z
			];
    delete_hyps [0];

    w4_unint_z3 ["gcm_ghash_array_internal","gcm_polyval","gcm_init_H"];

    unfolding ["ecEq"];
    simplify (cryptol_ss ());
    goal_apply gcm_ghash_array_unfolding_lemma2;

    unfolding ["ecEq"];
    simplify (cryptol_ss ());
    goal_apply gcm_ghash_array_unfolding_lemma2;
  }
  {{ \H Xi inp x y z ->
       ( y - x
       , x <= y /\ y <= z ==>
         gcm_ghash_array_internal H Xi inp x z ==
           gcm_ghash_array_internal H
             (gcm_ghash_array_internal H Xi inp x y)
             inp y z
       )
  }};


gcm_enc_blocks_compose_lemma <-
  prove_by_bv_induction
  do {
    inp <- goal_intro "inp";
    iv  <- goal_intro "iv";
    ctr <- goal_intro "ctr";
    rndkeys <- goal_intro "rndkeys";
    buf <- goal_intro "buf";
    x   <- goal_intro "x";
    y   <- goal_intro "y";
    z   <- goal_intro "z";
    goal_intro_hyp;

    goal_cut {{ arrayEq (gcm_enc_blocks inp iv ctr rndkeys buf x y)
                        (gcm_enc_blocks_unfold inp iv ctr rndkeys buf x y) }};

    goal_cut {{ arrayEq (gcm_enc_blocks inp iv ctr rndkeys buf x z)
                        (gcm_enc_blocks_unfold inp iv ctr rndkeys buf x z) }};

    focus_hyp 0;
    goal_specialize_hyp [inp,iv,{{ctr+1}},rndkeys,{{gcm_enc inp iv ctr rndkeys buf x}},{{x+1}},y,z];
    delete_hyps [0];

    w4_unint_z3 ["gcm_enc_blocks","enc_block"];

    simplify (cryptol_ss ());
    goal_apply gcm_enc_blocks_unfolding_lemma2;

    simplify (cryptol_ss ());
    goal_apply gcm_enc_blocks_unfolding_lemma2;
  }
  {{ \inp iv ctr rndkeys buf x y z ->
        ( y - x
	, x <= y /\ y <= z ==>
	  arrayEq
            (gcm_enc_blocks inp iv ctr rndkeys buf x z)
            (gcm_enc_blocks inp iv (ctr+drop`{32} (y-x)) rndkeys
              (gcm_enc_blocks inp iv ctr rndkeys buf x y) y z)
	)
  }};


let aesni_gcm_cipher_block6_tac =
  do {
    goal_eval_unint
        // TODO? not sure all of these are necesary *shrug*
        [ "pmult", "pmod", "gcm_polyval", "gcm_polyval_mul"
        , "gcm_polyval_mul_pmult3", "gcm_polyval_mul_pmult4"
        , "gcm_polyval_red", "gcm_polyval_red_pmult"
        , "aes_hw_encrypt", "gcm_pmult_pmod"
        ];
    simplify (addsimps gcm_polyval_thms empty_ss);
    w4_unint_yices ["pmult", "pmod", "gcm_polyval", "aes_hw_encrypt"];
  };

aesni_gcm_cipher_block6_eq_lemma0 <-
  prove_theorem
    aesni_gcm_cipher_block6_tac
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
    {{ \H Xi blks ->
         aesni_gcm_cipher_block6 False (gcm_init_Htable H) Xi blks ==
         foldl (\x blk -> gcm_polyval H (x ^ blk)) Xi blks
    }}));

aesni_gcm_cipher_block6_eq_lemma1 <-
  prove_theorem
    aesni_gcm_cipher_block6_tac
    (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
    {{ \H Xi blks ->
         aesni_gcm_cipher_block6 True (gcm_init_Htable H) Xi blks ==
         foldl (\x blk -> gcm_polyval H (x ^ blk)) Xi blks
    }}));



enc_block_eq_lemma <-
  prove_theorem
  do {
    w4_unint_yices ["AESRound","AESFinalRound"];
  }
  {{ \blk rndkeys -> enc_block blk rndkeys == swap8 (aesEncryptWithKeySchedule (swap8 blk) (aes_key_to_schedule rndkeys)) }};

gcm_enc_blocks_eq_lemma <-
  prove_by_bv_induction
  do {
    simplify (cryptol_ss ());
    in_ <- goal_intro "in";
    key <- goal_intro "key";
    iv  <- goal_intro "iv";
    i   <- goal_intro "i";
    blocks <- goal_intro "blocks";
    buf <- goal_intro "buf";
    goal_intro_hyps 1;

    focus_hyp 0;
    goal_specialize_hyp
      [ in_
      , key
      , iv
      , {{i+1}}
      , blocks
      , {{ gcm_enc in_ (take`{12} iv) ((join (drop`{12} iv)) + drop`{32} i) (aes_round_keys key) buf i }}
      ];
    delete_hyps [0];

    simplify (cryptol_ss ());

    focus_concl 0;
    simplify (addsimps [ aes_hw_ctr32_encrypt_blocks_array_unfold_lemma2
                       , gcm_enc_blocks_unfolding_lemma2 ] empty_ss);

    w4_unint_yices ["aes_hw_ctr32_encrypt_blocks_array","gcm_enc_blocks","AESRound","AESFinalRound","ExpandKey"];
  }

  {{ \in key iv i blocks buf ->
       ( blocks - i
       , (i <= blocks /\ blocks <= 2^^32) ==>
           arrayEq (aes_hw_ctr32_encrypt_blocks_array in key iv i blocks buf)
                   (gcm_enc_blocks in (take`{12} iv) ((join (drop`{12} iv)+drop`{32} i)) (aes_round_keys key) buf i blocks)
       )
  }};


gcm_ghash_6x_to_1x_lemma <-
  prove_by_bv_induction
  do {
    unfolding ["ecEq"];
    simplify (cryptol_ss ());
    H   <- goal_intro "H";
    Xi  <- goal_intro "Xi";
    inp <- goal_intro "inp";
    i   <- goal_intro "i";
    blocks <- goal_intro "blocks";
    goal_intro_hyps 1;

    let go = w4_unint_yices ["gcm_ghash_array_6x","gcm_ghash_array_internal","gcm_polyval","gcm_init_Htable","gcm_init_H"];
    let unfold_gcm_ghash =
         do { simplify (addsimp gcm_ghash_array_unfolding_lemma2 empty_ss);
              unfolding ["gcm_ghash_array_internal_unfold"];
              simplify (cryptol_ss ());
         };

    // focus on and specialize the induction hypothesis
    focus_hyp 0;
    goal_specialize_hyp
      [ H
      , {{ (aesni_gcm_cipher_block6 False (gcm_init_Htable (gcm_init_H H)) Xi
             [ join (arrayRangeLookup inp ((i+j) * 16 )) | j <- [0 .. 5] ]) }}
      , inp, {{i+6}}, blocks
      ];
    delete_hyps [0];
    simplify (cryptol_ss ());

    // unfold the 6x function once
    focus_concl 0;
    simplify (addsimp ghash_6x_unfolding_lemma2 empty_ss);
    unfolding ["gcm_ghash_array_6x_unfold"];

    // apply the lemma regarding the 6x loop body
    unfocus;
    simplify (addsimp aesni_gcm_cipher_block6_eq_lemma0 (cryptol_ss ()));

    let go = w4_unint_yices ["gcm_ghash_array_6x","gcm_ghash_array_internal","gcm_polyval","gcm_init_Htable","gcm_init_H"];
    let unfold_gcm_ghash =
         do { simplify (addsimp gcm_ghash_array_unfolding_lemma2 empty_ss);
              unfolding ["gcm_ghash_array_internal_unfold"];
              simplify (cryptol_ss ());
         };

    // split on the 6x loop termination condition
    focus_concl 0;
    goal_apply bv128_ite_decompose_left;
    goal_intro_hyps 1;

    // test was true, unfold the single loop six times and finish
    unfold_gcm_ghash;
    unfold_gcm_ghash;
    unfold_gcm_ghash;
    unfold_gcm_ghash;
    unfold_gcm_ghash;
    unfold_gcm_ghash;
    go;

    // test was false, unfold the single loop once to reveal
    // it's test and finish
    unfold_gcm_ghash;
    go;
  }
  {{ \H Xi inp i blocks ->
       ( blocks - i
       , gcm_ghash_array_6x H Xi inp i blocks ==
         gcm_ghash_array_internal H Xi inp i (blocks - ((blocks-i)%6))
       )
  }};


gcm_enc_6x_to_1x_lemma <-
  prove_by_bv_induction
  do {
    simplify (cryptol_ss ());
    in_  <- goal_intro "in";
    iv   <- goal_intro "iv";
    ctr  <- goal_intro "ctr";
    keys <- goal_intro "keys";
    buf  <- goal_intro "buf";
    i    <- goal_intro "i";
    blocks <- goal_intro "blocks";
    goal_intro_hyps 1;

    // focus on and specialize the induction hypothesis
    focus_hyp 0;
    goal_specialize_hyp [ in_ , iv, {{ ctr+6 }}, keys, {{ gcm_enc_6x in_ iv ctr keys buf i }}, {{ i+6 }}, blocks ];
    delete_hyps [0];
    simplify (cryptol_ss ());

    // unfold the body of the 6x loop once
    focus_concl 0;
    simplify (addsimp gcm_enc_blocks_6x_unfolding_lemma2 empty_ss);
    unfolding ["gcm_enc_blocks_6x_unfold"];
    simplify (cryptol_ss ());

    // split on the 6x termination condition
    goal_apply arrayEq_ite_decompose_left;
    goal_intro_hyps 1;

    let go = w4_unint_yices ["gcm_enc_blocks_6x","gcm_enc_blocks","enc_block"];
    let unfold_gcm_enc_blocks =
         do { simplify (addsimp gcm_enc_blocks_unfolding_lemma2 empty_ss);
              unfolding ["gcm_enc_blocks_unfold"];
              simplify (cryptol_ss ());
         };

    // test was true, unfold the single loop six time and finish
    unfold_gcm_enc_blocks;
    unfold_gcm_enc_blocks;
    unfold_gcm_enc_blocks;
    unfold_gcm_enc_blocks;
    unfold_gcm_enc_blocks;
    unfold_gcm_enc_blocks;
    go;

    // test was false, unfold the single loop once to reveal
    // its termination test
    unfold_gcm_enc_blocks;
    go;
  }

  {{ \in iv ctr rndkeys buf i blocks ->
       ( blocks - i
       , arrayEq (gcm_enc_blocks_6x in iv ctr rndkeys buf i blocks)
                 (gcm_enc_blocks in iv ctr rndkeys buf i (blocks - ((blocks-i)%6)))
       )
  }};

arrayRange_gcm_enc_blocks_6x_lemma_8_aux <-
  prove_by_bv_induction
  do {
    simplify (cryptol_ss ());

    // introduce lemma variables
    in_  <- goal_intro "in";
    ivec <- goal_intro "ivec";
    ctr  <- goal_intro "ctr";
    keys <- goal_intro "keys";
    buf  <- goal_intro "buf";
    i    <- goal_intro "i";
    blocks <- goal_intro "blocks";
    offset <- goal_intro "offset";

    // introduce, focus on, and specialize the induction hypothesis
    goal_intro_hyps 1;
    focus_hyp 0;
    goal_specialize_hyp
      [ in_, ivec, {{ ctr+6 }}, keys
      , {{ gcm_enc_6x in_ ivec ctr keys buf i }}
      , {{ i+6 }}, blocks, offset
      ];
    delete_hyps [0]; // remove the IH so it doesn't confuse the solver

    // focus on the conclusion and unroll the recursive definition
    focus_concl 0;
    simplify (addsimp gcm_enc_blocks_6x_unfolding_lemma2 empty_ss);

    // finish up
    w4_unint_yices ["gcm_enc_blocks_6x","enc_block"];
  }
  {{ \in ivec ctr keys buf i blocks offset ->
       ( blocks - i
       , (offset+8 <= i*16 /\ i <= blocks /\ blocks <= 2^^32) ==>
          arrayRangeLookup`{n=8} (gcm_enc_blocks_6x in ivec ctr keys buf i blocks) offset
            == arrayRangeLookup`{n=8} buf offset
       )
  }};

arrayRange_gcm_enc_blocks_6x_lemma_8 <-
  prove_theorem
  do {
    goal_insert arrayRange_gcm_enc_blocks_6x_lemma_8_aux;
    w4_unint_z3 ["gcm_enc_blocks_6x","enc_block"];
  }
  (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
    {{ \in ivec ctr keys buf i blocks offset ->
         arrayRangeLookup`{n=8} (gcm_enc_blocks_6x in ivec ctr keys buf i blocks) offset ==
         arrayRangeLookup`{n=8}
           (if (offset+8 <= i*16 /\ i <= blocks /\ blocks <= 2^^32)
             then buf
             else (gcm_enc_blocks_6x in ivec ctr keys buf i blocks))
           offset
    }}));

arrayRange_gcm_enc_blocks_6x_lemma_16_aux <-
  prove_by_bv_induction
  do {
    simplify (cryptol_ss ());

    // introduce lemma variables
    in_  <- goal_intro "in";
    ivec <- goal_intro "ivec";
    ctr  <- goal_intro "ctr";
    keys <- goal_intro "keys";
    buf  <- goal_intro "buf";
    i    <- goal_intro "i";
    blocks <- goal_intro "blocks";
    offset <- goal_intro "offset";

    // introduce, focus on, and specialize the induction hypothesis
    goal_intro_hyps 1;
    focus_hyp 0;
    goal_specialize_hyp
      [ in_, ivec, {{ ctr+6 }}, keys
      , {{ gcm_enc_6x in_ ivec ctr keys buf i }}
      , {{ i+6 }}, blocks, offset
      ];
    delete_hyps [0]; // remove the IH so it doesn't confuse the solver

    // focus on the conclusion and unroll the recursive definition
    focus_concl 0;
    simplify (addsimp gcm_enc_blocks_6x_unfolding_lemma2 empty_ss);

    // finish up
    w4_unint_yices ["gcm_enc_blocks_6x","enc_block"];
  }
  {{ \in ivec ctr keys buf i blocks offset ->
       ( blocks - i
       , (offset+16 <= i*16 /\ i <= blocks /\ blocks <= 2^^32) ==>
          arrayRangeLookup`{n=16} (gcm_enc_blocks_6x in ivec ctr keys buf i blocks) offset
            == arrayRangeLookup`{n=16} buf offset
       )
  }};


arrayRange_gcm_enc_blocks_6x_lemma_16 <-
  prove_theorem
  do {
    goal_insert arrayRange_gcm_enc_blocks_6x_lemma_16_aux;

    // finish up
    w4_unint_z3 ["gcm_enc_blocks_6x","enc_block"];
  }
  (rewrite (cryptol_ss ()) (unfold_term ["ecEq"]
    {{ \in ivec ctr keys buf i blocks offset ->
         arrayRangeLookup`{n=16} (gcm_enc_blocks_6x in ivec ctr keys buf i blocks) offset ==
         arrayRangeLookup`{n=16}
           (if (offset+16 <= i*16 /\ i <= blocks /\ blocks <= 2^^32)
             then buf
             else (gcm_enc_blocks_6x in ivec ctr keys buf i blocks))
           offset
    }}));
