/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Block/AES.cry";
import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Authenticated/AES_256_GCM.cry";
import "../../spec/AES/X86.cry";
import "../../spec/AES/AES-GCM.cry";

enable_experimental;

set_path_sat_solver "yices";

// Disable debug intrinsics to avoid https://github.com/GaloisInc/crucible/issues/778
disable_debug_intrinsics;

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";
print "loaded bitcode";

include "../common/helpers.saw";
include "../common/memory.saw";

/*
 * Architecture features for the AVX+shrd code path
 */
let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};

/*
 * The GCM implementation has multiple phases:
 * 1) A "bulk" encryption/decryption that operates on multiples of 6 blocks, and computes
 *    AES/CTR32 and GHASH in parallel using different functional units of the CPU.
 * 2) An optimized AES/CTR32 implementation that processes the remaining blocks.
 * 3) An optimized GHASH implementation that processes the remaining blocks.
 *
 * This proof uses "unbounded" verification to do a proof for the bulk encryption/decryption
 * phase for an arbitrary amount of input data (up to the limits imposed by the AES-GCM cipher
 * mode itself), followed by bounded verification of the procedures to process the final
 * remaining blocks.  We know that no more than 18 blocks of data must be processed following
 * the bulk phase, so series of finite verifications suffices.
 */

// These are some magic constants relating to the datastructure
// invariants for the AES/GCM cipher mode.
let NID_aes_256_gcm = 901;
let aes_block_size = 1;

// the IV for AES-GCM consists of 12 bytes = 96 bits
let aes_iv_len = 12;

// The number of bytes in a single AES block
let AES_BLOCK_SIZE = 16;

// This computes the total number of message blocks that can be
// handeled by a single AES/GCM mode session. The GCM counter is
// a 32-bit counter which starts at 1, and we need to leave a block at
// the end for the authentication tag. This gives us a total of
// slightly fewer than 2^^32 blocks we can handle.
let TOTAL_MESSAGE_BLOCKS = eval_size {| 2^^32 - 2 |};

// This is the total number of bytes that can be in the plain/cyphertext
// for AES-GCM.
let TOTAL_MESSAGE_MAX_LENGTH = eval_size {| TOTAL_MESSAGE_BLOCKS * AES_BLOCK_SIZE |};

// This is the maximum number of blocks that can still need
// to be processed following the bulk encrypt/decrypt phase.
// This is due to the fact that the bulk encryption phase processes
// 6 block chunks, and has a pipeline setup which is three stages
// deep.  Thus, 18 blocks is the minimum number of blocks it will
// process; fewer than that and it will simply rely on the
// separate AES/CTR32 and GHASH routines.
let MAX_BLOCKS_AFTER_BULK = 18;

// Prove a collection of useful rewrite rules, mostly
// to do with modular arithmetic and low-level bitvector
// operation rearrangements.
include "goal-rewrites.saw";

// Basic properties of the bare AES block cipher function.
include "AES.saw";

// Data-structure invariants relating to the encryption
// context, expanded key schedules, etc.
include "AES-invariants.saw";

// A series of lemmas relating various low-level Cryptol
// specifications to higher-level ones.
include "Lemmas.saw";

// The bounded proof of the stand-alone GHASH routine.
include "GHASH.saw";

// The bounded proof of the standalone AES/CTR32 routine.
include "AES-HW-CTR.saw";

// The main proofs of the bulk encryption and decryption phases.
// These are partial correctness proofs (i.e., not proving termination)
// using loop invariants to handle an (essentially) unbounded
// amount of data.
include "AESNI-GCM.saw";

// Specifications of the EVP level API functions.
include "evp-function-specs.saw";

// Correctness proofs of the EVP level API functions.
include "evp-function-proofs.saw";

// Equivalence proofs between implementation and high-level specs.
include "implementation-to-spec.saw";

summarize_verification_json "AES-GCM-results.json";
