/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/


/*
 * Verification parameters.
 */
let ec_bits = eval_size {| P384_w |};
let ec_bytes = eval_size {| (ec_bits + 7) / 8 |};
let ec_words = eval_size {| (ec_bytes + 7) / 8 |};
let EC_MAX_BYTES = 66;
let EC_MAX_WORDS = eval_size {| ((EC_MAX_BYTES + 7) / 8) |};

let NID_secp384r1 = 715;
let EVP_PKEY_OP_UNDEFINED = 0;
let EVP_PKEY_OP_KEYGEN = eval_int {{ (1 << 2) : [64] }};
let EVP_PKEY_OP_PARAMGEN = eval_int {{ (1 << 9) : [64] }};

let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};

include "memory.saw";
include "../common/goal-rewrites.saw";
include "../EVP/EVP_CTX.saw";
import "../../spec/EC/EC_FIPS.cry";
include "EC_P384_private.saw";


let points_to_p384_bignum_st ptr d_ptr flags = points_to_bignum_st ptr d_ptr ec_words ec_words flags;


let points_to_AWSLC_fips_evp_pkey_methods = do {
  // AWSLC_fips_evp_pkey_methods_storage global is split into 3 globals
  crucible_points_to (crucible_global "AWSLC_fips_evp_pkey_methods_storage.0.0") (crucible_global "EVP_PKEY_rsa_pkey_meth_storage");
  crucible_points_to (crucible_global "AWSLC_fips_evp_pkey_methods_storage.0.1") (crucible_global "EVP_PKEY_rsa_pss_pkey_meth_storage");
  crucible_points_to (crucible_global "AWSLC_fips_evp_pkey_methods_storage.0.2") (crucible_global "EVP_PKEY_ec_pkey_meth_storage");
  crucible_points_to (crucible_global "AWSLC_fips_evp_pkey_methods_storage.0.3") (crucible_global "EVP_PKEY_hkdf_pkey_meth_storage");
  crucible_points_to (crucible_global "AWSLC_fips_evp_pkey_methods_storage.0.4") (crucible_global "EVP_PKEY_hmac_pkey_meth_storage");
};


let points_to_ec_method_st ptr = do {
  crucible_points_to (crucible_field ptr "point_get_affine_coordinates") (crucible_global "ec_GFp_mont_point_get_affine_coordinates");
  crucible_points_to (crucible_field ptr "jacobian_to_affine_batch") (crucible_global "ec_GFp_mont_jacobian_to_affine_batch");
  crucible_points_to (crucible_field ptr "add") (crucible_global "ec_GFp_mont_add");
  crucible_points_to (crucible_field ptr "dbl") (crucible_global "ec_GFp_mont_dbl");
  crucible_points_to (crucible_field ptr "mul") (crucible_global "ec_GFp_nistp384_point_mul");
  crucible_points_to (crucible_field ptr "mul_base") (crucible_global "ec_GFp_nistp384_point_mul_base");
  crucible_points_to (crucible_field ptr "mul_batch") (crucible_global "ec_GFp_mont_mul_batch");
  crucible_points_to (crucible_field ptr "mul_public") (crucible_global "ec_GFp_nistp384_point_mul_public");
  crucible_points_to (crucible_field ptr "mul_public_batch") (crucible_global "ec_GFp_mont_mul_public_batch");
  crucible_points_to (crucible_field ptr "init_precomp") (crucible_global "ec_GFp_mont_init_precomp");
  crucible_points_to (crucible_field ptr "mul_precomp") (crucible_global "ec_GFp_mont_mul_precomp");
  crucible_points_to (crucible_field ptr "felem_mul") (crucible_global "ec_GFp_mont_felem_mul");
  crucible_points_to (crucible_field ptr "felem_sqr") (crucible_global "ec_GFp_mont_felem_sqr");
  crucible_points_to (crucible_field ptr "felem_to_bytes") (crucible_global "ec_GFp_mont_felem_to_bytes");
  crucible_points_to (crucible_field ptr "felem_from_bytes") (crucible_global "ec_GFp_mont_felem_from_bytes");
  crucible_points_to (crucible_field ptr "felem_reduce") (crucible_global "ec_GFp_mont_felem_reduce");
  crucible_points_to (crucible_field ptr "felem_exp") (crucible_global "ec_GFp_mont_felem_exp");
  crucible_points_to (crucible_field ptr "scalar_inv0_montgomery") (crucible_global "ec_simple_scalar_inv0_montgomery");
  crucible_points_to (crucible_field ptr "scalar_to_montgomery_inv_vartime") (crucible_global "ec_simple_scalar_to_montgomery_inv_vartime");
  crucible_points_to (crucible_field ptr "cmp_x_coordinate") (crucible_global "ec_GFp_mont_cmp_x_coordinate");
};

let points_to_built_in_curve ptr ec_method_ptr = do {
  crucible_points_to (crucible_elem ptr 0) (crucible_term {{ `NID_secp384r1 : [32] }});
  crucible_points_to (crucible_elem ptr 1) (crucible_global "OPENSSL_built_in_curves_do_init.kOIDP384");
  crucible_points_to (crucible_elem ptr 2) (crucible_term {{ 5 : [8] }});
  crucible_points_to (crucible_elem ptr 4) (crucible_term {{ 48 : [8] }});
  crucible_points_to (crucible_elem ptr 5) (crucible_global "kP384Params");
  crucible_points_to (crucible_elem ptr 6) ec_method_ptr;
  points_to_ec_method_st ec_method_ptr;
};


let EC_GFp_mont_method_spec = do {
  crucible_alloc_global "EC_GFp_mont_method_storage";
  crucible_execute_func [];
  points_to_ec_method_st (crucible_global "EC_GFp_mont_method_storage");
  crucible_return (crucible_global "EC_GFp_mont_method_storage");
};

let EC_GFp_nistz256_method_spec = do {
  crucible_alloc_global "EC_GFp_nistz256_method_storage";
  crucible_execute_func [];
  crucible_return (crucible_global "EC_GFp_nistz256_method_storage");
};

let EC_GFp_nistp224_method_spec = do {
  crucible_alloc_global "EC_GFp_nistp224_method_storage";
  crucible_execute_func [];
  crucible_return (crucible_global "EC_GFp_nistp224_method_storage");
};

let OPENSSL_built_in_curves_init_spec = do {
  crucible_alloc_global "OPENSSL_built_in_curves_storage";
  crucible_alloc_global "EC_GFp_mont_method_storage";
  crucible_alloc_global "EC_GFp_nistz256_method_storage";
  crucible_alloc_global "EC_GFp_nistp224_method_storage";
  crucible_execute_func [];
  points_to_built_in_curve
    (crucible_elem (crucible_field (crucible_global "OPENSSL_built_in_curves_storage") "curves") 1)
    (crucible_global "EC_GFp_mont_method_storage");
};


let points_to_EC_WRAPPED_SCALAR ptr scalar = do {
  points_to_p384_bignum_st (crucible_field ptr "bignum") (crucible_field ptr "scalar") BN_FLG_STATIC_DATA;
  crucible_points_to_untyped (crucible_field ptr "scalar") (crucible_term scalar);
};

let points_to_EC_JACOBIAN ptr point = do {
  crucible_points_to_untyped (crucible_field ptr "X") (crucible_term {{ point.X }});
  crucible_points_to_untyped (crucible_field ptr "Y") (crucible_term {{ point.Y }});
  crucible_points_to_untyped (crucible_field ptr "Z") (crucible_term {{ point.Z }});
};

let points_to_fresh_EC_JACOBIAN ptr = do {
  X <- crucible_fresh_var "raw.X" i384;
  crucible_points_to_untyped (crucible_field ptr "X") (crucible_term X);
  Y <- crucible_fresh_var "raw.Y" i384;
  crucible_points_to_untyped (crucible_field ptr "Y") (crucible_term Y);
  Z <- crucible_fresh_var "raw.Z" i384;
  crucible_points_to_untyped (crucible_field ptr "Z") (crucible_term Z);
  return {{ { X = X, Y = Y, Z = Z } : JacobianBVPoint }};
};

let points_to_ec_point_st ptr group_ptr point = do {
  crucible_points_to (crucible_field ptr "group") group_ptr;
  points_to_EC_JACOBIAN (crucible_field ptr "raw") point;
};

let points_to_fresh_ec_point_st ptr group_ptr = do {
  crucible_points_to (crucible_field ptr "group") group_ptr;
  points_to_fresh_EC_JACOBIAN (crucible_field ptr "raw");
};

let pointer_to_fresh_ec_group_st_with_curve_name curve_name = do {
  ptr <- crucible_alloc_readonly (llvm_struct "struct.ec_group_st");

  meth_ptr <- crucible_alloc_readonly (llvm_struct "struct.ec_method_st");
  points_to_ec_method_st meth_ptr;
  crucible_points_to (crucible_field ptr "meth") meth_ptr;

  points_to_ec_point_st (crucible_field ptr "generator") ptr {{ jacobianToMontBV P384_G_Jacobian }};

  crucible_points_to (crucible_field ptr "curve_name") (crucible_term {{ `curve_name : [32] }});

  points_to_bn_mont_ctx_st (crucible_field ptr "order") ec_words {| P384_n |};
  points_to_bn_mont_ctx_st (crucible_field ptr "field") ec_words {| P384_p |};

  crucible_points_to_untyped (crucible_field ptr "a") (crucible_term {{ fieldElementToBV ((P384_a * P384_R_p) % `P384_p) }});
  crucible_points_to_untyped (crucible_field ptr "b") (crucible_term {{ fieldElementToBV ((P384_b * P384_R_p) % `P384_p) }});
  crucible_points_to (crucible_field ptr "a_is_minus3") (crucible_term {{ 1 : [32] }});
  crucible_points_to (crucible_field ptr "field_greater_than_order") (crucible_term {{ 1 : [32] }});

  return ptr;
};
let pointer_to_fresh_ec_group_st = pointer_to_fresh_ec_group_st_with_curve_name NID_secp384r1;


let pointer_to_evp_pkey_method_st = do {
  ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_pkey_method_st");
  points_to_EVP_PKEY_ec_pkey_meth ptr;
  return ptr;
};

let points_to_evp_pkey_ctx_st_common ptr pmeth_ptr = do {
  crucible_points_to (crucible_field ptr "pmeth") pmeth_ptr;
  crucible_points_to (crucible_field ptr "engine") crucible_null;
};

let points_to_evp_pkey_ctx_st ptr pmeth_ptr pkey_ptr peerkey_ptr op data_ptr = do {
  points_to_evp_pkey_ctx_st_common ptr pmeth_ptr;
  crucible_points_to (crucible_field ptr "pkey") pkey_ptr;
  crucible_points_to (crucible_field ptr "peerkey") peerkey_ptr;
  crucible_points_to (crucible_field ptr "operation") (crucible_term {{ `op : [32] }});
  crucible_points_to (crucible_field ptr "data") data_ptr;
};

let points_to_evp_pkey_st_with_references ptr references pkey_ptr = do {
  crucible_points_to (crucible_field ptr "references") (crucible_term references);
  crucible_points_to (crucible_field ptr "type") (crucible_term {{ `EVP_PKEY_EC : [32] }});
  crucible_points_to (crucible_field ptr "pkey") pkey_ptr;
  crucible_points_to (crucible_field ptr "ameth") (crucible_global "ec_asn1_meth");
};

let points_to_evp_pkey_st ptr pkey_ptr = do {
  references <- crucible_fresh_var "references" i32;
  crucible_precond {{ references != 0 }};
  points_to_evp_pkey_st_with_references ptr references pkey_ptr;
};

let POINT_CONVERSION_UNCOMPRESSED = 4;

let points_to_ec_key_st ptr group_ptr pub_key_ptr (priv_specified, priv_key_ptr) = do {
  crucible_points_to (crucible_field ptr "group") group_ptr;
  crucible_points_to (crucible_field ptr "pub_key") pub_key_ptr;
  // If private key is specified, then point the ec_key_st.priv_key to priv_key_ptr
  // Otherwise specify nothing about ec_key_st.priv_key
  if priv_specified then do {
    crucible_points_to (crucible_field ptr "priv_key") priv_key_ptr;
  } else do {
    return (); };
  crucible_points_to (crucible_field ptr "enc_flag") (crucible_term {{ 0 : [32] }});
  crucible_points_to (crucible_field ptr "conv_form") (crucible_term {{ `POINT_CONVERSION_UNCOMPRESSED : [32] }});
  references <- crucible_fresh_var "references" i32;
  crucible_points_to (crucible_field ptr "references") (crucible_term references);
  crucible_points_to (crucible_field ptr "ecdsa_meth") crucible_null;
};

let pointer_to_fresh_ec_key_st group_ptr is_priv = do {
  ec_key_ptr <- crucible_alloc_readonly (llvm_struct "struct.ec_key_st");

  pub_key_ptr <- crucible_alloc_readonly (llvm_struct "struct.ec_point_st");
  pub_key <- points_to_fresh_ec_point_st pub_key_ptr group_ptr;

  // If is_priv is true, then priv_key_ptr is allocated properly.
  // Otherwise, specify nothing for priv_key_ptr.
  (priv_key_ptr, priv_key) <- if is_priv then do {
    priv_key_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_WRAPPED_SCALAR");
    priv_key <- crucible_fresh_var "priv_key" i384;
    points_to_EC_WRAPPED_SCALAR priv_key_ptr priv_key;
    crucible_precond {{ (scalarFromBV priv_key) % `P384_n == scalarFromBV priv_key }};
    return (priv_key_ptr, priv_key);
  } else do {
    // Using crucible_null to keep SAW's type system happy.
    // There is no specification for ec_key_st.priv_key when is_priv is false.
    return (crucible_null, {{ undefined : [384] }});
  };

  points_to_ec_key_st ec_key_ptr group_ptr pub_key_ptr (is_priv, priv_key_ptr);

  return (ec_key_ptr, pub_key, priv_key);
};

let points_to_EC_PKEY_CTX ptr md_ptr = do {
  crucible_points_to (crucible_field ptr "md") md_ptr;
};


let ec_group_new_from_data_spec = do {
  curve_ptr <- crucible_alloc_readonly (llvm_struct "struct.built_in_curve");
  ec_method_ptr <- crucible_alloc_readonly (llvm_struct "struct.ec_method_st");
  points_to_built_in_curve curve_ptr ec_method_ptr;

  crucible_execute_func [curve_ptr];

  ec_group_ptr <- pointer_to_fresh_ec_group_st_with_curve_name 0;
  crucible_return ec_group_ptr;
};

let EC_GROUP_new_by_curve_name_spec = do {
  crucible_execute_func [(crucible_term {{ `NID_secp384r1 : [32] }})];
  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  crucible_return ec_group_ptr;
};

let EC_KEY_check_fips_spec = do {

  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  (key_ptr, pub_key, _priv_key) <- pointer_to_fresh_ec_key_st ec_group_ptr false;

  crucible_execute_func [key_ptr];

  crucible_return (crucible_term {{EC_KEY_check_fips pub_key}});
};

let EC_KEY_free_spec = do {
  key_ptr <- crucible_alloc (llvm_struct "struct.ec_key_st");

  crucible_execute_func [key_ptr];
};

let BN_num_bits_spec num_bits = do {
  bn_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (bn, bn_d_ptr) <- ptr_to_fresh_readonly "bn" i384;
  flags <- crucible_fresh_var "flags" i32;
  points_to_p384_bignum_st bn_ptr bn_d_ptr flags;
  crucible_precond {{ is_num_bits_bn`{num_bits} bn }};
  crucible_execute_func [bn_ptr];
  crucible_return (crucible_term {{ `num_bits : [32] }});
};

let BN_is_zero_spec = do {
  bn_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (bn, bn_d_ptr) <- ptr_to_fresh_readonly "bn" i384;
  flags <- crucible_fresh_var "flags" i32;
  points_to_p384_bignum_st bn_ptr bn_d_ptr flags;
  crucible_execute_func [bn_ptr];
  crucible_return (crucible_term {{ if scalarFromBV bn == 0 then 1 : [32] else 0 }});
};

let BN_is_zero_false_spec = do {
  bn_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (bn, bn_d_ptr) <- ptr_to_fresh_readonly "bn" i384;
  flags <- crucible_fresh_var "flags" i32;
  points_to_p384_bignum_st bn_ptr bn_d_ptr flags;
  crucible_precond {{ scalarFromBV bn != 0 }};
  crucible_execute_func [bn_ptr];
  crucible_return (crucible_term {{ 0 : [32] }});
};

let ec_scalar_is_zero_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  crucible_execute_func [group_ptr, a_ptr];
  crucible_return (crucible_term {{ if scalarFromBV a == 0 then 1 : [32] else 0 }});
};

let ec_scalar_is_zero_false_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  crucible_precond {{ scalarFromBV a != 0 }};
  crucible_execute_func [group_ptr, a_ptr];
  crucible_return (crucible_term {{ 0 : [32] }});
};

let ec_bignum_to_scalar_spec = do {
  ec_group_ptr <- pointer_to_fresh_ec_group_st;
  out_ptr <- crucible_alloc i384;
  in_ptr <- crucible_alloc_readonly (llvm_struct "struct.bignum_st");
  (in_, in_d_ptr) <- ptr_to_fresh_readonly "in" i384;
  flags <- crucible_fresh_var "flags" i32;
  points_to_p384_bignum_st in_ptr in_d_ptr flags;

  crucible_execute_func [ec_group_ptr, out_ptr, in_ptr];

  crucible_points_to out_ptr (crucible_term in_);
  crucible_return (crucible_term {{ if scalarFromBV in_ < `P384_n then 1 : [32] else 0 }});
};

let ec_scalar_to_montgomery_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;

  crucible_execute_func [group_ptr, r_ptr, a_ptr];

  crucible_points_to r_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * P384_R_n) % `P384_n) }});
};

let ec_scalar_to_montgomery_same_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh "a" i384;

  crucible_execute_func [group_ptr, a_ptr, a_ptr];

  crucible_points_to a_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * P384_R_n) % `P384_n) }});
};

let ec_scalar_from_montgomery_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;

  crucible_execute_func [group_ptr, r_ptr, a_ptr];

  crucible_points_to r_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * P384_R_n_inv) % `P384_n) }});
};

let ec_scalar_from_montgomery_same_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh "a" i384;

  crucible_execute_func [group_ptr, a_ptr, a_ptr];

  crucible_points_to a_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * P384_R_n_inv) % `P384_n) }});
};

// These specs are very similar to those of ec_scalar_from_montgomery, as that
// function directly invokes bn_from_montgomery_small. When compiled with
// optimizations, ec_scalar_from_montgomery will be inlined away, exposing a
// call site to bn_from_montgomery_small.
let bn_from_montgomery_small_spec = do {
  r_ptr <- llvm_alloc i384;
  (a, a_ptr) <- ptr_to_fresh "a" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (_, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [r_ptr, width, a_ptr, width, order_mont_ptr];

  llvm_points_to r_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * P384_R_n_inv) % `P384_n) }});
};

let bn_from_montgomery_small_same_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (_, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [a_ptr, width, a_ptr, width, order_mont_ptr];

  llvm_points_to a_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * P384_R_n_inv) % `P384_n) }});
};

let ec_scalar_add_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
  crucible_precond {{ (scalarFromBV a) % `P384_n == scalarFromBV a }};
  crucible_precond {{ (scalarFromBV b) % `P384_n == scalarFromBV b }};

  crucible_execute_func [group_ptr, r_ptr, a_ptr, b_ptr];

  crucible_points_to r_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) + (scalarFromBV b)) % `P384_n) }});
};

let ec_scalar_add_same_l_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
  crucible_precond {{ (scalarFromBV a) % `P384_n == scalarFromBV a }};
  crucible_precond {{ (scalarFromBV b) % `P384_n == scalarFromBV b }};

  crucible_execute_func [group_ptr, a_ptr, a_ptr, b_ptr];

  crucible_points_to a_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) + (scalarFromBV b)) % `P384_n) }});
};

// These specs are very similar to those of ec_scalar_add, as that
// function directly invokes bn_mod_add_words. When compiled with
// optimizations, ec_scalar_add will be inlined away, exposing a
// call site to bn_mod_add_words.
let bn_mod_add_words_spec = do {
  r_ptr <- llvm_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
  llvm_precond {{ (scalarFromBV a) % `P384_n == scalarFromBV a }};
  llvm_precond {{ (scalarFromBV b) % `P384_n == scalarFromBV b }};
  d_ptr <- llvm_alloc_readonly i384;
  llvm_points_to d_ptr (llvm_term {{ fromInteger`{[P384_w]} `P384_n }});
  out_ptr <- llvm_alloc (llvm_array EC_MAX_WORDS i64);

  llvm_execute_func [r_ptr, a_ptr, b_ptr, d_ptr, out_ptr, llvm_term {{ `ec_words : [64] }}];

  llvm_points_to r_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) + (scalarFromBV b)) % `P384_n) }});
};

let bn_mod_add_words_same_l_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
  llvm_precond {{ (scalarFromBV a) % `P384_n == scalarFromBV a }};
  llvm_precond {{ (scalarFromBV b) % `P384_n == scalarFromBV b }};
  d_ptr <- llvm_alloc_readonly i384;
  llvm_points_to d_ptr (llvm_term {{ fromInteger`{[P384_w]} `P384_n }});
  out_ptr <- llvm_alloc (llvm_array EC_MAX_WORDS i64);

  llvm_execute_func [a_ptr, a_ptr, b_ptr, d_ptr, out_ptr, llvm_term {{ `ec_words : [64] }}];

  llvm_points_to a_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) + (scalarFromBV b)) % `P384_n) }});
};

let ec_scalar_mul_montgomery_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;

  crucible_execute_func [group_ptr, r_ptr, a_ptr, b_ptr];

  crucible_points_to r_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
};

let ec_scalar_mul_montgomery_same_r_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh "b" i384;

  crucible_execute_func [group_ptr, b_ptr, a_ptr, b_ptr];

  crucible_points_to b_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
};

let ec_scalar_mul_montgomery_same_l_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  (a, a_ptr) <- ptr_to_fresh "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;

  crucible_execute_func [group_ptr, a_ptr, a_ptr, b_ptr];

  crucible_points_to a_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
};

// These specs are very similar to those of ec_scalar_mul_montgomery, as that
// function directly invokes bn_mod_mul_montgomery_small. When compiled with
// optimizations, ec_scalar_mul_montgomery will be inlined away, exposing a
// call site to bn_mod_mul_montgomery.
let bn_mod_mul_montgomery_small_spec = do {
  r_ptr <- llvm_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (_, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [r_ptr, a_ptr, b_ptr, width, order_mont_ptr];

  llvm_points_to r_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
};

let bn_mod_mul_montgomery_small_same_r_spec = do {
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  (b, b_ptr) <- ptr_to_fresh "b" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (_, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [b_ptr, a_ptr, b_ptr, width, order_mont_ptr];

  llvm_points_to b_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
};

let bn_mod_mul_montgomery_small_same_l_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" i384;
  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (_, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [a_ptr, a_ptr, b_ptr, width, order_mont_ptr];

  llvm_points_to a_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
};

// These specs are very similar to those of ec_scalar_to_montgomery, as that
// function directly invokes bn_to_montgomery_small, which in turn directly
// invokes bn_mod_mul_montgomery_small. When compiled with optimizations,
// ec_scalar_to_montgomery and bn_to_montgomery_small will be inlined away,
// exposing a call site to bn_mod_mul_montgomery.
let bn_mod_mul_montgomery_small_RR_d_spec = do {
  r_ptr <- llvm_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (RR_d_ptr, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [r_ptr, a_ptr, RR_d_ptr, width, order_mont_ptr];

  llvm_points_to r_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * P384_R_n) % `P384_n) }});
};

let bn_mod_mul_montgomery_small_RR_d_same_spec = do {
  (a, a_ptr) <- ptr_to_fresh "a" i384;
  let width = llvm_term {{ `ec_words : [64] }};
  (RR_d_ptr, order_mont_ptr) <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};

  llvm_execute_func [a_ptr, a_ptr, RR_d_ptr, width, order_mont_ptr];

  llvm_points_to a_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * P384_R_n) % `P384_n) }});
};

let ec_simple_scalar_inv0_montgomery_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc i384;
  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;

  crucible_execute_func [group_ptr, r_ptr, a_ptr];

  crucible_points_to r_ptr (crucible_term {{ scalarToBV (((inv0 (scalarFromBV a)) * P384_R_n * P384_R_n) % `P384_n) }});
};


ec_random_nonzero_scalar_out <- crucible_declare_ghost_state "ec_random_nonzero_scalar_out";

let ec_random_nonzero_scalar_spec = do {
  out <- crucible_fresh_cryptol_var "out" {| Integer |};
  crucible_ghost_value ec_random_nonzero_scalar_out out;

  group_ptr <- pointer_to_fresh_ec_group_st;
  out_ptr <- crucible_alloc i384;
  (_additional_data, additional_data_ptr) <- ptr_to_fresh_readonly "a" (llvm_array 32 i8);

  crucible_execute_func [group_ptr, out_ptr, additional_data_ptr];

  crucible_points_to out_ptr (crucible_term {{ scalarToBV (out % `P384_n) }});
  crucible_return (crucible_term {{ 1 : [32] }});
};

// This spec is very similar to that of ec_random_nonzero_scalar, as that
// function directly invokes bn_rand_range_words. When compiled with
// optimizations, ec_random_nonzero_scalar will be inlined away, exposing a
// call site to bn_rand_range_words.
bn_rand_range_words_out <- llvm_declare_ghost_state "bn_rand_range_words_out";

let bn_rand_range_words_spec = do {
  out <- llvm_fresh_cryptol_var "out" {| Integer |};
  llvm_ghost_value bn_rand_range_words_out out;

  out_ptr <- llvm_alloc i384;
  max_exclusive_ptr <- llvm_alloc_readonly i384;
  llvm_points_to max_exclusive_ptr (llvm_term {{ fromInteger`{[P384_w]} `P384_n }});
  additional_data <- llvm_alloc_readonly (llvm_array 32 i8);

  llvm_execute_func [out_ptr, llvm_term {{ 1 : [64] }}, max_exclusive_ptr,
                     llvm_term {{ `ec_words: [64] }}, additional_data];

  llvm_points_to out_ptr (llvm_term {{ scalarToBV (out % `P384_n) }});
  llvm_return (llvm_term {{ 1 : [32] }});
};


let ec_point_mul_scalar_spec = do {

  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc (llvm_struct "struct.EC_JACOBIAN");
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  p <- points_to_fresh_EC_JACOBIAN p_ptr;
  (scalar, scalar_ptr) <- ptr_to_fresh_readonly "p_scalar" i384;
  crucible_precond {{ (scalarFromBV scalar) % `P384_n == scalarFromBV scalar }};

  crucible_execute_func [group_ptr, r_ptr, p_ptr, scalar_ptr];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  points_to_EC_JACOBIAN r_ptr 
    {{ point_mul_generic p scalar }};

  crucible_return (crucible_term {{ 1 : [32] }});
};

let ec_point_mul_scalar_base_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};

  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc (llvm_struct "struct.EC_JACOBIAN");
  (scalar, scalar_ptr) <- ptr_to_fresh_readonly "scalar" i384;
  crucible_precond {{ (scalarFromBV scalar) % `P384_n == scalarFromBV scalar }};

  crucible_execute_func [group_ptr, r_ptr, scalar_ptr];

  global_points_to "OPENSSL_ia32cap_P" {{ ia32cap }};

  points_to_EC_JACOBIAN r_ptr {{ point_mul_base_generic scalar }};
  crucible_return (crucible_term {{ 1 : [32] }});
};

let ec_point_mul_scalar_public_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- crucible_alloc (llvm_struct "struct.EC_JACOBIAN");
  (g_scalar, g_scalar_ptr) <- ptr_to_fresh_readonly "g_scalar" i384;
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  p <- points_to_fresh_EC_JACOBIAN p_ptr;
  (p_scalar, p_scalar_ptr) <- ptr_to_fresh_readonly "p_scalar" i384;
  crucible_precond {{ (scalarFromBV g_scalar) % `P384_n == scalarFromBV g_scalar }};
  crucible_precond {{ (scalarFromBV p_scalar) % `P384_n == scalarFromBV p_scalar }};

  crucible_execute_func [group_ptr, r_ptr, g_scalar_ptr, p_ptr, p_scalar_ptr];

  points_to_EC_JACOBIAN r_ptr
    {{ jacobianToMontBV (ec_point_jacobian_add (ec_point_jacobian_scalar_mul (scalarFromBV g_scalar) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (scalarFromBV p_scalar) (jacobianFromMontBV p))) }};
  crucible_return (crucible_term {{ 1 : [32] }});
};

// This spec is very similar to that of ec_point_mul_scalar_public, as that
// function directly invokes ec_GFp_mont_mul_public_batch. When compiled with
// optimizations, ec_point_mul_scalar_public will be inlined away, exposing a
// call site to ec_GFp_mont_mul_public_batch.
let ec_GFp_mont_mul_public_batch_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  r_ptr <- llvm_alloc (llvm_struct "struct.EC_JACOBIAN");
  (g_scalar, g_scalar_ptr) <- ptr_to_fresh_readonly "g_scalar" i384;
  p_ptr <- llvm_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  p <- points_to_fresh_EC_JACOBIAN p_ptr;
  (p_scalar, p_scalar_ptr) <- ptr_to_fresh_readonly "p_scalar" i384;
  llvm_precond {{ (scalarFromBV g_scalar) % `P384_n == scalarFromBV g_scalar }};
  llvm_precond {{ (scalarFromBV p_scalar) % `P384_n == scalarFromBV p_scalar }};

  llvm_execute_func [group_ptr, r_ptr, g_scalar_ptr, p_ptr, p_scalar_ptr, llvm_term {{ 1 : [64] }}];

  points_to_EC_JACOBIAN r_ptr
    {{ jacobianToMontBV (ec_point_jacobian_add (ec_point_jacobian_scalar_mul (scalarFromBV g_scalar) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (scalarFromBV p_scalar) (jacobianFromMontBV p))) }};
  llvm_return (llvm_term {{ 1 : [32] }});
};

let ec_cmp_x_coordinate_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  p <- points_to_fresh_EC_JACOBIAN p_ptr;
  (r, r_ptr) <- ptr_to_fresh_readonly "r" i384;

  crucible_execute_func [group_ptr, p_ptr, r_ptr];

  crucible_return (crucible_term {{ if (fromJacobian (jacobianFromMontBV p)).x % `P384_n == (scalarFromBV r) % `P384_n then 1 : [32] else 0 }});
};

// This spec is identical to that of ec_cmp_x_coordinate, as that
// function directly invokes ec_GFp_mont_cmp_x_coordinate. When compiled with
// optimizations, ec_cmp_x_coordinate will be inlined away, exposing a
// call site to ec_GFp_mont_cmp_x_coordinate.
let ec_GFp_mont_cmp_x_coordinate_spec = ec_cmp_x_coordinate_spec;

let ec_get_x_coordinate_as_scalar_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  out_ptr <- crucible_alloc i384;
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  p <- points_to_fresh_EC_JACOBIAN p_ptr;

  crucible_execute_func [group_ptr, out_ptr, p_ptr];

  crucible_points_to out_ptr (crucible_term {{ scalarToBV (((fromJacobian (jacobianFromMontBV p)).x) % `P384_n) }});
  crucible_return (crucible_term {{ 1 : [32] }});
};

let ec_get_x_coordinate_as_bytes_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  out_ptr <- crucible_alloc (llvm_array EC_MAX_BYTES i8);
  out_len_ptr <- crucible_alloc i64;
  p_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  p <- points_to_fresh_EC_JACOBIAN p_ptr;

  crucible_execute_func [group_ptr, out_ptr, out_len_ptr, (crucible_term {{ `EC_MAX_BYTES : [64] }}), p_ptr];

  crucible_points_to_untyped out_ptr (crucible_term {{ split`{each=8} (fieldElementToBV (((fromJacobian (jacobianFromMontBV p)).x) % `P384_p)) }});
  crucible_points_to out_len_ptr (crucible_term {{ `ec_bytes : [64] }});
  crucible_return (crucible_term {{ 1 : [32] }});
};

// This spec is currently a bit simplistic, as it will always return 1.
// ec_GFp_simple_is_on_curve is used to check for fault attacks or bugs, and
// as a result, it will never return a non-1 result unless something goes
// unusually wrong.
let ec_GFp_simple_is_on_curve_spec = do {
  group_ptr <- pointer_to_fresh_ec_group_st;
  point_ptr <- llvm_alloc_readonly (llvm_struct "struct.EC_JACOBIAN");
  _point <- points_to_fresh_EC_JACOBIAN point_ptr;

  llvm_execute_func [group_ptr, point_ptr];

  llvm_return (llvm_term {{ 1 : [32] }});
};

// Specification of `AWSLC_fips_evp_pkey_methods_init`, the initialization function
// for `AWSLC_fips_evp_pkey_methods_storage`.
let AWSLC_fips_evp_pkey_methods_init_spec = do {
  crucible_alloc_global "EVP_PKEY_rsa_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_rsa_pss_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_ec_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_hkdf_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_hmac_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_rsa_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_rsa_pss_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_ec_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_hkdf_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_hmac_pkey_meth_once";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.0";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.1";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.2";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.3";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.4";

  crucible_execute_func [];

  points_to_EVP_PKEY_rsa_pkey_meth (crucible_global "EVP_PKEY_rsa_pkey_meth_storage");
  points_to_EVP_PKEY_rsa_pss_pkey_meth (crucible_global "EVP_PKEY_rsa_pss_pkey_meth_storage");
  points_to_EVP_PKEY_ec_pkey_meth (crucible_global "EVP_PKEY_ec_pkey_meth_storage");
  points_to_EVP_PKEY_hkdf_pkey_meth (crucible_global "EVP_PKEY_hkdf_pkey_meth_storage");
  points_to_EVP_PKEY_hmac_pkey_meth (crucible_global "EVP_PKEY_hmac_pkey_meth_storage");
  points_to_AWSLC_fips_evp_pkey_methods;
};
let AWSLC_fips_evp_pkey_methods_spec = do {
  crucible_alloc_global "EVP_PKEY_rsa_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_rsa_pss_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_ec_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_hkdf_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_hmac_pkey_meth_storage";
  crucible_alloc_global "EVP_PKEY_rsa_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_rsa_pss_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_ec_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_hkdf_pkey_meth_once";
  crucible_alloc_global "EVP_PKEY_hmac_pkey_meth_once";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.0";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.1";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.2";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.3";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_storage.0.4";
  crucible_alloc_global "AWSLC_fips_evp_pkey_methods_once";

  crucible_execute_func
    [ (crucible_global "AWSLC_fips_evp_pkey_methods_once")
    , (crucible_global "AWSLC_fips_evp_pkey_methods_init")
    ];

  points_to_EVP_PKEY_rsa_pkey_meth (crucible_global "EVP_PKEY_rsa_pkey_meth_storage");
  points_to_EVP_PKEY_rsa_pss_pkey_meth (crucible_global "EVP_PKEY_rsa_pss_pkey_meth_storage");
  points_to_EVP_PKEY_ec_pkey_meth (crucible_global "EVP_PKEY_ec_pkey_meth_storage");
  points_to_EVP_PKEY_ec_pkey_meth (crucible_global "EVP_PKEY_hkdf_pkey_meth_storage");
  points_to_EVP_PKEY_ec_pkey_meth (crucible_global "EVP_PKEY_hmac_pkey_meth_storage");
  points_to_AWSLC_fips_evp_pkey_methods;
};


////////////////////////////////////////////////////////////////////////////////
// Proof commands

EC_GFp_mont_method_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EC_GFp_mont_method"
  EC_GFp_mont_method_spec;
EC_GFp_nistz256_method_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EC_GFp_nistz256_method"
  EC_GFp_nistz256_method_spec;
EC_GFp_nistp224_method_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EC_GFp_nistp224_method"
  EC_GFp_nistp224_method_spec;


bn_add_words_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_add_words"
  (bn_add_words_spec ec_words);
bn_add_words_same_res_left_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_add_words"
  (bn_add_words_same_res_left_spec ec_words);

bn_sub_words_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_sub_words"
  (bn_sub_words_spec ec_words);

bn_mul_mont_p_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_mont"
  (bn_mul_mont_spec ec_words {| P384_p |});
bn_mul_mont_same_res_left_p_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_mont"
  (bn_mul_mont_same_res_left_spec ec_words {| P384_p |});
bn_mul_mont_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_mont"
  (bn_mul_mont_spec ec_words {| P384_n |});
bn_mul_mont_same_res_left_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_mont"
  (bn_mul_mont_same_res_left_spec ec_words {| P384_n |});
bn_mul_mont_same_res_right_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_mont"
  (bn_mul_mont_same_res_right_spec ec_words {| P384_n |});
bn_mul_mont_same_res_left_n_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_mul_mont"
  (bn_mul_mont_same_res_left_spec ec_words {| P384_n |});

// This is needed for the proofs of bn_select_words. Clang optimizes
// bn_select_words to use code which compares pointers from different
// allocation blocks, which requires relaxing a validity check in Crucible.
enable_lax_pointer_ordering;

bn_select_words_true_ov <- llvm_verify
  m
  "bn_select_words"
  [value_barrier_w_ov]
  true
  (bn_select_words_true_spec ec_words)
  (do {
    w4_unint_z3 [];
  });
bn_select_words_same_res_left_true_ov <- llvm_verify
  m
  "bn_select_words"
  [value_barrier_w_ov]
  true
  (bn_select_words_same_res_left_true_spec ec_words)
  (do {
    w4_unint_z3 [];
  });
bn_select_words_false_ov <- llvm_verify
  m
  "bn_select_words"
  [value_barrier_w_ov]
  true
  (bn_select_words_false_spec ec_words)
  (do {
    w4_unint_z3 [];
  });
bn_select_words_same_res_left_false_ov <- llvm_verify
  m
  "bn_select_words"
  [value_barrier_w_ov]
  true
  (bn_select_words_same_res_left_false_spec ec_words)
  (do {
    w4_unint_z3 [];
  });

// These theorems are used to move an if-expression inside an application of
// integerToBV in the proof for bn_reduce_once_in_place.
bn_reduce_once_in_place_thm_1 <- prove_folding_theorem
  {{ \(c : Bit) (x : Bit) (y1 : Bit) (y2 : Bit) ->
     (if c then (x || y1) else (x || y2)) == (x || (if c then y1 else y2)) }};
bn_reduce_once_in_place_thm_2 <- prove_print w4 (rewrite (add_cryptol_defs ["ecEq"] (cryptol_ss ()))
  {{ \(c : Bit) (x : [384]) (y1 : [384]) (y2 : [384]) ->
     (if c then (x == y1) else (x == y2)) == (x == (if c then y1 else y2)) }});
bn_reduce_once_in_place_thm_3 <- prove_folding_theorem
  {{ \(x : Integer) (y : [384]) (c : Bit) ->
     (if c then integerToBV`{384} x else y) == (if c then integerToBV`{384} x else integerToBV (integerFromBV y)) }};
bn_reduce_once_in_place_thm_4 <- prove_print
  (do {
    w4_unint_z3 ["integerToBV"];
  })
  (rewrite (cryptol_ss ())
  {{ \(x : Integer) (y : [384]) (c : Bit) ->
     (if c then integerToBV`{384} x else integerToBV (integerFromBV y)) == integerToBV`{384} (if c then x else integerFromBV y) }});

let bn_reduce_once_in_place_thms =
  [ bn_reduce_once_in_place_thm_1
  , bn_reduce_once_in_place_thm_2
  , bn_reduce_once_in_place_thm_3
  , bn_reduce_once_in_place_thm_4
  ];

bn_reduce_once_in_place_true_ov <- crucible_llvm_unsafe_assume_spec
  m
  "bn_reduce_once_in_place"
  (bn_reduce_once_in_place_spec true ec_words);
bn_reduce_once_in_place_false_ov <- llvm_verify
  m
  "bn_reduce_once_in_place"
  [ bn_sub_words_ov
  , bn_select_words_same_res_left_true_ov
  , bn_select_words_same_res_left_false_ov
  , value_barrier_w_ov
  ]
  true
  (bn_reduce_once_in_place_spec false ec_words)
  (do {
    goal_eval_unint ["integerToBV", "integerFromBV"];
    simplify (addsimp integerBV_thm empty_ss);
    simplify (addsimp ite_integerToBV_thm empty_ss);
    hoist_ifs_in_goal;
    simplify (addsimps minor_touchup_thms empty_ss);
    simplify (addsimp append_slice_384_thm empty_ss);
    simplify (addsimps bn_reduce_once_in_place_thms empty_ss);
    w4_unint_z3 ["integerToBV", "integerFromBV"];
  });


BN_div_ov <- crucible_llvm_unsafe_assume_spec
  m
  "BN_div"
  (BN_div_spec (eval_size {| 2 * ec_words + 1 |}) ec_words);


EC_GROUP_new_by_curve_name_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EC_GROUP_new_by_curve_name"
  EC_GROUP_new_by_curve_name_spec;

EC_KEY_check_fips_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EC_KEY_check_fips"
  EC_KEY_check_fips_spec;

EC_KEY_free_ov <- crucible_llvm_unsafe_assume_spec
  m
  "EC_KEY_free"
  EC_KEY_free_spec;

BN_is_zero_ov <- llvm_verify
  m
  "BN_is_zero"
  [ value_barrier_w_ov
  ]
  true
  BN_is_zero_spec
  (w4_unint_z3 []);
BN_is_zero_false_ov <- llvm_verify
  m
  "BN_is_zero"
  [ value_barrier_w_ov
  ]
  true
  BN_is_zero_false_spec
  (w4_unint_z3 []);
bn_rand_range_words_ov <- llvm_unsafe_assume_spec
  m
  "bn_rand_range_words"
  bn_rand_range_words_spec;

ec_scalar_is_zero_ov <- llvm_verify
  m
  "ec_scalar_is_zero"
  []
  true
  ec_scalar_is_zero_spec
  (w4_unint_z3 []);
ec_scalar_is_zero_false_ov <- llvm_verify
  m
  "ec_scalar_is_zero"
  []
  true
  ec_scalar_is_zero_false_spec
  (w4_unint_z3 []);

ec_bignum_to_scalar_ov <- llvm_verify
  m
  "ec_bignum_to_scalar"
  [ value_barrier_w_ov
  , ERR_put_error_ov
  ]
  true
  ec_bignum_to_scalar_spec
  (w4_unint_z3 []);

ec_scalar_to_montgomery_ov <- llvm_verify
  m
  "ec_scalar_to_montgomery"
  [bn_mul_mont_n_ov]
  true
  ec_scalar_to_montgomery_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });
ec_scalar_to_montgomery_same_ov <- llvm_verify
  m
  "ec_scalar_to_montgomery"
  [bn_mul_mont_same_res_left_n_ov]
  true
  ec_scalar_to_montgomery_same_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

ec_scalar_from_montgomery_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_scalar_from_montgomery"
  ec_scalar_from_montgomery_spec;
ec_scalar_from_montgomery_same_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_scalar_from_montgomery"
  ec_scalar_from_montgomery_same_spec;

bn_from_montgomery_small_ov <- llvm_unsafe_assume_spec
  m
  "bn_from_montgomery_small"
  bn_from_montgomery_small_spec;
bn_from_montgomery_small_same_ov <- llvm_unsafe_assume_spec
  m
  "bn_from_montgomery_small"
  bn_from_montgomery_small_same_spec;

ec_scalar_add_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_scalar_add"
  ec_scalar_add_spec;

ec_scalar_add_same_l_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_scalar_add"
  ec_scalar_add_same_l_spec;

bn_mod_add_words_ov <- llvm_unsafe_assume_spec
  m
  "bn_mod_add_words"
  bn_mod_add_words_spec;

bn_mod_add_words_same_l_ov <- llvm_unsafe_assume_spec
  m
  "bn_mod_add_words"
  bn_mod_add_words_same_l_spec;

ec_scalar_mul_montgomery_ov <- llvm_verify
  m
  "ec_scalar_mul_montgomery"
  [bn_mul_mont_n_ov]
  true
  ec_scalar_mul_montgomery_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

ec_scalar_mul_montgomery_same_r_ov <- llvm_verify
  m
  "ec_scalar_mul_montgomery"
  [bn_mul_mont_same_res_right_n_ov]
  true
  ec_scalar_mul_montgomery_same_r_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

ec_scalar_mul_montgomery_same_l_ov <- llvm_verify
  m
  "ec_scalar_mul_montgomery"
  [bn_mul_mont_same_res_left_n_ov]
  true
  ec_scalar_mul_montgomery_same_l_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

bn_mod_mul_montgomery_small_ov <- llvm_verify
  m
  "bn_mod_mul_montgomery_small"
  [bn_mul_mont_n_ov]
  true
  bn_mod_mul_montgomery_small_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

bn_mod_mul_montgomery_small_same_r_ov <- llvm_verify
  m
  "bn_mod_mul_montgomery_small"
  [bn_mul_mont_same_res_right_n_ov]
  true
  bn_mod_mul_montgomery_small_same_r_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

bn_mod_mul_montgomery_small_same_l_ov <- llvm_verify
  m
  "bn_mod_mul_montgomery_small"
  [bn_mul_mont_same_res_left_n_ov]
  true
  bn_mod_mul_montgomery_small_same_l_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

bn_mod_mul_montgomery_small_RR_d_ov <- llvm_verify
  m
  "bn_mod_mul_montgomery_small"
  [bn_mul_mont_n_ov]
  true
  bn_mod_mul_montgomery_small_RR_d_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

bn_mod_mul_montgomery_small_RR_d_same_ov <- llvm_verify
  m
  "bn_mod_mul_montgomery_small"
  [bn_mul_mont_same_res_left_n_ov]
  true
  bn_mod_mul_montgomery_small_RR_d_same_spec
  (do {
    goal_eval_unint [];
    w4_unint_z3 [];
  });

ec_simple_scalar_inv0_montgomery_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_simple_scalar_inv0_montgomery"
  ec_simple_scalar_inv0_montgomery_spec;

ec_random_nonzero_scalar_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_random_nonzero_scalar"
  ec_random_nonzero_scalar_spec;

ec_GFp_simple_is_on_curve_ov <- llvm_unsafe_assume_spec
  m
  "ec_GFp_simple_is_on_curve"
  ec_GFp_simple_is_on_curve_spec;

ec_point_mul_scalar_ov <- llvm_verify m "ec_point_mul_scalar"
  [ p384_point_mul_ov 
  , ec_GFp_simple_is_on_curve_ov
  ]
  true
  ec_point_mul_scalar_spec
  (do{
  w4_unint_z3 ["point_mul"];
  });


ec_point_mul_scalar_base_ov <- llvm_verify m "ec_point_mul_scalar_base"
  [ p384_point_mul_base_ov
  , ec_GFp_simple_is_on_curve_ov
  , value_barrier_u32_ov ]
  true
  ec_point_mul_scalar_base_spec
  (do {
  w4_unint_z3 ["point_mul_base"];
  });

ec_point_mul_scalar_public_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_point_mul_scalar_public"
  ec_point_mul_scalar_public_spec;

ec_GFp_mont_mul_public_batch_ov <- llvm_unsafe_assume_spec
  m
  "ec_GFp_mont_mul_public_batch"
  ec_GFp_mont_mul_public_batch_spec;

ec_cmp_x_coordinate_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_cmp_x_coordinate"
  ec_cmp_x_coordinate_spec;

ec_GFp_mont_cmp_x_coordinate_ov <- llvm_unsafe_assume_spec
  m
  "ec_GFp_mont_cmp_x_coordinate"
  ec_GFp_mont_cmp_x_coordinate_spec;

ec_get_x_coordinate_as_scalar_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_get_x_coordinate_as_scalar"
  ec_get_x_coordinate_as_scalar_spec;

ec_get_x_coordinate_as_bytes_ov <- crucible_llvm_unsafe_assume_spec
  m
  "ec_get_x_coordinate_as_bytes"
  ec_get_x_coordinate_as_bytes_spec;

llvm_verify m "AWSLC_fips_evp_pkey_methods_init"
  [ EVP_PKEY_rsa_pkey_meth_ov
  , EVP_PKEY_rsa_pss_pkey_meth_ov
  , EVP_PKEY_ec_pkey_meth_ov
  , EVP_PKEY_hkdf_pkey_meth_ov
  , EVP_PKEY_hmac_pkey_meth_ov
  ]
  true
  AWSLC_fips_evp_pkey_methods_init_spec
  (w4_unint_z3 []);
AWSLC_fips_evp_pkey_methods_ov <- llvm_unsafe_assume_spec
  m
  "CRYPTO_once"
  AWSLC_fips_evp_pkey_methods_spec;
