/*
* Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
* SPDX-License-Identifier: Apache-2.0
*/

enable_experimental;

import "../../../cryptol-specs/Primitive/Keyless/Hash/SHA384.cry";
import "../../spec/HASH/HMAC.cry";
import "../../spec/KDF/HKDF.cry";

// include "../SHA512/goal-rewrites.saw";
include "../SHA512/SHA512-384-common.saw";
include "../SHA512/goal-rewrites.saw";
include "../SHA512/SHA512-function-specs.saw";
include "../HMAC/HMAC-SHA384.saw";
include "../HMAC/HMAC-common.saw";
include "../HMAC/HMAC-array.saw";

// Assume HMAC, HMAC_Init_ex, HMAC_Update and HMAC_Final satisfy the specs to save proof time
// The specifications are verified in ../HMAC/verify-HMAC.saw
HMAC_array_withLength_ov <- crucible_llvm_unsafe_assume_spec m "HMAC" (HMAC_array_spec true);
HMAC_Init_ex_array_ov <- crucible_llvm_unsafe_assume_spec m "HMAC_Init_ex" HMAC_Init_ex_array_spec;
HMAC_Update_array_ov <- crucible_llvm_unsafe_assume_spec m "HMAC_Update" HMAC_Update_array_spec;
HMAC_Final_array_ov <- crucible_llvm_unsafe_assume_spec m "HMAC_Final" (HMAC_Final_array_spec false);

let digestOut_len64_pre = do {
  out_ptr <- crucible_alloc (llvm_array SHA_DIGEST_LENGTH i8);
  out_len_ptr <- crucible_alloc i64;
  return (out_ptr, out_len_ptr);
};

let digestOut_len64_post out_ptr out_len_ptr out_value = do {
  crucible_points_to out_ptr out_value;
  crucible_points_to out_len_ptr (crucible_term {{`SHA_DIGEST_LENGTH : [64]}} );
};

// HKDF_extract
let HKDF_extract_spec = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;
  alloc_hmac_globals;
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  secret_len <- crucible_fresh_var "secret_len" i64;
  (secret, secret_ptr) <- ptr_to_fresh_array_readonly "secret" secret_len;
  salt_len <- crucible_fresh_var "salt_len" i64;
  (salt, salt_ptr) <- ptr_to_fresh_array_readonly "salt" salt_len;

  (out_ptr, out_len_ptr) <- digestOut_len64_pre;

  crucible_execute_func
  [ out_ptr
  , out_len_ptr
  , (crucible_global (md_storage HMAC_MD_INDEX))
  , secret_ptr
  , (crucible_term secret_len)
  , salt_ptr
  , (crucible_term salt_len)
  ];

  digestOut_len64_post out_ptr out_len_ptr (crucible_term {{ HKDF_extract salt salt_len secret secret_len }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

let verify_HKDF_extract = do {
  print "Verifying HKDF_extract";
  llvm_verify m "HKDF_extract"
  [HMAC_array_withLength_ov]
  true
  HKDF_extract_spec
  (do {
    goal_eval_unint ["HMAC_Array"];
    w4_unint_z3 ["HMAC_Array"];
  });
};
verify_HKDF_extract;

// HKDF_expand
let HKDF_expand_spec outLen = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  alloc_md_globals;
  alloc_hmac_globals;
  points_to_env_md_st (crucible_global (md_storage HMAC_MD_INDEX));

  out_ptr <- llvm_alloc (llvm_array outLen i8);
  (prk, prk_ptr) <- ptr_to_fresh_readonly "prk" (llvm_array SHA_DIGEST_LENGTH i8);
  info_len <- crucible_fresh_var "info_len" i64;
  (info, info_ptr) <- ptr_to_fresh_array_readonly "info" info_len;

  crucible_execute_func
  [ out_ptr
  , (crucible_term {{ `outLen : [64] }} )
  , (crucible_global (md_storage HMAC_MD_INDEX))
  , prk_ptr
  , (crucible_term {{ `SHA_DIGEST_LENGTH : [64]}} )
  , info_ptr
  , (crucible_term info_len)
  ];

  crucible_points_to out_ptr (crucible_term {{ HKDF_expand`{l = outLen} prk info info_len }});

  crucible_return (crucible_term {{ 1 : [32] }});
};

let verify_HKDF_expand = do {
  print "Verifying HKDF_expand";
  llvm_verify m "HKDF_expand"
  [ HMAC_Final_array_ov
  , HMAC_Update_array_ov
  , HMAC_Init_ex_array_ov
  , OPENSSL_cleanse_ov
  ]
  true
  (HKDF_expand_spec 32)
  (do {
    goal_eval_unint ["HMACInit_Array", "HMACUpdate_Array", "HMACFinal_Array"];
    print_goal;
    w4_unint_z3 ["HMACInit_Array", "HMACUpdate_Array", "HMACFinal_Array"];
  });
};
verify_HKDF_expand;
