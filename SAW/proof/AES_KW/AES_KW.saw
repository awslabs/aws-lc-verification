/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
*/

enable_experimental;

import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Block/AESKeyWrap.cry";
import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Block/AESKeyWrapPadded.cry";
import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Block/AES.cry";
import "../../../cryptol-specs/Primitive/Symmetric/Cipher/Authenticated/AES_256_GCM.cry";
import "../../spec/AES/X86.cry";
import "../../spec/AES/AES-GCM.cry";

m <- llvm_load_module "../../build/llvm/crypto/crypto_test.bc";

// Include helper functions
include "../common/helpers.saw";
// Include memory management specs
include "../common/memory.saw";

// The value_barrier_w function is used to prevent compiler optimizations that might
// break constant-time implementations. The functional spec is that it takes a value
// and returns it with no side effects.
let value_barrier_w_spec = do {
  
  a <- crucible_fresh_var "a" (llvm_int 64);
  crucible_execute_func [crucible_term a];
  crucible_return (crucible_term a);
};

value_barrier_w_ov <- llvm_verify_x86 m "../../build/x86/crypto/crypto_test" "value_barrier_w"
  []
  true
  value_barrier_w_spec
  (do {
    w4_unint_yices [];
  });


let {{ ia32cap = [0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff] : [4][32] }};
let do_prove = false;
include "../AES/goal-rewrites-AES.saw";
include "../AES/AES.saw";

let {{ kw_iv = [0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6] : [8][8] }};

let ivPre withIv = do {
  if withIv then do {
    ptr_to_fresh_readonly "iv" (llvm_array 8 (llvm_int 8));
  } else do {
    return ({{kw_iv}}, crucible_null);
  };
};

let AES_wrap_key_spec withIv len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  key <- fresh_aes_key_st;
  points_to_aes_key_st key_ptr key;
  (iv, iv_ptr) <- ivPre withIv;
  (indata, indata_ptr) <- ptr_to_fresh_readonly "in" (llvm_array len (llvm_int 8));
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array (eval_size {|len+8|}) (llvm_int 8));

  crucible_execute_func [key_ptr, iv_ptr, out_ptr, indata_ptr, crucible_term {{`len : [64]}}];

  crucible_points_to out_ptr (crucible_term {{aesWrapKey (join key) iv indata}});
  crucible_return (crucible_term {{`len+8 : [32]}});
};

let AES_unwrap_key_spec withIv len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ia32cap}};
  
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  (key_low, key_high) <- fresh_aes_key_256_parts;
  points_to_inv_aes_key_st key_ptr (key_low, key_high);
  (iv, iv_ptr) <- ivPre withIv;
  (indata, indata_ptr) <- ptr_to_fresh_readonly "in" (llvm_array (eval_size {|len+8|}) (llvm_int 8));
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array len (llvm_int 8));

  crucible_execute_func [key_ptr, iv_ptr, out_ptr, indata_ptr, crucible_term {{`len+8 : [64]}}];

  // The cryptol spec only produces the plaintext when unwrap succeeds. So this part is only checked conditionally.
  // Use a new symbolic variable to represent the value stored in the output buffer.
  unwrapped <- crucible_fresh_var "unwrapped" (llvm_array len (llvm_int 8));
  // If the unwrap succeeds, the output buffer holds this symbolic value, and this value is equal to the result of unwrap.
  crucible_conditional_points_to {{(aesUnwrapKey (join (key_low#key_high)) iv indata).0}} out_ptr (crucible_term unwrapped);
  crucible_postcond {{(aesUnwrapKey (join (key_low#key_high)) iv indata).0 ==> (aesUnwrapKey (join (key_low#key_high)) iv indata).1 == unwrapped}};
  crucible_return (crucible_term {{if (aesUnwrapKey (join (key_low#key_high)) iv indata).0 then (`len : [32]) else (-1 : [32])}});
};

let AES_wrap_key_bad_length_spec withIv len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ ia32cap }};
  
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  key <- fresh_aes_key_st;
  points_to_aes_key_st key_ptr key;
  (iv, iv_ptr) <- ivPre withIv;
  (indata, indata_ptr) <- ptr_to_fresh_readonly "in" (llvm_array len (llvm_int 8));
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array (eval_size {|len+8|}) (llvm_int 8));

  crucible_execute_func [key_ptr, iv_ptr, out_ptr, indata_ptr, crucible_term {{`len : [64]}}];

  crucible_return (crucible_term {{-1 : [32]}});
};

let AES_unwrap_key_bad_length_spec withIv len = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ia32cap}};
  
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  (key_low, key_high) <- fresh_aes_key_256_parts;
  points_to_inv_aes_key_st key_ptr (key_low, key_high);
  (iv, iv_ptr) <- ivPre withIv;
  (indata, indata_ptr) <- ptr_to_fresh_readonly "in" (llvm_array (eval_size {|len+8|}) (llvm_int 8));
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array len (llvm_int 8));

  crucible_execute_func [key_ptr, iv_ptr, out_ptr, indata_ptr, crucible_term {{`len+8 : [64]}}];

  crucible_return (crucible_term {{-1 : [32]}});
};

let {{kwp_iv = [0xa6, 0x59, 0x59, 0xa6] : [4][8]}};

// The core spec for (un)wrap padded accepts a plaintext length and pad length.
// The correct pad length is calculated by the top-level spec.
let AES_wrap_key_padded_size_spec len pad = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ia32cap}};
  
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  key <- fresh_aes_key_st;
  points_to_aes_key_st key_ptr key;
  (indata, indata_ptr) <- ptr_to_fresh_readonly "in" (llvm_array len (llvm_int 8));
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array (eval_size {|len+pad+8|}) (llvm_int 8));
  (out_len, out_len_ptr) <- ptr_to_fresh "out" (llvm_int 64);

  crucible_execute_func [key_ptr, out_ptr, out_len_ptr, crucible_term {{`len+`pad+8 : [64]}}, indata_ptr, crucible_term {{`len : [64]}}];

  crucible_points_to out_ptr (crucible_term {{aesWrapKeyPadded`{len, pad} (join key) kwp_iv indata}});
  crucible_points_to out_len_ptr (crucible_term {{`len+`pad+8 : [64]}});
  crucible_return (crucible_term {{1 : [32]}});
};

let AES_wrap_key_padded_spec len = AES_wrap_key_padded_size_spec len {|(len+7)/8*8-len|};

let AES_unwrap_key_padded_size_spec len pad = do {
  global_alloc_init "OPENSSL_ia32cap_P" {{ia32cap}};
  
  key_ptr <- crucible_alloc_readonly (llvm_struct "struct.aes_key_st");
  (key_low, key_high) <- fresh_aes_key_256_parts;
  points_to_inv_aes_key_st key_ptr (key_low, key_high);
  (indata, indata_ptr) <- ptr_to_fresh_readonly "in" (llvm_array (eval_size {|len+pad+8|}) (llvm_int 8));
  (out, out_ptr) <- ptr_to_fresh "out" (llvm_array (eval_size {|len + pad|}) (llvm_int 8));
  (out_len_in, out_len_ptr) <- ptr_to_fresh "out" (llvm_int 64);

  crucible_execute_func [key_ptr, out_ptr, out_len_ptr, crucible_term {{`len+`pad : [64]}}, indata_ptr, crucible_term {{`len+`pad+8 : [64]}}];

  // The cryptol spec only produces the plaintext when unwrap succeeds. So this part is only checked conditionally.
  // Use a new symbolic variable to represent the value stored in the output buffer.
  unwrapped <- crucible_fresh_var "unwrapped" (llvm_array (eval_size {|len + pad|}) (llvm_int 8));
  // If the unwrap succeeds, the output buffer holds this symbolic value, and this value is equal to the result of unwrap.
  crucible_conditional_points_to {{(aesUnwrapKeyPadded (join (key_low#key_high)) kwp_iv indata).0}} out_ptr (crucible_term unwrapped);
  crucible_postcond {{(aesUnwrapKeyPadded (join (key_low#key_high)) kwp_iv indata).0 ==> (aesUnwrapKeyPadded (join (key_low#key_high)) kwp_iv indata).2 == unwrapped}};

  // Similarly, the output length is only correct when unwrap succeeds.
  out_len_out <- crucible_fresh_var "out_len_out" (llvm_int 64);
  crucible_conditional_points_to {{(aesUnwrapKeyPadded (join (key_low#key_high)) kwp_iv indata).0}} out_len_ptr (crucible_term out_len_out);
  crucible_postcond {{(aesUnwrapKeyPadded (join (key_low#key_high)) kwp_iv indata).0 ==> 
    out_len_out == (0 : [32]) # (join (aesUnwrapKeyPadded`{len+pad+8} (join (key_low#key_high)) kwp_iv indata).1)}};

  crucible_return (crucible_term {{if (aesUnwrapKeyPadded`{len+pad+8} (join (key_low#key_high)) kwp_iv indata).0 then (1 : [32]) else (0 : [32])}});
};

let AES_unwrap_key_padded_spec len = AES_unwrap_key_padded_size_spec len {|(len+7)/8*8-len|};


// Wrap and unwrap (unpadded) proof commands

// Outer loop over whether an IV is supplied
let verify_wrap_iv withIv = do {
  // Testing at length 16 is sufficient to cover all "good" branches and boundary conditions.
  // Additional checks are for common key sizes (32), and for extra spot checking
  wrap_lengths <- for (eval_list {{ [16, 24, 32, 40] : [4][32] }})
    (\x -> (return (eval_int x)) : (TopLevel Int));
  // Wrap and unwrap (no padding) proof commands
  let verify_wrap length = do {
    crucible_llvm_verify m "AES_wrap_key" [aes_hw_encrypt_in_place_ov] true (AES_wrap_key_spec withIv length) (do {w4_unint_yices ["aesEncrypt"];});

    crucible_llvm_verify m "AES_unwrap_key" [aes_hw_decrypt_in_place_ov] true (AES_unwrap_key_spec withIv length) (do {w4_unint_yices ["aesDecrypt"];});
  };
  for wrap_lengths verify_wrap;

  // Remaining cases cover wrap/unwrap failure due to bad size
  wrap_bad_lengths <- for (eval_list {{ ([0 .. 15]#[17]): [17][32] }})
    (\x -> (return (eval_int x)) : (TopLevel Int));
  // Wrap and unwrap (no padding) proof commands
  let verify_bad_wrap length = do {
    crucible_llvm_verify m "AES_wrap_key" [] true (AES_wrap_key_bad_length_spec withIv length) (do {w4_unint_yices [];});

    crucible_llvm_verify m "AES_unwrap_key" [] true (AES_unwrap_key_bad_length_spec withIv length) (do {w4_unint_yices [];});
  };
  for wrap_bad_lengths verify_bad_wrap;
};
for [false, true] verify_wrap_iv;


// Wrap and unwrap (padded) proof commands

// Wrap (padded) uses a temporary heap buffer.
// Assume correct behavior of malloc at the appropriate size.
OPENSSL_malloc_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 16);

OPENSSL_free_nonnull_16_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  (OPENSSL_free_nonnull_spec 16);

OPENSSL_malloc_24_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 24);

OPENSSL_free_nonnull_24_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  (OPENSSL_free_nonnull_spec 24);

OPENSSL_malloc_32_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_malloc"
  (OPENSSL_malloc_spec 32);

OPENSSL_free_nonnull_32_ov <- crucible_llvm_unsafe_assume_spec
  m
  "OPENSSL_free"
  (OPENSSL_free_nonnull_spec 32);

// Up to 8 bytes, the code uses a simpler branch that only performs a single encrypt.
// After 16 bytes, all code and boundary conditions are covered.
// Length 32 is also included because it is a common key size.
wrap_padded_lengths <- for (eval_list {{ ([1 .. 16]#[32]) : [18][32] }})
  (\x -> (return (eval_int x)) : (TopLevel Int));

let verify_wrap_padded length = do {
  crucible_llvm_verify m "AES_wrap_key_padded" 
    [aes_hw_encrypt_ov, aes_hw_encrypt_in_place_ov, 
      OPENSSL_malloc_16_ov, OPENSSL_free_nonnull_16_ov,
      OPENSSL_malloc_24_ov, OPENSSL_free_nonnull_24_ov,
      OPENSSL_malloc_32_ov, OPENSSL_free_nonnull_32_ov
    ] 
    true 
    (AES_wrap_key_padded_spec length)
    (do {w4_unint_yices ["aesEncrypt"];});

  crucible_llvm_verify m "AES_unwrap_key_padded" 
    [aes_hw_decrypt_ov, aes_hw_decrypt_in_place_ov, value_barrier_w_ov] 
    true 
    (AES_unwrap_key_padded_spec length)
    (do {w4_unint_yices ["aesDecrypt"];});
};
for wrap_padded_lengths verify_wrap_padded;

