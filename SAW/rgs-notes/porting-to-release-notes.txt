The first issue I run into is:

```
[19:10:45.544] Loading file "/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES/AESNI-GCM.saw"
[19:10:45.600] Finding symbol for "aesni_gcm_encrypt"
[19:10:45.635] Found symbol at address 0x6c49a0, building CFG
[19:10:45.737] Simulating function "aesni_gcm_encrypt" (at address 0x6c49a0)
[19:10:45.737] Examining specification to determine preconditions

[19:10:46.196] Simulating function
[19:10:46.257] Examining specification to determine postconditions
[19:10:46.332] Simulation finished, running solver on 20 goals
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
[19:11:05.049] All goals succeeded
[19:11:05.104] Finding symbol for "aesni_gcm_decrypt"
[19:11:05.135] Found symbol at address 0x6c4700, building CFG
[19:11:05.202] Simulating function "aesni_gcm_decrypt" (at address 0x6c4700)
[19:11:05.202] Examining specification to determine preconditions

[19:11:05.658] Simulating function
[19:11:05.721] Examining specification to determine postconditions
[19:11:05.783] Simulation finished, running solver on 25 goals
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
Calling Yices to check sat
Running check sat
[19:11:17.755] All goals succeeded
[19:11:17.825] Finding symbol for "aes_hw_ctr32_encrypt_blocks"
[19:11:17.859] Found symbol at address 0x6c5b00, building CFG
[19:11:17.980] Simulating function "aes_hw_ctr32_encrypt_blocks" (at address 0x6c5b00)
[19:11:17.980] Examining specification to determine preconditions
[19:11:18.209] Simulating function
[19:11:18.229] Examining specification to determine postconditions
[19:11:18.246] Simulation finished, running solver on 1 goals
Calling Yices to check sat
Running check sat
[19:11:23.323] All goals succeeded
[19:11:23.367] Finding symbol for "aes_hw_ctr32_encrypt_blocks"
[19:11:23.414] Found symbol at address 0x6c5b00, building CFG
[19:11:23.532] Simulating function "aes_hw_ctr32_encrypt_blocks" (at address 0x6c5b00)
[19:11:23.532] Examining specification to determine preconditions
[19:11:23.756] Simulating function
[19:11:23.775] Examining specification to determine postconditions
[19:11:23.792] Simulation finished, running solver on 1 goals
Calling Yices to check sat
Running check sat
[19:11:30.553] All goals succeeded
[19:11:30.554] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES/verify-AES-GCM-quickcheck.saw:11:1-11:8):
"llvm_sizeof" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES/AES-GCM.saw:141:28-141:39):
llvm_sizeof: Unsupported type: %struct.EVP_AES_GCM_CTX
Details:
Unknown type alias Ident "struct.EVP_AES_GCM_CTX"

2021/05/12 15:11:31 Failed to run saw script %s.verify-AES-GCM-quickcheck.sawexit status 2
exit status 1
```

After a tentative `saw-script` fix for the issue above:

```
$ PATH=~/Documents/Hacking/Haskell/sandbox/saw-script/bin:$PATH CRYPTOLPATH=$(pwd)/../cryptol-specs ./scripts/entrypoint_check.sh

<elided>

[20:54:12.793] Loading file "/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES/evp-function-specs.saw"
[20:54:12.799] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES/verify-AES-GCM-quickcheck.saw:11:1-11:8):
"crucible_llvm_unsafe_assume_spec" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES/AES-GCM.saw:243:31-243:63):
Could not find definition for function named `aes_gcm_from_cipher_ctx`.
Run SAW with --sim-verbose=3 to see all function names

2021/05/17 16:54:13 Failed to run saw script %s.verify-AES-GCM-quickcheck.sawexit status 2
exit status 1
```

That can be worked around by marking `aes_gcm_from_cipher_ctx` as `__attribute__((noinline))` and changing its spec slightly:

```diff
+// let aes_gcm_from_cipher_ctx_spec = do {
+//   ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_ctx_st");
+//   cipher_data_ptr <- crucible_alloc_readonly_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");
+//   crucible_points_to (crucible_field ctx_ptr "cipher_data") cipher_data_ptr;
+//
+//   crucible_execute_func [ctx_ptr];
+//
+//   crucible_return cipher_data_ptr;
+// };
+
 let aes_gcm_from_cipher_ctx_spec = do {
-  ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_cipher_ctx_st");
   cipher_data_ptr <- crucible_alloc_readonly_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");
-  crucible_points_to (crucible_field ctx_ptr "cipher_data") cipher_data_ptr;

-  crucible_execute_func [ctx_ptr];
+  crucible_execute_func [cipher_data_ptr];

   crucible_return cipher_data_ptr;
 };
```

Or simply:

```
let aes_gcm_from_cipher_ctx_spec = do {
  cipher_data_ptr <- crucible_alloc_readonly_aligned 16 (llvm_struct "struct.EVP_AES_GCM_CTX");

  crucible_execute_func [cipher_data_ptr];

  crucible_return cipher_data_ptr;
};
```

Next issue:

```
[15:39:41.411] Loading file "/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/internal.saw"
[15:39:41.512] Assume override CRYPTO_get_fork_generation
[15:39:41.514] Finding symbol for "value_barrier_w"
[15:39:41.543] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES_KW/verify-AES_KWP.saw:6:1-6:8):
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES_KW/AES_KWP.saw:19:1-19:8):
"llvm_verify_x86" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/internal.saw:91:23-91:38):
"crucible_llvm_verify_x86" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:69:8-69:32):
Could not find symbol "value_barrier_w"
```

Indeed, `value_barrier_w` (and `constant_time_select_w`, a function which uses `value_barrier_w`) are inlined away. I decided to just comment out the specs/overrides involving these functions to see what would happen.

...This is what happened:

```
[16:17:56.132] Verifying AES_unwrap_key_padded ...
[16:17:56.134] Simulating AES_unwrap_key_padded ...
[16:17:56.135] Registering overrides for `aes_hw_decrypt`
[16:17:56.135]   variant `Symbol "aes_hw_decrypt"`
[16:17:56.139] Matching 2 overrides of  aes_hw_decrypt ...
[16:17:56.141] Branching on 1 override variants of aes_hw_decrypt ...
[16:17:56.141] Applied override! aes_hw_decrypt
[16:17:56.145] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES_KW/verify-AES_KWP.saw:6:1-6:8):
"for" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES_KW/AES_KWP.saw:117:1-117:4):
"verify_wrap_padded" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES_KW/AES_KWP.saw:117:25-117:43):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/AES_KW/AES_KWP.saw:110:3-110:23):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/self_check/../tls/../../internal.h:270:3: error: in AES_unwrap_key_padded
  unsupported LLVM value: ValAsm False False "" "=r,0,~{dirflag},~{fpsr},~{flags}" of type i64(i64)*
```

Wouldn't you know it, inlining `value_barrier_w`/`constant_time_select_w` causes inline assembly to appear in the LLVM bitcode for `AES_unwrap_key_padded`, and `llvm_verify` can't handle inline assembly. Even trivial inline assembly, such as what `value_barrier_w` is using. Hm.

For now, I added an ugly hack in Crucible which will allow this to work, given that `value_barrier_w` is essentially the identity function:

```diff
diff --git a/crucible-llvm/src/Lang/Crucible/LLVM/Translation/Instruction.hs b/crucible-llvm/src/Lang/Crucible/LLVM/Translation/Instruction.hs
index fe0015d7..7fd6523c 100644
--- a/crucible-llvm/src/Lang/Crucible/LLVM/Translation/Instruction.hs
+++ b/crucible-llvm/src/Lang/Crucible/LLVM/Translation/Instruction.hs
@@ -1789,28 +1789,36 @@ callFunction ::
    [L.Typed L.Value] {- ^ argument list -} ->
    (LLVMExpr s arch -> LLVMGenerator s arch ret ()) {- ^ assignment continuation for return value -} ->
    LLVMGenerator s arch ret ()
-callFunction instr _tailCall fnTy@(L.FunTy lretTy _largTys _varargs) fn args assign_f = do
-  let err :: String -> a
-      err = \msg -> malformedLLVMModule "Invalid type in function call" $
-                       [ fromString msg ]
-                       ++
-                       maybe [] ((:[]) . fromString . showInstr) instr
-
-  fnTy'  <- either (err . displayException) return $ liftMemType (L.PtrTo fnTy)
-  retTy' <- either (err . displayException) return $ liftRetType lretTy
-  fn'    <- transValue fnTy' fn
-  args'  <- mapM transTypedValue args
-
-  let ?err = err
-  unpackArgs args' $ \_archProxy argTypes args'' ->
-    llvmRetTypeAsRepr retTy' $ \retTy ->
-      case asScalar fn' of
-        Scalar _ PtrRepr ptr -> do
-          memVar <- getMemVar
-          v   <- extensionStmt (LLVM_LoadHandle memVar fnTy ptr argTypes retTy)
-          ret <- call v args''
-          assign_f (BaseExpr retTy ret)
-        _ -> fail $ unwords ["unsupported function value", show fn]
+callFunction instr _tailCall fnTy@(L.FunTy lretTy largTys _varargs) fn args assign_f
+    -- TODO RGS: This is a gross hack. Think of a better way to do this.
+  | L.ValAsm False False "" "=r,0,~{dirflag},~{fpsr},~{flags}" <- fn
+  , [largTy] <- largTys
+  , [arg]    <- args
+  , lretTy == largTy
+  = assign_f =<< transTypedValue arg
+
+  | otherwise
+  = do let err :: String -> a
+           err = \msg -> malformedLLVMModule "Invalid type in function call" $
+                            [ fromString msg ]
+                            ++
+                            maybe [] ((:[]) . fromString . showInstr) instr
+
+       fnTy'  <- either (err . displayException) return $ liftMemType (L.PtrTo fnTy)
+       retTy' <- either (err . displayException) return $ liftRetType lretTy
+       fn'    <- transValue fnTy' fn
+       args'  <- mapM transTypedValue args
+
+       let ?err = err
+       unpackArgs args' $ \_archProxy argTypes args'' ->
+         llvmRetTypeAsRepr retTy' $ \retTy ->
+           case asScalar fn' of
+             Scalar _ PtrRepr ptr -> do
+               memVar <- getMemVar
+               v   <- extensionStmt (LLVM_LoadHandle memVar fnTy ptr argTypes retTy)
+               ret <- call v args''
+               assign_f (BaseExpr retTy ret)
+             _ -> fail $ unwords ["unsupported function value", show fn]

 callFunction instr _tailCall fnTy _fn _args _assign_f =
   reportError $ App $ StringLit $ UnicodeLiteral $ Text.pack $ unlines $
```

Our struggles don't end there. Next is:

```
[15:19:51.163] Verifying bn_select_words ...
[15:19:51.164] Simulating bn_select_words ...
[15:19:51.167] Checking proof obligations bn_select_words ...
[15:19:51.183] Subgoal failed: bn_select_words safety assertion:
src/crypto/fipsmodule/bn/bn.c:418:3: error: in bn_select_words
Undefined behavior encountered
Details:
  Comparison of pointers from different allocations

[15:19:51.183] SolverStats {solverStatsSolvers = fromList ["W4 ->z3"], solverStatsGoalSize = 25}
[15:19:51.183] ----------Counterexample----------
[15:19:51.183] <<All settings of the symbolic variables constitute a counterexample>>
[15:19:51.183] ----------------------------------
[15:19:51.183] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:38:1-38:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:571:28-571:39):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Proof failed.
```

I believe this is the same issue as https://github.com/GaloisInc/crucible/issues/149. We should probably offer a knob in SAW to tweak this, but until then, what's one more ugly hack among friends? (EDIT: I'm going to upstream this in https://github.com/GaloisInc/saw-script/pull/1309.)

```diff
diff --git a/src/SAWScript/Crucible/LLVM/Builtins.hs b/src/SAWScript/Crucible/LLVM/Builtins.hs
index a2f56ebf..3106e0d0 100644
--- a/src/SAWScript/Crucible/LLVM/Builtins.hs
+++ b/src/SAWScript/Crucible/LLVM/Builtins.hs
@@ -1349,7 +1352,7 @@ setupLLVMCrucibleContext pathSat lm action =

                let bindings = Crucible.fnBindingsFromList []
                let simctx   = Crucible.initSimContext sym intrinsics halloc stdout
-                                 bindings (Crucible.llvmExtensionImpl Crucible.defaultMemOptions)
+                                 bindings (Crucible.llvmExtensionImpl Crucible.defaultMemOptions{Crucible.laxPointerOrdering = True})
                                  Common.SAWCruciblePersonality
                mem <- Crucible.populateConstGlobals sym (Crucible.globalInitMap mtrans)
                         =<< Crucible.initializeMemoryConstGlobals sym ctx llvm_mod
```

Next up is more inline assembly:

```
[16:49:12.060] Verifying bn_reduce_once_in_place ...
[16:49:12.061] Simulating bn_reduce_once_in_place ...
[16:49:12.061] Registering overrides for `bn_select_words`
[16:49:12.062]   variant `Symbol "bn_select_words"`
[16:49:12.062] Registering overrides for `bn_sub_words`
[16:49:12.062]   variant `Symbol "bn_sub_words"`
[16:49:12.064] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:38:1-38:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:612:37-612:48):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/bn/asm/x86_64-gcc.c:225:3: error: in bn_reduce_once_in_place
  unsupported LLVM value: ValAsm True False "\tsubq\t$0,$0\t\t\n\tjmp\t1f\t\t\n.p2align 4\t\t\t\n1:\tmovq\t($4,$2,8),$0\t\n\tsbbq\t($5,$2,8),$0\t\n\tmovq\t$0,($3,$2,8)\t\n\tlea\t1($2),$2\t\n\tdec\t$1\t\t\n\tjnz\t1b\t\t\n\tsbbq\t$0,$0\t\t\n" "=&r,={cx},=r,r,r,r,
1,2,~{cc},~{memory},~{dirflag},~{fpsr},~{flags}" of type { i64, i64, i64 }(i64*, i64*, i64*, i64, i64)*
```

Yeesh. This probably won't be simple to special-case in Crucible, so I will run away from my problems by just marking `bn_sub_words` as `noinline`:

```diff
diff --git a/crypto/fipsmodule/bn/asm/x86_64-gcc.c b/crypto/fipsmodule/bn/asm/x86_64-gcc.c
index 30fff2177..7dbd7055e 100644
--- a/crypto/fipsmodule/bn/asm/x86_64-gcc.c
+++ b/crypto/fipsmodule/bn/asm/x86_64-gcc.c
@@ -213,6 +213,7 @@ BN_ULONG bn_add_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
   return ret & 1;
 }

+__attribute__((noinline))
 BN_ULONG bn_sub_words(BN_ULONG *rp, const BN_ULONG *ap, const BN_ULONG *bp,
                       size_t n) {
   BN_ULONG ret;
```

Which leads to this lovely error:

```
[16:40:33.528] Verifying bn_reduce_once_in_place ...
[16:40:33.528] Simulating bn_reduce_once_in_place ...
[16:40:33.529] Registering overrides for `bn_select_words`
[16:40:33.529]   variant `Symbol "bn_select_words"`
[16:40:33.529] Registering overrides for `bn_sub_words`
[16:40:33.529]   variant `Symbol "bn_sub_words"`
[16:40:33.533] Matching 1 overrides of  bn_sub_words ...
[16:40:33.534] Branching on 1 override variants of bn_sub_words ...
[16:40:33.535] Applied override! bn_sub_words
[16:40:33.539] Checking proof obligations bn_reduce_once_in_place ...
[16:40:33.668] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:38:1-38:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:612:37-612:48):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
"tactic" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:59-66:65):
"w4_unint_z3" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:625:5-625:16):
Prover returned Unknown
```

Yikes. It turns out that the proof becomes much hairier with optimizations enabled, as there are far more vectorized instructions to deal with. Compare the original goal:

```
EqTrue
  (Prelude.or
     (Prelude.or
        (Prelude.or
           (Prelude.or
              (Prelude.or (Prelude.or (intLt x@14 x@12) (intLe x@17 x@14))
                 (intLe x@15 x@12))
              (intLe x@17 x@15))
           (intLe (intMul (natToInt 2) x@15) x@14))
        (Prelude.and (not x@20) (not (bvEq 64 x@16 x@19))))
     (bvEq 384 (integerToBV x@13 (intMod x@14 x@15))
        (ite x@11 x@20
           (integerToBV x@13
              (integerFromBV x@13
                 (integerToBV x@13
                    (intAdd
                       (intAdd x@14 (intMul (intNeg (natToInt 1)) x@15))
                       (ite Integer x@18 x@12 x@17)))))
           (integerToBV x@13 x@14))))
```

To the new goal:

```
EqTrue
  (Prelude.or
     (Prelude.or
        (Prelude.or
           (Prelude.or (Prelude.or (intLt x@12 x@10) (intLe x@14 x@12))
              (intLe x@13 x@10))
           (intLe x@14 x@13))
        (intLe (intMul (natToInt 2) x@13) x@12))
     (bvEq 384 (integerToBV x@11 (intMod x@12 x@13))
        (append 64 320 Bool
           (bvOr 64 (bvAnd 64 x@16 (slice Bool 0 64 320 r))
              (bvXor 64 x@18 (bvAnd 64 x@16 x@18)))
           (append 64 256 Bool
              (bvOr 64 (bvAnd 64 x@16 (slice Bool 64 64 256 r))
                 (bvXor 64 x@19 (bvAnd 64 x@16 x@19)))
              (append 128 128 Bool
                 (append 64 64 Bool
                    (bvOr 64 (bvAnd 64 x@16 (slice Bool 128 64 192 r))
                       (bvXor 64 x@20 (bvAnd 64 x@16 x@20)))
                    (bvOr 64 (bvAnd 64 x@16 (slice Bool 192 64 128 r))
                       (bvXor 64 x@21 (bvAnd 64 x@16 x@21))))
                 (append 64 64 Bool
                    (bvOr 64 (bvAnd 64 x@16 (slice Bool 256 64 64 r))
                       (bvXor 64 x@22 (bvAnd 64 x@16 x@22)))
                    (bvOr 64 (bvAnd 64 x@16 (slice Bool 320 64 0 r))
                       (bvXor 64 x@23 (bvAnd 64 x@16 x@23)))))))))
```

With significant effort, however, this can be shown to be equivalent to the original goal:

```diff
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..90edfc1 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
+let prove_folding_theorem t = prove_print abc (rewrite (cryptol_ss ()) t);
+
+let slice_0_64_320 = parse_core "\\(x : Vec 384 Bool) -> slice Bool 0 64 320 x";
+let slice_64_64_256 = parse_core "\\(x : Vec 384 Bool) -> slice Bool 64 64 256 x";
+let slice_128_64_192 = parse_core "\\(x : Vec 384 Bool) -> slice Bool 128 64 192 x";
+let slice_192_64_128 = parse_core "\\(x : Vec 384 Bool) -> slice Bool 192 64 128 x";
+let slice_256_64_64 = parse_core "\\(x : Vec 384 Bool) -> slice Bool 256 64 64 x";
+let slice_320_64_0 = parse_core "\\(x : Vec 384 Bool) -> slice Bool 320 64 0 x";
+
+append_or_thm <- prove_folding_theorem
+  {{ \(x0 : [64]) (x1 : [64]) (x2 : [64]) (x3 : [64]) (x4 : [64]) (x5 : [64]) y0 y1 y2 y3 y4 y5 -> (x0 || y0) # ((x1 || y1) # (((x2 || y2) # (x3 || y3)) # (((x4 || y4) # (x5 || y5))))) == (x0 # x1 # x2 # x3 # x4 # x5) || (y0 # y1 # y2 # y3 # y4 # y5) }};
+append_and_thm <- prove_folding_theorem
+  {{ \(x0 : [64]) (x1 : [64]) (x2 : [64]) (x3 : [64]) (x4 : [64]) (x5 : [64]) y0 y1 y2 y3 y4 y5 -> (x0 && y0) # ((x1 && y1) # ((x2 && y2) # ((x3 && y3) # ((x4 && y4) # (x5 && y5))))) == (x0 # x1 # x2 # x3 # x4 # x5) && (y0 # y1 # y2 # y3 # y4 # y5) }};
+append_xor_thm <- prove_folding_theorem
+  {{ \(x0 : [64]) (x1 : [64]) (x2 : [64]) (x3 : [64]) (x4 : [64]) (x5 : [64]) y0 y1 y2 y3 y4 y5 -> (x0 ^ y0) # ((x1 ^ y1) # ((x2 ^ y2) # ((x3 ^ y3) # ((x4 ^ y4) # (x5 ^ y5))))) == (x0 # x1 # x2 # x3 # x4 # x5) ^ (y0 # y1 # y2 # y3 # y4 # y5) }};
+append_slice_thm <- prove_folding_theorem
+  {{ \x -> (slice_0_64_320 x) # (slice_64_64_256 x) # (slice_128_64_192 x) # (slice_192_64_128 x) # (slice_256_64_64 x) # (slice_320_64_0 x) == x }};
+mul_if_thm <- prove_folding_theorem
+  {{ \(n : [64]) (b : Bit) -> (n * (if b then 0 else 1)) == if b then 0 else n }};
+append_if_thm <- prove_folding_theorem
+  {{ \(x0 : [64]) (x1 : [64]) (x2 : [64]) (x3 : [64]) (x4 : [64]) (x5 : [64]) y0 y1 y2 y3 y4 y5 (b : Bit) -> (if b then x0 else y0) # ((if b then x1 else y1) # ((if b then x2 else y2) # ((if b then x3 else y3) # ((if b then x4 else y4) # (if b then x5 else y5))))) == if b then (x0 # x1 # x2 # x3 # x4 # x5) else (y0 # y1 # y2 # y3 # y4 # y5) }};
+and_if_zero_thm <- prove_folding_theorem
+  {{ \(x : [64]) (y : [64]) (b : Bit) -> (if b then 0 else x) && y == if b then 0 else (x && y) }};
+xor_if_zero_thm <- prove_folding_theorem
+  {{ \(x : [64]) (y : [64]) (b : Bit) -> x ^ (if b then 0 else y) == if b then x else (x ^ y) }};
+or_if_thm <- prove_folding_theorem
+  {{ \(x0 : [384]) (x1 : [384]) y0 y1 (b : Bit) -> (if b then x0 else y0) || (if b then x1 else y1) == if b then (x0 || x1) else (y0 || y1) }};
+or_zero_0_thm <- prove_folding_theorem
+  {{ \(x : [384]) -> 0 || x == x }};
+or_zero_1_thm <- prove_folding_theorem
+  {{ \(x : [384]) -> x || 0 == x }};
+and_ones_thm <- prove_folding_theorem
+  {{ \(x : [384]) -> ~0 && x == x }};
+xor_cancel_thm <- prove_folding_theorem
+  {{ \(x : [384]) -> x ^ x == 0 }};
+coup_de_grace_0_thm <- prove_print
+  (do {
+    w4_unint_z3 [];
+  })
+  (rewrite (cryptol_ss ()) {{ \(x : Integer) (y : [384]) (b : Bit) -> (if b then integerToBV`{384} x else y) == (if b then integerToBV`{384} x else integerToBV (integerFromBV y)) }});
+coup_de_grace_1_thm <- prove_print
+  (do {
+    w4_unint_z3 ["integerToBV"];
+  })
+  (rewrite (cryptol_ss ()) {{ \(x : Integer) (y : [384]) (b : Bit) -> (if b then integerToBV`{384} x else integerToBV (integerFromBV y)) == integerToBV`{384} (if b then x else integerFromBV y) }});
+
+let append_thms =
+  [ append_or_thm
+  , append_and_thm
+  , append_xor_thm
+  , append_slice_thm
+  , mul_if_thm
+  , append_if_thm
+  , and_if_zero_thm
+  , xor_if_zero_thm
+  , or_if_thm
+  , or_zero_0_thm
+  , and_ones_thm
+  , xor_cancel_thm
+  , or_zero_1_thm
+  ];
+
+let coup_de_grace_thms =
+  [ coup_de_grace_0_thm
+  , coup_de_grace_1_thm
+  ];
+
 bn_reduce_once_in_place_true_ov <- crucible_llvm_unsafe_assume_spec
   m
   "bn_reduce_once_in_place"
@@ -622,6 +689,11 @@ bn_reduce_once_in_place_false_ov <- llvm_verify
     goal_eval_unint ["integerToBV", "integerFromBV"];
     simplify (addsimp integerBV_thm empty_ss);
     simplify (addsimp ite_integerToBV_thm empty_ss);
+
+    // These two are only needed when optimization is enabled
+    simplify (addsimps append_thms empty_ss);
+    simplify (addsimps coup_de_grace_thms empty_ss);
+
     w4_unint_z3 ["integerToBV", "integerFromBV"];
   });

```

I feel like there has to be an easier way, but oh well. TODO RGS: The name "`b`" is shadowing. Change it to "`cond`" above.

Next problem:

```
[01:48:33.634] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:38:1-38:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:707:1-707:12):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Could not find definition for function named `ec_group_new_from_data`.
Run SAW with --sim-verbose=3 to see all function names
```

Surprise surprise, `ec_group_new_from_data` got inlined away in the definition of `EC_GROUP_new_by_curve_name`. It doesn't look like we use the resulting override anywhere, so let's just comment it out:

```diff
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..8ed42fc 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
@@ -632,26 +704,26 @@ BN_div_ov <- crucible_llvm_unsafe_assume_spec
   (BN_div_spec (eval_size {| 2 * ec_words + 1 |}) ec_words);


-llvm_verify m "ec_group_new_from_data"
-  [ OPENSSL_malloc_ov
-  , OPENSSL_free_nonnull_bignum_st_ov
-  , OPENSSL_free_nonnull_ec_bytes_ov
-  , OPENSSL_free_null_ov
-  , OPENSSL_cleanse_ov
-  , CRYPTO_refcount_inc_ov
-  , CRYPTO_refcount_dec_and_test_zero_ov
-  , BN_div_ov
-  , BN_value_one_ov
-  , bn_add_words_ov
-  , bn_add_words_same_res_left_ov
-  , bn_sub_words_ov
-  , bn_mul_mont_p_ov
-  , bn_mul_mont_same_res_left_p_ov
-  , value_barrier_w_ov
-  ]
-  true
-  ec_group_new_from_data_spec
-  (w4_unint_yices []);
+// llvm_verify m "ec_group_new_from_data"
+//   [ OPENSSL_malloc_ov
+//   , OPENSSL_free_nonnull_bignum_st_ov
+//   , OPENSSL_free_nonnull_ec_bytes_ov
+//   , OPENSSL_free_null_ov
+//   , OPENSSL_cleanse_ov
+//   , CRYPTO_refcount_inc_ov
+//   , CRYPTO_refcount_dec_and_test_zero_ov
+//   , BN_div_ov
+//   , BN_value_one_ov
+//   , bn_add_words_ov
+//   , bn_add_words_same_res_left_ov
+//   , bn_sub_words_ov
+//   , bn_mul_mont_p_ov
+//   , bn_mul_mont_same_res_left_p_ov
+//   // , value_barrier_w_ov
+//   ]
+//   true
+//   ec_group_new_from_data_spec
+//   (w4_unint_yices []);

 EC_GROUP_new_by_curve_name_ov <- crucible_llvm_unsafe_assume_spec
   m
```

Next up:

```
[01:59:26.132] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:185:24-185:35):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Could not find definition for function named `digest_to_scalar`.
```

This time, `digest_to_scalar_ov` is used in other places. What happens if we comment them out?

```diff
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..f787696 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -182,16 +182,16 @@ BN_num_bits_ec_bits_ov <- llvm_verify m "BN_num_bits"
   (w4_unint_yices []);


-digest_to_scalar_ov <- llvm_verify m "digest_to_scalar"
-  [ bn_reduce_once_in_place_false_ov
-  ]
-  true
-  digest_to_scalar_spec
-  (do {
-    goal_eval_unint [];
-    simplify (addsimp append_assoc_thm empty_ss);
-    w4_unint_z3 [];
-  });
+// digest_to_scalar_ov <- llvm_verify m "digest_to_scalar"
+//   [ bn_reduce_once_in_place_false_ov
+//   ]
+//   true
+//   digest_to_scalar_spec
+//   (do {
+//     goal_eval_unint [];
+//     simplify (addsimp append_assoc_thm empty_ss);
+//     w4_unint_z3 [];
+//   });


 // assume (without proving) the equivalence of point operations in affine and
@@ -226,7 +226,7 @@ ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
   , ec_point_mul_scalar_public_ov
   , ec_cmp_x_coordinate_ov
   , ec_get_x_coordinate_as_scalar_ov
-  , digest_to_scalar_ov
+  // , digest_to_scalar_ov
   , ec_scalar_is_zero_false_ov
   , BN_is_zero_false_ov
   , OPENSSL_malloc_ov
@@ -264,7 +264,7 @@ ECDSA_do_verify_ov <- llvm_verify m "ECDSA_do_verify"
   , ec_point_mul_scalar_public_ov
   , ec_cmp_x_coordinate_ov
   , ec_get_x_coordinate_as_scalar_ov
-  , digest_to_scalar_ov
+  // , digest_to_scalar_ov
   , ERR_put_error_ov
   ]
   true
```

This leads to:

```
[02:06:36.274] Verifying ECDSA_do_sign ...
[02:06:36.291] Simulating ECDSA_do_sign ...
[02:06:36.291] Registering overrides for `BN_is_zero`
[02:06:36.291]   variant `Symbol "BN_is_zero"`
[02:06:36.291] Registering overrides for `OPENSSL_cleanse`
[02:06:36.291]   variant `Symbol "OPENSSL_cleanse"`
[02:06:36.291] Registering overrides for `OPENSSL_malloc`
[02:06:36.291]   variant `Symbol "OPENSSL_malloc"`
[02:06:36.291] Registering overrides for `ec_bignum_to_scalar`
[02:06:36.291]   variant `Symbol "ec_bignum_to_scalar"`
[02:06:36.291] Registering overrides for `ec_cmp_x_coordinate`
[02:06:36.292]   variant `Symbol "ec_cmp_x_coordinate"`
[02:06:36.292] Registering overrides for `ec_get_x_coordinate_as_scalar`
[02:06:36.292]   variant `Symbol "ec_get_x_coordinate_as_scalar"`
[02:06:36.292] Registering overrides for `ec_point_mul_scalar_base`
[02:06:36.292]   variant `Symbol "ec_point_mul_scalar_base"`
[02:06:36.292] Registering overrides for `ec_point_mul_scalar_public`
[02:06:36.292]   variant `Symbol "ec_point_mul_scalar_public"`
[02:06:36.292] Registering overrides for `ec_random_nonzero_scalar`
[02:06:36.292]   variant `Symbol "ec_random_nonzero_scalar"`
[02:06:36.292] Registering overrides for `ec_scalar_add`
[02:06:36.292]   variant `Symbol "ec_scalar_add"`
[02:06:36.292] Registering overrides for `ec_scalar_from_montgomery`
[02:06:36.292]   variant `Symbol "ec_scalar_from_montgomery"`
[02:06:36.292] Registering overrides for `ec_scalar_is_zero`
[02:06:36.292]   variant `Symbol "ec_scalar_is_zero"`
[02:06:36.292] Registering overrides for `ec_scalar_mul_montgomery`
[02:06:36.292]   variant `Symbol "ec_scalar_mul_montgomery"`
[02:06:36.292] Registering overrides for `ec_scalar_to_montgomery`
[02:06:36.293]   variant `Symbol "ec_scalar_to_montgomery"`
[02:06:36.293] Registering overrides for `ec_simple_scalar_inv0_montgomery`
[02:06:36.293]   variant `Symbol "ec_simple_scalar_inv0_montgomery"`
[02:06:36.293] Registering overrides for `sha512_block_data_order`
[02:06:36.293]   variant `Symbol "sha512_block_data_order"`
[02:06:36.302] Matching 1 overrides of  sha512_block_data_order ...
[02:06:36.305] Branching on 1 override variants of sha512_block_data_order ...
[02:06:36.306] Applied override! sha512_block_data_order
[02:06:36.309] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:211:21-211:32):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/rand/fork_detect.c:91:3: error: in RAND_bytes_with_additional_data
  Global symbol not allocated
  Details:
    Global symbol "g_fork_detect_once" has no associated allocation
```

This happens due to `RAND_bytes_with_additional_data` being inlined in the definition of `bn_rand_range_words`, which `ECDSA_do_sign` transitively invokes by way of `ec_random_nonzero_scalar`. In turn, `RAND_bytes_with_additional_data` invokes `CRYPTO_once` with the global `g_fork_detect_once` as an argument.

Since `ec_random_nonzero_scalar` has an unsafe override, I'm going to the same thing with `bn_rand_range_words`:

```diff
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..0c7590b 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
@@ -279,6 +279,25 @@ let BN_is_zero_false_spec = do {
   crucible_return (crucible_term {{ 0 : [32] }});
 };

+bn_rand_range_words_out <- llvm_declare_ghost_state "bn_rand_range_words_out";
+let bn_rand_range_words_spec num = do {
+  out <- llvm_fresh_cryptol_var "out" {| Integer |};
+  llvm_ghost_value bn_rand_range_words_out out;
+
+  let num_bits = eval_size {| num * 64 |};
+  out_ptr <- llvm_alloc (llvm_int num_bits);
+  min_inclusive <- llvm_fresh_var "min_inclusive" i64;
+  (max_exclusive, max_exclusive_ptr) <- ptr_to_fresh_readonly "max_exclusive" (llvm_int num_bits);
+  additional_data <- llvm_alloc_readonly (llvm_array 32 i8);
+
+  llvm_execute_func [out_ptr, llvm_term min_inclusive, max_exclusive_ptr,
+                     llvm_term {{ `num: [64] }}, additional_data];
+
+  llvm_points_to out_ptr (llvm_term {{ integerToBV`{num_bits} out }});
+  llvm_postcond {{ (integerFromBV`{64} min_inclusive <= out) && (out < integerFromBV`{num_bits} max_exclusive) }};
+  llvm_return (llvm_term {{ 1 : [32] }});
+};
+
 let ec_scalar_is_zero_spec = do {
   group_ptr <- pointer_to_fresh_ec_group_st;
   (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..94bc037 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -99,6 +99,7 @@ let nondeterministic_valid_k priv_key digest = do {
   crucible_precond {{ is_num_bits_bn`{r_bits} (scalarToBV sig.r) }};
   crucible_precond {{ is_num_bits_bn`{s_bits} (scalarToBV sig.s) }};
   crucible_ghost_value ec_random_nonzero_scalar_out k;
+  crucible_ghost_value bn_rand_range_words_out      k;
   return k;
 };
@@ -670,11 +761,15 @@ BN_is_zero_ov <- llvm_verify
   ]
   true
   BN_is_zero_false_spec
   (w4_unint_z3 []);
+bn_rand_range_words_ov <- llvm_unsafe_assume_spec
+  m
+  "bn_rand_range_words"
+  (bn_rand_range_words_spec ec_words);

 ec_scalar_is_zero_ov <- llvm_verify
   m
@@ -226,11 +227,12 @@ ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
   , ec_scalar_is_zero_false_ov
   , BN_is_zero_false_ov
   , OPENSSL_malloc_ov
   , OPENSSL_cleanse_ov
+  , bn_rand_range_words_ov
   ]
   true
   ECDSA_do_sign_spec
```

Next up is:

```
[20:36:43.511] Verifying ECDSA_do_sign ...
[20:36:43.539] Simulating ECDSA_do_sign ...
<elided>
[20:36:43.557] Matching 1 overrides of  bn_rand_range_words ...
[20:36:43.558] Branching on 1 override variants of bn_rand_range_words ...
[20:36:43.558] Applied override! bn_rand_range_words
[20:36:43.568] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:212:21-212:32):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/bn/montgomery.c:482:10: error: in bn_mod_mul_montgomery_small
  Failed to load function handle
  Details:
    No implementation or override found for pointer: "bn_mul_mont"
```

`bn_mul_mont` is an x86 function with an unsafe override that is used any time there is a (transitive) call site. Due to inlining, `ecdsa_sign_impl` now transitively invokes `bn_mul_mont` by way of `bn_mod_mul_montgomery_small`. `ECDSA_do_sign`, in turns, invokes `ecdsa_sign_impl`.

I'm choosing to fix this by adding overrides for `bn_mod_mul_montgomery_small` by cargo-culting the existing overrides for `ec_scalar_mul_montgomery`, which is a very similar function:

```diff
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..b9445fc 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
@@ -402,6 +421,40 @@ let ec_scalar_mul_montgomery_same_l_spec = do {
   crucible_points_to a_ptr (crucible_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
 };

+let bn_mod_mul_montgomery_small_spec = do {
+  r_ptr <- llvm_alloc i384;
+  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
+  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
+  let width = llvm_term {{ `ec_words : [64] }};
+  order_mont_ptr <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};
+
+  llvm_execute_func [r_ptr, a_ptr, b_ptr, width, order_mont_ptr];
+
+  llvm_points_to r_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
+};
+
+let bn_mod_mul_montgomery_small_same_r_spec = do {
+  (a, a_ptr) <- ptr_to_fresh_readonly "a" i384;
+  (b, b_ptr) <- ptr_to_fresh "b" i384;
+  let width = llvm_term {{ `ec_words : [64] }};
+  order_mont_ptr <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};
+
+  llvm_execute_func [b_ptr, a_ptr, b_ptr, width, order_mont_ptr];
+
+  llvm_points_to b_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
+};
+
+let bn_mod_mul_montgomery_small_same_l_spec = do {
+  (a, a_ptr) <- ptr_to_fresh "a" i384;
+  (b, b_ptr) <- ptr_to_fresh_readonly "b" i384;
+  let width = llvm_term {{ `ec_words : [64] }};
+  order_mont_ptr <- pointer_to_bn_mont_ctx_st ec_words {| P384_n |};
+
+  llvm_execute_func [a_ptr, a_ptr, b_ptr, width, order_mont_ptr];
+
+  llvm_points_to a_ptr (llvm_term {{ scalarToBV (((scalarFromBV a) * (scalarFromBV b) * P384_R_n_inv) % `P384_n) }});
+};
+
 let ec_simple_scalar_inv0_montgomery_spec = do {
   group_ptr <- pointer_to_fresh_ec_group_st;
   r_ptr <- crucible_alloc i384;
@@ -774,6 +914,39 @@ ec_scalar_mul_montgomery_same_l_ov <- llvm_verify
     w4_unint_z3 [];
   });

+bn_mod_mul_montgomery_small_ov <- llvm_verify
+  m
+  "bn_mod_mul_montgomery_small"
+  [bn_mul_mont_n_ov]
+  true
+  bn_mod_mul_montgomery_small_spec
+  (do {
+    goal_eval_unint [];
+    w4_unint_z3 [];
+  });
+
+bn_mod_mul_montgomery_small_same_r_ov <- llvm_verify
+  m
+  "bn_mod_mul_montgomery_small"
+  [bn_mul_mont_same_res_right_n_ov]
+  true
+  bn_mod_mul_montgomery_small_same_r_spec
+  (do {
+    goal_eval_unint [];
+    w4_unint_z3 [];
+  });
+
+bn_mod_mul_montgomery_small_same_l_ov <- llvm_verify
+  m
+  "bn_mod_mul_montgomery_small"
+  [bn_mul_mont_same_res_left_n_ov]
+  true
+  bn_mod_mul_montgomery_small_same_l_spec
+  (do {
+    goal_eval_unint [];
+    w4_unint_z3 [];
+  });
+
 ec_simple_scalar_inv0_montgomery_ov <- crucible_llvm_unsafe_assume_spec
   m
   "ec_simple_scalar_inv0_montgomery"
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..d1fa91e 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -226,11 +227,19 @@ ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
+  , bn_mod_mul_montgomery_small_ov
+  , bn_mod_mul_montgomery_small_same_l_ov
+  , bn_mod_mul_montgomery_small_same_r_ov
   ]
   true
   ECDSA_do_sign_spec
```

Next up:

```
[21:19:26.982] Verifying ECDSA_do_sign ...
[21:19:27.000] Simulating ECDSA_do_sign ...
<elided>
[21:19:27.037] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:212:21-212:32):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/bn/asm/x86_64-gcc.c:197:3: error: in ec_GFp_mont_dbl
  unsupported LLVM value: ValAsm True False "\tsubq\t$0,$0\t\t\n\tjmp\t1f\t\t\n.p2align 4\t\t\t\n1:\tmovq\t($4,$2,8),$0\t\n\tadcq\t($5,$2,8),$0\t\n\tmovq\t$0,($3,$2,8)\t\n\tlea\t1($2),$2\t\n\tdec\t$1\t\t\n\tjnz\t1b\t\t\n\tsbbq\t$0,$0\t\t\n" "=&r,={cx},=r,r,r,r,1,2,~{cc},~{memory},~{dirflag},~{fpsr},~{flags}" of type { i64, i64, i64 }(i64*, i64*, i64*, i64, i64)*
```

In the unoptimized code, `ecdsa_sign_impl` calls `ec_point_mul_scalar_base`, which eventually calls `ec_GFp_mont_dbl` by way of function pointer shenanigans (see the `group->meth->mul_base(group, r, scalar)` line in `ec_point_mul_scalar_base`, which in this case, invokes `ec_GFp_mont_mul_base`). `ec_point_mul_scalar_base` has an unsafe override, so that's as far as we get in the unoptimized version. In the optimized version, the function pointer shenanigans—i.e., `ec_GFp_mont_mul_base`—are inlined into `ecdsa_sign_impl`. `ec_GFp_mont_mul_base`, in turn, invokes `ec_GFp_mont_mul` and then `ec_GFp_mont_dbl`.

As far as I can tell, `ec_point_mul_scalar_base` is a thin wrapper around `ec_GFp_mont_mul_base` anyway, so I'm going to cargo-cult the unsafe override for `ec_point_mul_scalar_base` and re-use it for `ec_GFp_mont_mul_base`: (TODO RGS: Factor out the common bits between these specs)

```diff
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..8ab113a 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
@@ -457,6 +476,17 @@ let ec_point_mul_scalar_base_spec = do {
   crucible_return (crucible_term {{ 1 : [32] }});
 };

+let ec_GFp_mont_mul_base_spec = do {
+  group_ptr <- pointer_to_fresh_ec_group_st;
+  r_ptr <- crucible_alloc (llvm_struct "struct.EC_RAW_POINT");
+  (scalar, scalar_ptr) <- ptr_to_fresh_readonly "scalar" i384;
+  crucible_precond {{ (scalarFromBV scalar) % `P384_n == scalarFromBV scalar }};
+
+  crucible_execute_func [group_ptr, r_ptr, scalar_ptr];
+
+  points_to_EC_RAW_POINT r_ptr {{ jacobianToMontBV (ec_point_jacobian_scalar_mul (scalarFromBV scalar) P384_G_Jacobian) }};
+};
+
 let ec_point_mul_scalar_public_spec = do {
   group_ptr <- pointer_to_fresh_ec_group_st;
   r_ptr <- crucible_alloc (llvm_struct "struct.EC_RAW_POINT");
@@ -795,6 +901,11 @@ ec_point_mul_scalar_base_ov <- crucible_llvm_unsafe_assume_spec
   "ec_point_mul_scalar_base"
   ec_point_mul_scalar_base_spec;

+ec_GFp_mont_mul_base_ov <- llvm_unsafe_assume_spec
+  m
+  "ec_GFp_mont_mul_base"
+  ec_GFp_mont_mul_base_spec;
+
 ec_point_mul_scalar_public_ov <- crucible_llvm_unsafe_assume_spec
   m
   "ec_point_mul_scalar_public"
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..612bb93 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -226,11 +227,15 @@ ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
+  , ec_GFp_mont_mul_base_ov
   ]
   true
   ECDSA_do_sign_spec
```

Next up is:

```
[16:23:04.911] Verifying ECDSA_do_sign ...
[16:23:04.943] Simulating ECDSA_do_sign ...
<elided>
[16:23:05.047] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:212:21-212:32):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Both branches aborted after a symbolic branch.
Location of control-flow branching:
  /home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:904:28
Message from the true branch:
  Abort due to false assumption:
    src/crypto/fipsmodule/bn/asm/x86_64-gcc.c:197:3: error: in ec_GFp_simple_is_on_curve
    unsupported LLVM value: ValAsm True False "\tsubq\t$0,$0\t\t\n\tjmp\t1f\t\t\n.p2align 4\t\t\t\n1:\tmovq\t($4,$2,8),$0\t\n\tadcq\t($5,$2,8),$0\t\n\tmovq\t$0,($3,$2,8)\t\n\tlea\t1($2),$2\t\n\tdec\t$1\t\t\n\tjnz\t1b\t\t\n\tsbbq\t$0,$0\t\t\n" "=&r,={cx},=r,r,r,r,1,2,~{cc},~{memory},~{dirflag},~{fpsr},~{flags}" of type { i64, i64, i64 }(i64*, i64*, i64*, i64, i64)*
```

This is due to `ec_GFp_simple_is_on_curve`, which `ec_point_mul_scalar_base` invokes, being inlined in `ecdsa_do_sign`. I don't know how to write a specification for this function. Thankfully, this appears to mostly be used for error-checking, and if it returns 0, the program errors out. As a result, I'm going to use an unsafe override which always returns 1: (TODO RGS: Fix this)

```
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..02aac4b 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
+let ec_GFp_simple_is_on_curve_spec = do {
+  group_ptr <- pointer_to_fresh_ec_group_st;
+  point_ptr <- crucible_alloc_readonly (llvm_struct "struct.EC_RAW_POINT");
+  _point <- points_to_fresh_EC_RAW_POINT point_ptr;
+
+  llvm_execute_func [group_ptr, point_ptr];
+
+  llvm_return (llvm_term {{ 1 : [32] }});
+};
+
+ec_GFp_simple_is_on_curve_ov <- llvm_unsafe_assume_spec
+  m
+  "ec_GFp_simple_is_on_curve"
+  ec_GFp_simple_is_on_curve_spec;
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..475d396 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -226,11 +227,16 @@ ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
+  , ec_GFp_simple_is_on_curve_ov
   ]
   true
   ECDSA_do_sign_spec
```

Once that is done, the proof seems to go into an infinite loop:

```
[17:47:10.197] Verifying ECDSA_do_sign ...
[17:47:10.238] Simulating ECDSA_do_sign ...
<elided>
[15:00:13.113] Matching 1 overrides of  bn_rand_range_words ...
[15:00:13.114] Branching on 1 override variants of bn_rand_range_words ...
[15:00:13.114] Applied override! bn_rand_range_words
[15:00:13.118] Matching 1 overrides of  ec_GFp_mont_mul_base ...
[15:00:13.153] Branching on 1 override variants of ec_GFp_mont_mul_base ...
[15:00:13.170] Applied override! ec_GFp_mont_mul_base
[15:00:13.170] Matching 1 overrides of  ec_GFp_simple_is_on_curve ...
[15:00:13.203] Branching on 1 override variants of ec_GFp_simple_is_on_curve ...
[15:00:13.203] Applied override! ec_GFp_simple_is_on_curve
[15:00:13.203] Matching 1 overrides of  ec_get_x_coordinate_as_scalar ...
[15:00:13.236] Branching on 1 override variants of ec_get_x_coordinate_as_scalar ...
[15:00:13.236] Applied override! ec_get_x_coordinate_as_scalar
[15:00:13.240] Matching 3 overrides of  bn_mod_mul_montgomery_small ...
[15:00:13.256] Branching on 1 override variants of bn_mod_mul_montgomery_small ...
[15:00:13.256] Applied override! bn_mod_mul_montgomery_small
[15:00:13.256] Matching 3 overrides of  bn_mod_mul_montgomery_small ...
[15:00:13.272] Branching on 1 override variants of bn_mod_mul_montgomery_small ...
[15:00:13.272] Applied override! bn_mod_mul_montgomery_small

[15:00:13.278] Matching 1 overrides of  bn_rand_range_words ...
[15:00:13.279] Branching on 1 override variants of bn_rand_range_words ...
[15:00:13.279] Applied override! bn_rand_range_words
[15:00:13.280] Matching 1 overrides of  ec_GFp_mont_mul_base ...
[15:00:13.311] Branching on 1 override variants of ec_GFp_mont_mul_base ...
[15:00:13.317] Applied override! ec_GFp_mont_mul_base
[15:00:13.317] Matching 1 overrides of  ec_GFp_simple_is_on_curve ...
[15:00:13.350] Branching on 1 override variants of ec_GFp_simple_is_on_curve ...
[15:00:13.350] Applied override! ec_GFp_simple_is_on_curve
[15:00:13.350] Matching 1 overrides of  ec_get_x_coordinate_as_scalar ...
[15:00:13.384] Branching on 1 override variants of ec_get_x_coordinate_as_scalar ...
[15:00:13.384] Applied override! ec_get_x_coordinate_as_scalar

[15:00:13.386] Matching 1 overrides of  bn_rand_range_words ...
[15:00:13.387] Branching on 1 override variants of bn_rand_range_words ...
[15:00:13.387] Applied override! bn_rand_range_words
[15:00:13.388] Matching 1 overrides of  ec_GFp_mont_mul_base ...
[15:00:13.418] Branching on 1 override variants of ec_GFp_mont_mul_base ...
[15:00:13.425] Applied override! ec_GFp_mont_mul_base
[15:00:13.425] Matching 1 overrides of  ec_GFp_simple_is_on_curve ...
[15:00:13.456] Branching on 1 override variants of ec_GFp_simple_is_on_curve ...
[15:00:13.457] Applied override! ec_GFp_simple_is_on_curve
[15:00:13.457] Matching 1 overrides of  ec_get_x_coordinate_as_scalar ...
[15:00:13.491] Branching on 1 override variants of ec_get_x_coordinate_as_scalar ...
[15:00:13.491] Applied override! ec_get_x_coordinate_as_scalar

<repeat ad infinitum>
```

Hm. I'm not sure what to do about this. Let's try something besides ECDSA for a while. How about ECDH? This is what I get:

```
[15:23:28.020] Verifying EVP_PKEY_keygen ...
[15:23:28.035] Simulating EVP_PKEY_keygen ...
[15:23:28.035] Registering overrides for `OPENSSL_malloc`
[15:23:28.035]   variant `Symbol "OPENSSL_malloc"`
[15:23:28.035] Registering overrides for `ec_point_mul_scalar_base`
[15:23:28.036]   variant `Symbol "ec_point_mul_scalar_base"`
[15:23:28.036] Registering overrides for `ec_random_nonzero_scalar`
[15:23:28.036]   variant `Symbol "ec_random_nonzero_scalar"`
[15:23:28.039] Matching 1 overrides of  OPENSSL_malloc ...
[15:23:28.040] Branching on 1 override variants of OPENSSL_malloc ...
[15:23:28.040] Applied override! OPENSSL_malloc
[15:23:28.041] Matching 1 overrides of  OPENSSL_malloc ...
[15:23:28.042] Branching on 1 override variants of OPENSSL_malloc ...
[15:23:28.042] Applied override! OPENSSL_malloc
[15:23:28.045] Matching 1 overrides of  OPENSSL_malloc ...
[15:23:28.045] Branching on 1 override variants of OPENSSL_malloc ...
[15:23:28.046] Applied override! OPENSSL_malloc
[15:23:28.046] Matching 1 overrides of  OPENSSL_malloc ...
[15:23:28.047] Branching on 1 override variants of OPENSSL_malloc ...
[15:23:28.047] Applied override! OPENSSL_malloc
[15:23:28.050] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDH/verify-ECDH.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDH/ECDH.saw:101:1-101:12):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/rand/fork_detect.c:91:3: error: in RAND_bytes_with_additional_data
  Global symbol not allocated
  Details:
    Global symbol "g_fork_detect_once" has no associated allocation
```

That sounds familiar! I'll fix it in much the same way as I did before:

```
diff --git a/SAW/proof/ECDH/ECDH.saw b/SAW/proof/ECDH/ECDH.saw
index 27a3755..e682fa8 100644
--- a/SAW/proof/ECDH/ECDH.saw
+++ b/SAW/proof/ECDH/ECDH.saw
@@ -102,6 +102,7 @@ llvm_verify m "EVP_PKEY_keygen"
   [ ec_random_nonzero_scalar_ov
   , ec_point_mul_scalar_base_ov
   , OPENSSL_malloc_ov
+  , bn_rand_range_words_ov
   ]
   true
   EVP_PKEY_keygen_spec
diff --git a/SAW/proof/ECDH/evp-function-specs.saw b/SAW/proof/ECDH/evp-function-specs.saw
index 3566d1f..31c9eac 100644
--- a/SAW/proof/ECDH/evp-function-specs.saw
+++ b/SAW/proof/ECDH/evp-function-specs.saw
@@ -83,6 +83,7 @@ let EVP_PKEY_paramgen_spec = do {
 let EVP_PKEY_keygen_spec = do {
   d <- crucible_fresh_cryptol_var "d" {| Integer |};
   crucible_ghost_value ec_random_nonzero_scalar_out d;
+  crucible_ghost_value bn_rand_range_words_out      d;

   ctx_ptr <- crucible_alloc_readonly (llvm_struct "struct.evp_pkey_ctx_st");
   points_to_evp_pkey_ctx_st_common ctx_ptr;
```

Next up is:

```
[15:41:58.609] Verifying EVP_PKEY_keygen ...
[15:41:58.623] Simulating EVP_PKEY_keygen ...
<elided>
[15:42:00.120] Matching 1 overrides of  bn_rand_range_words ...
[15:42:00.121] Branching on 1 override variants of bn_rand_range_words ...
[15:42:00.122] Applied override! bn_rand_range_words
[15:42:00.126] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDH/verify-ECDH.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDH/ECDH.saw:101:1-101:12):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/fipsmodule/bn/montgomery.c:482:10: error: in bn_mod_mul_montgomery_small
  Failed to load function handle
  Details:
    No implementation or override found for pointer: "bn_mul_mont"
```

I believe this happens due to things being inlined from the definition of `ec_point_mul_scalar_base`. Let's add an override for `ec_GFp_mont_mul_base` to see if that fixes it:

```
diff --git a/SAW/proof/ECDH/ECDH.saw b/SAW/proof/ECDH/ECDH.saw
index 27a3755..c8c67e2 100644
--- a/SAW/proof/ECDH/ECDH.saw
+++ b/SAW/proof/ECDH/ECDH.saw
@@ -102,6 +102,8 @@ llvm_verify m "EVP_PKEY_keygen"
+  , ec_GFp_mont_mul_base_ov
   ]
   true
   EVP_PKEY_keygen_spec
```

Next is:

```
[15:53:18.050] Verifying EVP_PKEY_keygen ...
[15:53:18.068] Simulating EVP_PKEY_keygen ...
<elided>
[15:53:19.554] Matching 1 overrides of  ec_GFp_mont_mul_base ...
[15:53:19.587] Branching on 1 override variants of ec_GFp_mont_mul_base ...
[15:53:19.602] Applied override! ec_GFp_mont_mul_base
[15:53:19.605] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDH/verify-ECDH.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDH/ECDH.saw:101:1-101:12):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Both branches aborted after a symbolic branch.
Location of control-flow branching:
  /home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/EC/EC.saw:971:28
Message from the true branch:
  Abort due to false assumption:
    src/crypto/fipsmodule/bn/montgomery.c:482:10: error: in bn_mod_mul_montgomery_small
    Failed to load function handle
    Details:
      No implementation or override found for pointer: "bn_mul_mont"
```

This ultimately comes from my favorite function, `ec_GFp_simple_is_on_curve`. Uh...

```diff
diff --git a/SAW/proof/ECDH/ECDH.saw b/SAW/proof/ECDH/ECDH.saw
index 27a3755..d95926b 100644
--- a/SAW/proof/ECDH/ECDH.saw
+++ b/SAW/proof/ECDH/ECDH.saw
@@ -102,6 +102,9 @@ llvm_verify m "EVP_PKEY_keygen"
+  , ec_GFp_simple_is_on_curve_ov
   ]
   true
   EVP_PKEY_keygen_spec
```

While that seems to have solved the immediate problem, I'm once again thrown back into a proof that never terminates. This time, it hangs here:

```
[15:57:21.242] Verifying EVP_PKEY_keygen ...
[15:57:21.258] Simulating EVP_PKEY_keygen ...
[15:57:21.259] Registering overrides for `OPENSSL_malloc`
[15:57:21.259]   variant `Symbol "OPENSSL_malloc"`
[15:57:21.259] Registering overrides for `bn_rand_range_words`
[15:57:21.259]   variant `Symbol "bn_rand_range_words"`
[15:57:21.259] Registering overrides for `ec_GFp_mont_mul_base`
[15:57:21.259]   variant `Symbol "ec_GFp_mont_mul_base"`
[15:57:21.259] Registering overrides for `ec_GFp_simple_is_on_curve`
[15:57:21.259]   variant `Symbol "ec_GFp_simple_is_on_curve"`
[15:57:21.259] Registering overrides for `ec_point_mul_scalar_base`
[15:57:21.259]   variant `Symbol "ec_point_mul_scalar_base"`
[15:57:21.259] Registering overrides for `ec_random_nonzero_scalar`
[15:57:21.259]   variant `Symbol "ec_random_nonzero_scalar"`
[15:57:21.262] Matching 1 overrides of  OPENSSL_malloc ...
[15:57:21.263] Branching on 1 override variants of OPENSSL_malloc ...
[15:57:21.263] Applied override! OPENSSL_malloc
[15:57:21.264] Matching 1 overrides of  OPENSSL_malloc ...
[15:57:21.264] Branching on 1 override variants of OPENSSL_malloc ...
[15:57:21.264] Applied override! OPENSSL_malloc
[15:57:21.267] Matching 1 overrides of  OPENSSL_malloc ...
[15:57:21.267] Branching on 1 override variants of OPENSSL_malloc ...
[15:57:21.267] Applied override! OPENSSL_malloc
[15:57:21.268] Matching 1 overrides of  OPENSSL_malloc ...
[15:57:21.268] Branching on 1 override variants of OPENSSL_malloc ...
[15:57:21.268] Applied override! OPENSSL_malloc
[15:57:21.268] Matching 1 overrides of  bn_rand_range_words ...
[15:57:21.269] Branching on 1 override variants of bn_rand_range_words ...
[15:57:21.270] Applied override! bn_rand_range_words
[15:57:21.270] Matching 1 overrides of  ec_GFp_mont_mul_base ...
[15:57:21.308] Branching on 1 override variants of ec_GFp_mont_mul_base ...
[15:57:21.330] Applied override! ec_GFp_mont_mul_base
[15:57:21.330] Matching 1 overrides of  ec_GFp_simple_is_on_curve ...
[15:57:21.369] Branching on 1 override variants of ec_GFp_simple_is_on_curve ...
[15:57:21.369] Applied override! ec_GFp_simple_is_on_curve
[15:57:21.369] Symbolic simulation completed with side conditions.
[15:57:21.403] Checking proof obligations EVP_PKEY_keygen ...
```

...let's skip ECDH for now. On to RSA! Here's the first error:

```
[12:31:10.152] Loading file "/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/BN.saw"
[12:31:10.558] Assume override bn_uadd_consttime
[12:31:10.988] Assume override bn_mul_consttime
[12:31:11.349] Assume override bn_mod_sub_consttime
[12:31:11.374] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/verify-RSA.saw:6:1-6:8):
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:56:1-56:8):
"crucible_llvm_unsafe_assume_spec" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/BN.saw:37:37-37:69):
Could not find definition for function named `bn_from_montgomery_in_place`.
Run SAW with --sim-verbose=3 to see all function names
```

Indeed, `bn_from_montgomery_in_place` was optimized away. Let's remove that override:

```diff
diff --git a/SAW/proof/BN/BN.saw b/SAW/proof/BN/BN.saw
index 41bf07b..bd9bf25 100644
--- a/SAW/proof/BN/BN.saw
+++ b/SAW/proof/BN/BN.saw
@@ -346,23 +346,23 @@ let BN_bn2bin_padded_spec num num_extra = do {
   crucible_return (crucible_term {{ 1 : [32] }});
 };

-let bn_from_montgomery_in_place_spec num = do {
-  let num_bits = eval_size {| num * 64 |};
-  let a_num = eval_size {| 2 * num |};
-  let a_num_bits = eval_size {| a_num * 64 |};
-
-  r_ptr <- crucible_alloc (llvm_int num_bits);
-  (a, a_ptr) <- ptr_to_fresh "a" (llvm_int a_num_bits);
-
-  (N_d, N_d_ptr) <- ptr_to_fresh_readonly "N_d" (llvm_int num_bits);
-  mont_ptr <- pointer_to_bn_mont_ctx_st_with_N_d num N_d_ptr N_d;
-
-  crucible_execute_func [r_ptr, (crucible_term {{ `num : [64] }}), a_ptr, (crucible_term {{ `a_num : [64] }}), mont_ptr];
-
-  crucible_points_to r_ptr (crucible_term {{ integerToBV`{num_bits} (((integerFromBV a) * (integerFromBV (mont_R_inv_with_N N_d))) % (integerModulusFromBV N_d)) }});
-
-  crucible_return (crucible_term {{ 1 : [32] }});
-};
+// let bn_from_montgomery_in_place_spec num = do {
+//   let num_bits = eval_size {| num * 64 |};
+//   let a_num = eval_size {| 2 * num |};
+//   let a_num_bits = eval_size {| a_num * 64 |};
+//
+//   r_ptr <- crucible_alloc (llvm_int num_bits);
+//   (a, a_ptr) <- ptr_to_fresh "a" (llvm_int a_num_bits);
+//
+//   (N_d, N_d_ptr) <- ptr_to_fresh_readonly "N_d" (llvm_int num_bits);
+//   mont_ptr <- pointer_to_bn_mont_ctx_st_with_N_d num N_d_ptr N_d;
+//
+//   crucible_execute_func [r_ptr, (crucible_term {{ `num : [64] }}), a_ptr, (crucible_term {{ `a_num : [64] }}), mont_ptr];
+//
+//   crucible_points_to r_ptr (crucible_term {{ integerToBV`{num_bits} (((integerFromBV a) * (integerFromBV (mont_R_inv_with_N N_d))) % (integerModulusFromBV N_d)) }});
+//
+//   crucible_return (crucible_term {{ 1 : [32] }});
+// };

 let bn_mul_mont_with_N_spec num = do {
   let num_bits = eval_size {| num * 64 |};
diff --git a/SAW/proof/RSA/BN.saw b/SAW/proof/RSA/BN.saw
index 5e7a9c9..2cf5f33 100644
--- a/SAW/proof/RSA/BN.saw
+++ b/SAW/proof/RSA/BN.saw
@@ -34,10 +34,10 @@ bn_mod_sub_consttime_p_ov <- crucible_llvm_unsafe_assume_spec
   "bn_mod_sub_consttime"
   (bn_mod_sub_consttime_spec p_words);

-bn_from_montgomery_in_place_p_ov <- crucible_llvm_unsafe_assume_spec
-  m
-  "bn_from_montgomery_in_place"
-  (bn_from_montgomery_in_place_spec p_words);
+// bn_from_montgomery_in_place_p_ov <- crucible_llvm_unsafe_assume_spec
+//   m
+//   "bn_from_montgomery_in_place"
+//   (bn_from_montgomery_in_place_spec p_words);

 bn_mul_mont_with_N_p_ov <- crucible_llvm_unsafe_assume_spec
   m
diff --git a/SAW/proof/RSA/RSA.saw b/SAW/proof/RSA/RSA.saw
index e8ca7a3..362092a 100644
--- a/SAW/proof/RSA/RSA.saw
+++ b/SAW/proof/RSA/RSA.saw
@@ -557,13 +557,13 @@ let RSA_sign_pss_mgf1_ovs =
   , bn_uadd_consttime_n_p_ov
   , bn_mul_consttime_p_ov
   , bn_mod_sub_consttime_p_ov
-  , bn_from_montgomery_in_place_p_ov
+  // , bn_from_montgomery_in_place_p_ov
   , bn_mul_mont_with_N_p_ov
   , bn_mul_mont_with_N_same_res_left_p_ov
   , bn_mul_mont_with_N_same_res_left_n_ov
   , bn_mul_mont_with_N_same_res_left_right_n_ov
   , sha512_block_data_order_spec
```

That leads to:

```
[13:11:04.564] Verifying RSA_padding_add_PKCS1_PSS_mgf1 ...
[13:11:04.568] Simulating RSA_padding_add_PKCS1_PSS_mgf1 ...
[13:11:04.569] Registering overrides for `BN_num_bits`
[13:11:04.569]   variant `Symbol "BN_num_bits"`
[13:11:04.569] Registering overrides for `OPENSSL_cleanse`
[13:11:04.569]   variant `Symbol "OPENSSL_cleanse"`
[13:11:04.570] Registering overrides for `OPENSSL_free`
[13:11:04.570]   variant `Symbol "OPENSSL_free"`
[13:11:04.570] Registering overrides for `OPENSSL_malloc`
[13:11:04.570]   variant `Symbol "OPENSSL_malloc"`
[13:11:04.570] Registering overrides for `RAND_bytes`
[13:11:04.570]   variant `Symbol "RAND_bytes"`
[13:11:04.570] Registering overrides for `sha512_block_data_order`
[13:11:04.570]   variant `Symbol "sha512_block_data_order"`
[13:11:04.584] Matching 1 overrides of  BN_num_bits ...
[13:11:04.586] Branching on 1 override variants of BN_num_bits ...
[13:11:04.586] Applied override! BN_num_bits
[13:11:04.587] Matching 1 overrides of  BN_num_bits ...
[13:11:04.589] Branching on 1 override variants of BN_num_bits ...
[13:11:04.589] Applied override! BN_num_bits
[13:11:04.590] Matching 1 overrides of  OPENSSL_malloc ...
[13:11:04.590] Branching on 1 override variants of OPENSSL_malloc ...
[13:11:04.590] Applied override! OPENSSL_malloc
[13:11:04.591] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/verify-RSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:477:38-477:49):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Both branches aborted after a symbolic branch.
Location of control-flow branching:
  src/crypto/fipsmodule/rsa/padding.c:600:7
Message from the true branch:
  Abort due to false assumption:
    src/crypto/fipsmodule/rand/fork_detect.c:91:3: error: in RAND_bytes_with_additional_data
    Global symbol not allocated
    Details:
      Global symbol "g_fork_detect_once" has no associated allocation
```

In the unoptimized code, `RSA_padding_add_PKCS1_PSS_mgf1` invokes `RAND_bytes`, which in turn invokes `RAND_bytes_with_additional_data`. In the optimized code, `RAND_bytes_with_additional_data` is inlined into `RSA_padding_add_PKCS1_PSS_mgf1`. There is already an unsafe override for `RAND_bytes`, so let's cargo-cult that into an override for `RAND_bytes_with_additional_data`:

```diff
diff --git a/SAW/proof/RSA/RSA.saw b/SAW/proof/RSA/RSA.saw
index e8ca7a3..678d406 100644
--- a/SAW/proof/RSA/RSA.saw
+++ b/SAW/proof/RSA/RSA.saw
@@ -323,6 +323,17 @@ let RAND_bytes_spec size = do {
   crucible_return (crucible_term {{ 1 : [32] }});
 };

+let RAND_bytes_with_additional_data_spec size = do {
+  out <- crucible_fresh_cryptol_var "out" {| [size][8] |};
+  crucible_ghost_value random_out out;
+
+  out_ptr <- crucible_alloc (llvm_array size i8);
+  user_additional_data <- llvm_alloc_readonly (llvm_array 32 i8);
+  crucible_execute_func [out_ptr, crucible_term {{ `size : [64] }}, user_additional_data];
+
+  crucible_points_to out_ptr (crucible_term out);
+};
+
 let RSA_padding_add_PKCS1_PSS_mgf1_spec = do {
   salt <- crucible_fresh_cryptol_var "salt" {| [salt_len][8] |};
   crucible_ghost_value random_out salt;
@@ -474,11 +485,17 @@ RAND_bytes_ov <- crucible_llvm_unsafe_assume_spec
   "RAND_bytes"
   (RAND_bytes_spec salt_len);

+RAND_bytes_with_additional_data_ov <- crucible_llvm_unsafe_assume_spec
+  m
+  "RAND_bytes_with_additional_data"
+  (RAND_bytes_with_additional_data_spec salt_len);
+
 RSA_padding_add_PKCS1_PSS_mgf1_ov <- llvm_verify
   m
   "RSA_padding_add_PKCS1_PSS_mgf1"
   [ sha512_block_data_order_spec
   , RAND_bytes_ov
+  , RAND_bytes_with_additional_data_ov
   , BN_num_bits_n_bits_ov
   , OPENSSL_malloc_ov
   , OPENSSL_free_nonnull_salt_ov
```

Unfortunately, this leads to another hang in a different function...

```
[13:35:30.354] Verifying RSA_verify_PKCS1_PSS_mgf1 ...
[13:35:30.371] Simulating RSA_verify_PKCS1_PSS_mgf1 ...
[13:35:30.372] Registering overrides for `BN_num_bits`
[13:35:30.372]   variant `Symbol "BN_num_bits"`
[13:35:30.372] Registering overrides for `ERR_put_error`
[13:35:30.372]   variant `Symbol "ERR_put_error"`
[13:35:30.372] Registering overrides for `EVP_DigestFinal_ex`
[13:35:30.373]   variant `Symbol "EVP_DigestFinal_ex"`
[13:35:30.373] Registering overrides for `OPENSSL_cleanse`
[13:35:30.373]   variant `Symbol "OPENSSL_cleanse"`
[13:35:30.373] Registering overrides for `OPENSSL_free`
[13:35:30.373]   variant `Symbol "OPENSSL_free"`
[13:35:30.373] Registering overrides for `OPENSSL_malloc`
[13:35:30.374]   variant `Symbol "OPENSSL_malloc"`
[13:35:30.374] Registering overrides for `memcmp`
[13:35:30.374]   variant `Symbol "memcmp"`
[13:35:30.374] Registering overrides for `sha512_block_data_order`
[13:35:30.374]   variant `Symbol "sha512_block_data_order"`
[13:35:30.383] Matching 1 overrides of  BN_num_bits ...
[13:35:30.401] Branching on 1 override variants of BN_num_bits ...
[13:35:30.405] Applied override! BN_num_bits
[13:35:30.407] Matching 1 overrides of  BN_num_bits ...
[13:35:30.418] Branching on 1 override variants of BN_num_bits ...
[13:35:30.418] Applied override! BN_num_bits
[13:35:30.420] Matching 1 overrides of  OPENSSL_malloc ...
[13:35:30.420] Branching on 1 override variants of OPENSSL_malloc ...
[13:35:30.420] Applied override! OPENSSL_malloc
[13:35:30.421] Matching 1 overrides of  OPENSSL_malloc ...
[13:35:30.422] Branching on 1 override variants of OPENSSL_malloc ...
[13:35:30.422] Applied override! OPENSSL_malloc
[13:35:30.422] Matching 2 overrides of  OPENSSL_free ...
[13:35:30.422] Branching on 1 override variants of OPENSSL_free ...
[13:35:30.422] Applied override! OPENSSL_free
[13:35:30.426] Matching 1 overrides of  sha512_block_data_order ...
[13:35:30.428] Branching on 1 override variants of sha512_block_data_order ...
[13:35:30.429] Applied override! sha512_block_data_order
[13:35:30.432] Matching 1 overrides of  OPENSSL_cleanse ...
[13:35:30.432] Branching on 1 override variants of OPENSSL_cleanse ...
[13:35:30.432] Applied override! OPENSSL_cleanse
[13:35:30.435] Matching 1 overrides of  sha512_block_data_order ...
[13:35:30.437] Branching on 1 override variants of sha512_block_data_order ...
[13:35:30.438] Applied override! sha512_block_data_order
[13:35:30.439] Matching 1 overrides of  OPENSSL_cleanse ...
[13:35:30.439] Branching on 1 override variants of OPENSSL_cleanse ...
[13:35:30.439] Applied override! OPENSSL_cleanse
[13:35:30.440] Matching 2 overrides of  OPENSSL_free ...
[13:35:30.440] Branching on 1 override variants of OPENSSL_free ...
[13:35:30.440] Applied override! OPENSSL_free
[13:35:30.562] Matching 1 overrides of  OPENSSL_malloc ...
[13:35:30.562] Branching on 1 override variants of OPENSSL_malloc ...
[13:35:30.562] Applied override! OPENSSL_malloc
[13:35:30.563] Matching 2 overrides of  OPENSSL_free ...
[13:35:30.563] Branching on 1 override variants of OPENSSL_free ...
[13:35:30.563] Applied override! OPENSSL_free
[13:35:30.600] Matching 1 overrides of  sha512_block_data_order ...
```

Ugh. I've exhausted all of my leads, so at this point, I suppose I'll go back and unsafe-assume things until progress happens. Let's revisit ECDSA first:

```diff
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..fb5d5c6 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -208,44 +209,52 @@ jacobian_affine_1_thm <- prove_print
   (rewrite (cryptol_ss ()) {{ \u1 u2 Q -> fromJacobian { x = ((ec_point_jacobian_add (ec_point_jacobian_scalar_mul (u1 % `P384_n) P3
84_G_Jacobian) (ec_point_jacobian_scalar_mul (u2 % `P384_n) Q)).x % `P384_p), y = ((ec_point_jacobian_add (ec_point_jacobian_scalar_m
ul (u1 % `P384_n) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (u2 % `P384_n) Q)).y % `P384_p), z = ((ec_point_jacobian_add (ec_poi
nt_jacobian_scalar_mul (u1 % `P384_n) P384_G_Jacobian) (ec_point_jacobian_scalar_mul (u2 % `P384_n) Q)).z % `P384_p) } == ec_point_af
fine_add (ec_point_affine_scalar_mul (u1 % `P384_n) P384_G) (ec_point_affine_scalar_mul (u2 % `P384_n) (fromJacobian Q)) }});


-ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
-  [ sha512_block_data_order_spec
-  , ec_bignum_to_scalar_ov
-  , ec_scalar_to_montgomery_ov
-  , ec_scalar_to_montgomery_same_ov
-  , ec_scalar_from_montgomery_ov
-  , ec_scalar_from_montgomery_same_ov
-  , ec_scalar_add_ov
-  , ec_scalar_add_same_l_ov
-  , ec_scalar_mul_montgomery_ov
-  , ec_scalar_mul_montgomery_same_l_ov
-  , ec_scalar_mul_montgomery_same_r_ov
-  , ec_simple_scalar_inv0_montgomery_ov
-  , ec_random_nonzero_scalar_ov
-  , ec_point_mul_scalar_base_ov
-  , ec_point_mul_scalar_public_ov
-  , ec_cmp_x_coordinate_ov
-  , ec_get_x_coordinate_as_scalar_ov
-  , digest_to_scalar_ov
-  , ec_scalar_is_zero_false_ov
-  , BN_is_zero_false_ov
-  , OPENSSL_malloc_ov
-  , OPENSSL_cleanse_ov
-  ]
-  true
-  ECDSA_do_sign_spec
-  (do {
-    unfolding ["ECDSA_sign"];
-    unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
-    simplify (cryptol_ss ());
-    simplify (addsimp scalarBV_thm empty_ss);
-    simplify (addsimp fieldElementBV_thm empty_ss);
-    simplify (addsimps mont_thms empty_ss);
-    simplify (addsimp jacobian_affine_0_thm empty_ss);
-    simplify (addsimps mod_thms empty_ss);
-    goal_eval_unint ["inv0", "ec_point_affine_scalar_mul"];
-    w4_unint_z3 ["inv0", "ec_point_affine_scalar_mul"];
-  });
+// ECDSA_do_sign_ov <- llvm_verify m "ECDSA_do_sign"
+//   [ sha512_block_data_order_spec
+//   , ec_bignum_to_scalar_ov
+//   , ec_scalar_to_montgomery_ov
+//   , ec_scalar_to_montgomery_same_ov
+//   , ec_scalar_from_montgomery_ov
+//   , ec_scalar_from_montgomery_same_ov
+//   , ec_scalar_add_ov
+//   , ec_scalar_add_same_l_ov
+//   , ec_scalar_mul_montgomery_ov
+//   , ec_scalar_mul_montgomery_same_l_ov
+//   , ec_scalar_mul_montgomery_same_r_ov
+//   , ec_simple_scalar_inv0_montgomery_ov
+//   , ec_random_nonzero_scalar_ov
+//   , ec_point_mul_scalar_base_ov
+//   , ec_point_mul_scalar_public_ov
+//   , ec_cmp_x_coordinate_ov
+//   , ec_get_x_coordinate_as_scalar_ov
+//   // , digest_to_scalar_ov
+//   , ec_scalar_is_zero_false_ov
+//   , BN_is_zero_false_ov
+//   , OPENSSL_malloc_ov
+//   , OPENSSL_cleanse_ov
+//   , bn_rand_range_words_ov
+//   , bn_mod_mul_montgomery_small_ov
+//   , bn_mod_mul_montgomery_small_same_l_ov
+//   , bn_mod_mul_montgomery_small_same_r_ov
+//   , ec_GFp_mont_mul_base_ov
+//   , ec_GFp_simple_is_on_curve_ov
+//   ]
+//   true
+//   ECDSA_do_sign_spec
+//   (do {
+//     unfolding ["ECDSA_sign"];
+//     unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
+//     simplify (cryptol_ss ());
+//     simplify (addsimp scalarBV_thm empty_ss);
+//     simplify (addsimp fieldElementBV_thm empty_ss);
+//     simplify (addsimps mont_thms empty_ss);
+//     simplify (addsimp jacobian_affine_0_thm empty_ss);
+//     simplify (addsimps mod_thms empty_ss);
+//     goal_eval_unint ["inv0", "ec_point_affine_scalar_mul"];
+//     w4_unint_z3 ["inv0", "ec_point_affine_scalar_mul"];
+//   });
+ECDSA_do_sign_ov <- llvm_unsafe_assume_spec m "ECDSA_do_sign"
+  ECDSA_do_sign_spec;

 ECDSA_do_verify_ov <- llvm_verify m "ECDSA_do_verify"
   [ BN_is_zero_ov
```

That's enough to make some progress, at least:

```
[13:56:10.657] Assume override ECDSA_do_sign


[13:56:12.469] Verifying ECDSA_do_verify ...
[13:56:12.490] Simulating ECDSA_do_verify ...
[13:56:12.490] Registering overrides for `BN_is_zero`
[13:56:12.491]   variant `Symbol "BN_is_zero"`
[13:56:12.491] Registering overrides for `ERR_put_error`
[13:56:12.491]   variant `Symbol "ERR_put_error"`
[13:56:12.491] Registering overrides for `ec_bignum_to_scalar`
[13:56:12.491]   variant `Symbol "ec_bignum_to_scalar"`
[13:56:12.491] Registering overrides for `ec_cmp_x_coordinate`
[13:56:12.491]   variant `Symbol "ec_cmp_x_coordinate"`
[13:56:12.492] Registering overrides for `ec_get_x_coordinate_as_scalar`
[13:56:12.492]   variant `Symbol "ec_get_x_coordinate_as_scalar"`
[13:56:12.492] Registering overrides for `ec_point_mul_scalar_base`
[13:56:12.492]   variant `Symbol "ec_point_mul_scalar_base"`
[13:56:12.492] Registering overrides for `ec_point_mul_scalar_public`
[13:56:12.492]   variant `Symbol "ec_point_mul_scalar_public"`
[13:56:12.493] Registering overrides for `ec_random_nonzero_scalar`
[13:56:12.493]   variant `Symbol "ec_random_nonzero_scalar"`
[13:56:12.493] Registering overrides for `ec_scalar_add`
[13:56:12.493]   variant `Symbol "ec_scalar_add"`
[13:56:12.493] Registering overrides for `ec_scalar_from_montgomery`
[13:56:12.493]   variant `Symbol "ec_scalar_from_montgomery"`
[13:56:12.493] Registering overrides for `ec_scalar_is_zero`
[13:56:12.494]   variant `Symbol "ec_scalar_is_zero"`
[13:56:12.494] Registering overrides for `ec_scalar_mul_montgomery`
[13:56:12.494]   variant `Symbol "ec_scalar_mul_montgomery"`
[13:56:12.494] Registering overrides for `ec_scalar_to_montgomery`
[13:56:12.494]   variant `Symbol "ec_scalar_to_montgomery"`
[13:56:12.494] Registering overrides for `ec_simple_scalar_inv0_montgomery`
[13:56:12.494]   variant `Symbol "ec_simple_scalar_inv0_montgomery"`
[13:56:12.509] Matching 1 overrides of  ERR_put_error ...
[13:56:12.509] Branching on 1 override variants of ERR_put_error ...
[13:56:12.509] Applied override! ERR_put_error
[13:56:12.510] Matching 1 overrides of  ec_bignum_to_scalar ...
[13:56:12.548] Branching on 1 override variants of ec_bignum_to_scalar ...
[13:56:12.549] Applied override! ec_bignum_to_scalar
[13:56:12.549] Matching 1 overrides of  ERR_put_error ...
[13:56:12.549] Branching on 1 override variants of ERR_put_error ...
[13:56:12.549] Applied override! ERR_put_error
[13:56:12.552] Matching 1 overrides of  ERR_put_error ...
[13:56:12.552] Branching on 1 override variants of ERR_put_error ...
[13:56:12.552] Applied override! ERR_put_error
[13:56:12.552] Matching 1 overrides of  ec_bignum_to_scalar ...
[13:56:12.584] Branching on 1 override variants of ec_bignum_to_scalar ...
[13:56:12.585] Applied override! ec_bignum_to_scalar
[13:56:12.586] Matching 1 overrides of  ERR_put_error ...
[13:56:12.586] Branching on 1 override variants of ERR_put_error ...
[13:56:12.586] Applied override! ERR_put_error
[13:56:12.587] Matching 1 overrides of  ec_simple_scalar_inv0_montgomery ...
[13:56:12.618] Branching on 1 override variants of ec_simple_scalar_inv0_montgomery ...
[13:56:12.618] Applied override! ec_simple_scalar_inv0_montgomery
[13:56:12.622] Symbolic simulation completed with side conditions.
[13:56:12.629] Checking proof obligations ECDSA_do_verify ...
[13:56:12.870] Subgoal failed: ECDSA_do_verify safety assertion:
src/crypto/fipsmodule/bn/asm/x86_64-gcc.c:106:5: error: in bn_mul_add_words
unsupported LLVM value: ValAsm False False "mulq $3" "={ax},={dx},{ax},*m,~{cc},~{dirflag},~{fpsr},~{flags}" of type { i64, i64 }(i64, i64*)*
```

This happens because `ECDSA_do_verify` invokes `ec_scalar_to_montgomery_inv_vartime`, which invokes `ec_simple_scalar_to_montgomery_inv_vartime` (by way of function pointer shenanigans), which invokes `ec_scalar_from_montgomery`, which invokes `bn_from_montgomery_small`, which invokes `bn_from_montgomery_in_place`, which invokes `bn_mul_add_words`. There is an override for `ec_scalar_from_montgomery`, which prevents us from going further than that in the unoptimized code. In the optimized code, `ec_scalar_from_montgomery` is inlined, leaving instead a call site to `bn_from_montgomery_small`.

Unfortunately, `bn_from_montgomery_in_place` was also inlined away, leaving only `bn_from_montgomery_small`. Time to come up with an unsafe spec for this function. Here is my best attempt (in `proof/BN/BN.saw`):

```
let bn_from_montgomery_small_spec num = do {
  let num_bits = eval_size {| num * 64 |};
  let num_val = llvm_term {{ `num : [64] }};

  r_ptr <- llvm_alloc (llvm_int num_bits);
  (a, a_ptr) <- ptr_to_fresh "a" (llvm_int num_bits);

  (N_d, N_d_ptr) <- ptr_to_fresh_readonly "N_d" (llvm_int num_bits);
  mont_ptr <- pointer_to_bn_mont_ctx_st_with_N_d num N_d_ptr N_d;

  llvm_execute_func [r_ptr, num_val, a_ptr, num_val, mont_ptr];

  llvm_points_to r_ptr (llvm_term {{ integerToBV`{num_bits} (((integerFromBV a) * (integerFromBV (mont_R_inv_with_N N_d))) % (integerModulusFromBV N_d)) }});
};

let bn_from_montgomery_small_same_spec num = do {
  let num_bits = eval_size {| num * 64 |};
  let num_val = llvm_term {{ `num : [64] }};

  (r, r_ptr) <- ptr_to_fresh "r" (llvm_int num_bits);

  (N_d, N_d_ptr) <- ptr_to_fresh_readonly "N_d" (llvm_int num_bits);
  mont_ptr <- pointer_to_bn_mont_ctx_st_with_N_d num N_d_ptr N_d;

  llvm_execute_func [r_ptr, num_val, r_ptr, num_val, mont_ptr];

  llvm_points_to r_ptr (llvm_term {{ integerToBV`{num_bits} (((integerFromBV r) * (integerFromBV (mont_R_inv_with_N N_d))) % (integerModulusFromBV N_d)) }});
};
```

And where it's used:

```diff
diff --git a/SAW/proof/EC/EC.saw b/SAW/proof/EC/EC.saw
index ce9dd3d..9b7884c 100644
--- a/SAW/proof/EC/EC.saw
+++ b/SAW/proof/EC/EC.saw
@@ -731,6 +871,15 @@ ec_scalar_from_montgomery_same_ov <- crucible_llvm_unsafe_assume_spec
   "ec_scalar_from_montgomery"
   ec_scalar_from_montgomery_same_spec;

+bn_from_montgomery_small_ov <- llvm_unsafe_assume_spec
+  m
+  "bn_from_montgomery_small"
+  (bn_from_montgomery_small_spec ec_words);
+bn_from_montgomery_small_same_ov <- llvm_unsafe_assume_spec
+  m
+  "bn_from_montgomery_small"
+  (bn_from_montgomery_small_same_spec ec_words);
+
 ec_scalar_add_ov <- crucible_llvm_unsafe_assume_spec
   m
   "ec_scalar_add"
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..8490a0b 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -264,8 +273,10 @@ ECDSA_do_verify_ov <- llvm_verify m "ECDSA_do_verify"
   , ERR_put_error_ov
+  , bn_from_montgomery_small_ov
+  , bn_from_montgomery_small_same_ov
   ]
   true
   ECDSA_do_verify_spec
```

Having done all of that, I am greeted with:

```
[15:05:40.412] Verifying ECDSA_do_verify ...
[15:05:40.422] Simulating ECDSA_do_verify ...
<elided>
[15:05:40.554] Matching 2 overrides of  bn_from_montgomery_small ...
[15:05:40.565] Run-time error: encountered call to the Cryptol 'error' function
```

Oh dear. What is causing that? It's very unclear to me. I had a hunch that it might be one of `mont_R_inv_with_N` or `bn_mont_n0_with_N`, which are used in the specs for `bn_from_montgomery_small`:

```diff
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..8490a0b 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -278,8 +289,8 @@ ECDSA_do_verify_ov <- llvm_verify m "ECDSA_do_verify"
     simplify (addsimps mont_thms empty_ss);
     simplify (addsimp jacobian_affine_1_thm empty_ss);
     simplify (addsimps mod_thms empty_ss);
-    goal_eval_unint ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian"];
-    w4_unint_z3 ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian"];
+    goal_eval_unint ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian", "mont_R_inv_with_N", "bn_mont_n0_with_N"];
+    w4_unint_z3 ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian", "mont_R_inv_with_N", "bn_mont_n0_with_N"];
   });
```

Unfortunately, that didn't change the error. Alas, I have no idea how to debug this currently. Skipping for now:

```diff
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..8490a0b 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
+// ECDSA_do_verify_ov <- llvm_verify m "ECDSA_do_verify"
+//   [ BN_is_zero_ov
+//   , ec_bignum_to_scalar_ov
+//   , ec_scalar_to_montgomery_ov
+//   , ec_scalar_to_montgomery_same_ov
+//   , ec_scalar_from_montgomery_ov
+//   , ec_scalar_from_montgomery_same_ov
+//   , ec_scalar_add_ov
+//   , ec_scalar_mul_montgomery_ov
+//   , ec_scalar_mul_montgomery_same_r_ov
+//   , ec_simple_scalar_inv0_montgomery_ov
+//   , ec_scalar_is_zero_ov
+//   , ec_random_nonzero_scalar_ov
+//   , ec_point_mul_scalar_base_ov
+//   , ec_point_mul_scalar_public_ov
+//   , ec_cmp_x_coordinate_ov
+//   , ec_get_x_coordinate_as_scalar_ov
+//   // , digest_to_scalar_ov
+//   , ERR_put_error_ov
+//   , bn_from_montgomery_small_ov
+//   , bn_from_montgomery_small_same_ov
+//   ]
+//   true
+//   ECDSA_do_verify_spec
+//   (do {
+//     unfolding ["ECDSA_verify"];
+//     unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
+//     simplify (cryptol_ss ());
+//     simplify (addsimp scalarBV_thm empty_ss);
+//     simplify (addsimp fieldElementBV_thm empty_ss);
+//     simplify (addsimps mont_thms empty_ss);
+//     simplify (addsimp jacobian_affine_1_thm empty_ss);
+//     simplify (addsimps mod_thms empty_ss);
+//     goal_eval_unint ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian", "mont_R_inv_with_N", "bn_mont_n0_with_N"];
+//     w4_unint_z3 ["inv0", "ec_point_affine_add", "ec_point_affine_scalar_mul", "fromJacobian", "mont_R_inv_with_N", "bn_mont_n0_with_N"];
+//   });
+ECDSA_do_verify_ov <- llvm_unsafe_assume_spec m "ECDSA_do_verify"
+  ECDSA_do_verify_spec;
```

We're on the last leg of ECDSA now, as the next failure is in `EVP_DigestFinal_ex`:

```
[15:20:34.723] Verifying EVP_DigestVerifyFinal ...
[15:20:34.745] Simulating EVP_DigestVerifyFinal ...
<elided>
[15:20:34.879] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/verify-ECDSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/ECDSA/ECDSA.saw:347:1-347:12):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Both branches aborted after a symbolic branch.
Location of control-flow branching:
  src/crypto/bn_extra/bn_asn1.c:49:8
Message from the true branch:
  Abort due to false assumption:
    src/crypto/ecdsa_extra/../internal.h:789:10: error: in ECDSA_verify
    Failed to load function handle
    Details:
      No implementation or override found for pointer: "bcmp"
```

My best guess is that `memcmp` is being optimized into `bcmp`. There's already an unsafe override for `memcmp`, so let's cargo-cult it for `bcmp`:

```diff
diff --git a/SAW/proof/common/memory.saw b/SAW/proof/common/memory.saw
index 5031849..6680245 100644
--- a/SAW/proof/common/memory.saw
+++ b/SAW/proof/common/memory.saw
@@ -1,4 +1,4 @@
-/*
+/*
  * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
  * SPDX-License-Identifier: Apache-2.0
 */
@@ -87,6 +87,17 @@ let memcmp_spec count = do {
   crucible_return (crucible_term {{ if (join lhs) < (join rhs) then (0 - 1) : [32] else if (join lhs) == (join rhs) then 0 else 1 }}
);
 };

+let bcmp_spec count = do {
+  (lhs, lhs_ptr) <- ptr_to_fresh_readonly "lhs" (llvm_array count i8);
+  (rhs, rhs_ptr) <- ptr_to_fresh_readonly "rhs" (llvm_array count i8);
+
+  llvm_execute_func [lhs_ptr, rhs_ptr, (llvm_term {{ `count : [64] }})];
+
+  bcmp_res <- llvm_fresh_var "bcmp_res" i32;
+  llvm_postcond {{ bcmp_res != 0 }};
+  llvm_return (llvm_term {{ if (join lhs) == (join rhs) then 0 else bcmp_res }});
+};
+

 ////////////////////////////////////////////////////////////////////////////////
 // Proof commands
diff --git a/SAW/proof/ECDSA/memory.saw b/SAW/proof/ECDSA/memory.saw
index 63b5714..9843370 100644
--- a/SAW/proof/ECDSA/memory.saw
+++ b/SAW/proof/ECDSA/memory.saw
@@ -42,3 +42,9 @@ memcmp_ov <- crucible_llvm_unsafe_assume_spec
   "memcmp"
   (memcmp_spec sig_len);

+// EVP_DigestVerifyFinal requires a bcmp_ov override when it
+// defends against potential laxness in the DER parser.
+bcmp_ov <- llvm_unsafe_assume_spec
+  m
+  "bcmp"
+  (bcmp_spec sig_len);
diff --git a/SAW/proof/ECDSA/ECDSA.saw b/SAW/proof/ECDSA/ECDSA.saw
index eb781c0..c18bd89 100644
--- a/SAW/proof/ECDSA/ECDSA.saw
+++ b/SAW/proof/ECDSA/ECDSA.saw
@@ -345,6 +358,7 @@ llvm_verify m "EVP_DigestVerifyFinal"
     , CRYPTO_refcount_inc_ov
     , CRYPTO_refcount_dec_and_test_zero_ov
     , memcmp_ov
+    , bcmp_ov
     , sha512_block_data_order_spec
     , BN_num_bits_r_bits_ov
     , BN_num_bits_s_bits_ov
```

That's enough to verify everything involved with ECDSA. On to ECDH. First, let's unsafe-assume the thing that's been giving us trouble:

```diff
diff --git a/SAW/proof/ECDH/ECDH.saw b/SAW/proof/ECDH/ECDH.saw
index 27a3755..72e0cb0 100644
--- a/SAW/proof/ECDH/ECDH.saw
+++ b/SAW/proof/ECDH/ECDH.saw
@@ -98,23 +98,28 @@ llvm_verify m "EVP_PKEY_keygen_init"
   (EVP_PKEY_operation_init_spec EVP_PKEY_OP_KEYGEN)
   (w4_unint_z3 []);

-llvm_verify m "EVP_PKEY_keygen"
-  [ ec_random_nonzero_scalar_ov
-  , ec_point_mul_scalar_base_ov
-  , OPENSSL_malloc_ov
-  ]
-  true
-  EVP_PKEY_keygen_spec
-  (do {
-    unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
-    simplify (cryptol_ss ());
-    simplify (addsimp scalarBV_thm empty_ss);
-    simplify (addsimp fieldElementBV_thm empty_ss);
-    simplify (addsimps mont_thms empty_ss);
-    simplify (addsimp jacobian_affine_0_thm empty_ss);
-    goal_eval_unint ["ec_point_affine_scalar_mul", "fromJacobian"];
-    w4_unint_z3 ["ec_point_affine_scalar_mul", "fromJacobian"];
-  });
+// llvm_verify m "EVP_PKEY_keygen"
+//   [ ec_random_nonzero_scalar_ov
+//   , ec_point_mul_scalar_base_ov
+//   , OPENSSL_malloc_ov
+//   , bn_rand_range_words_ov
+//   , ec_GFp_mont_mul_base_ov
+//   , ec_GFp_simple_is_on_curve_ov
+//   ]
+//   true
+//   EVP_PKEY_keygen_spec
+//   (do {
+//     unfolding ["jacobianToMontBV", "jacobianFromMontBV", "jacobianToMont", "jacobianFromMont", "jacobianToBV", "jacobianFromBV"];
+//     simplify (cryptol_ss ());
+//     simplify (addsimp scalarBV_thm empty_ss);
+//     simplify (addsimp fieldElementBV_thm empty_ss);
+//     simplify (addsimps mont_thms empty_ss);
+//     simplify (addsimp jacobian_affine_0_thm empty_ss);
+//     goal_eval_unint ["ec_point_affine_scalar_mul", "fromJacobian"];
+//     w4_unint_z3 ["ec_point_affine_scalar_mul", "fromJacobian"];
+//   });
+llvm_unsafe_assume_spec m "EVP_PKEY_keygen"
+  EVP_PKEY_keygen_spec;


 llvm_verify m "EVP_PKEY_derive_init"
```

As it turns out, everything else in ECDH verifies just fine. On to RSA. First, let's comment out the thing that's been giving me trouble (in `proof/RSA/RSA.saw`):

```diff
// RSA_verify_PKCS1_PSS_mgf1_ov <- llvm_verify
//   m
//   "RSA_verify_PKCS1_PSS_mgf1"
//   [ EVP_DigestFinal_ex_0x34_ov
//   , EVP_DigestFinal_ex_0x68_ov
//   , sha512_block_data_order_spec
//   , BN_num_bits_n_bits_ov
//   , OPENSSL_malloc_ov
//   , OPENSSL_free_nonnull_salt_ov
//   , OPENSSL_free_null_ov
//   , OPENSSL_cleanse_ov
//   , memcmp_ov
//   , ERR_put_error_ov
//   ]
//   true
//   RSA_verify_PKCS1_PSS_mgf1_spec
//   (do {
//     w4_unint_z3 ["processBlock_Common"];
//   });
RSA_verify_PKCS1_PSS_mgf1_ov <- llvm_unsafe_assume_spec
  m
  "RSA_verify_PKCS1_PSS_mgf1"
  RSA_verify_PKCS1_PSS_mgf1_spec;
```

That leads to:

```
[16:59:46.196] Verifying EVP_DigestFinal_ex ...
[16:59:46.199] Simulating EVP_DigestFinal_ex ...
[16:59:46.199] Registering overrides for `OPENSSL_cleanse`
[16:59:46.199]   variant `Symbol "OPENSSL_cleanse"`
[16:59:46.200] Registering overrides for `sha512_block_data_order`
[16:59:46.200]   variant `Symbol "sha512_block_data_order"`
[16:59:46.204] Matching 1 overrides of  sha512_block_data_order ...
[16:59:46.206] Branching on 1 override variants of sha512_block_data_order ...
[16:59:46.207] Applied override! sha512_block_data_order
[16:59:46.208] Matching 1 overrides of  OPENSSL_cleanse ...
[16:59:46.208] Branching on 1 override variants of OPENSSL_cleanse ...
[16:59:46.208] Applied override! OPENSSL_cleanse
[16:59:46.215] Checking proof obligations EVP_DigestFinal_ex ...
[16:59:46.264] Proof succeeded! EVP_DigestFinal_ex
[16:59:46.694] Assume override RSA_verify_PKCS1_PSS_mgf1
[16:59:46.694] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/verify-RSA.saw:6:1-6:8):
"crucible_llvm_unsafe_assume_spec" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:552:24-552:56):
Could not find definition for function named `rsa_blinding_get`.
```

Indeed, `rsa_blinding_get` was inlined away into `rsa_default_private_transform`. Similarly for `rsa_blinding_release`. This kind of scares me, these are pretty non-trivial specifications, and `rsa_default_private_transform` is quite involved. I'm going to fix this by choosing to mark `rsa_blinding_get` and `rsa_blinding_release` as `noinline`:

```diff
diff --git a/crypto/fipsmodule/rsa/rsa_impl.c b/crypto/fipsmodule/rsa/rsa_impl.c
index a0ef8d1f5..d25dce2da 100644
--- a/crypto/fipsmodule/rsa/rsa_impl.c
+++ b/crypto/fipsmodule/rsa/rsa_impl.c
@@ -360,6 +360,7 @@ err:
 //
 // On success, the index of the assigned BN_BLINDING is written to
 // |*index_used| and must be passed to |rsa_blinding_release| when finished.
+__attribute__((noinline))
 static BN_BLINDING *rsa_blinding_get(RSA *rsa, unsigned *index_used,
                                      BN_CTX *ctx) {
   assert(ctx != NULL);
@@ -461,6 +462,7 @@ out:

 // rsa_blinding_release marks the cached BN_BLINDING at the given index as free
 // for other threads to use.
+__attribute__((noinline))
 static void rsa_blinding_release(RSA *rsa, BN_BLINDING *blinding,
                                  unsigned blinding_index) {
   if (blinding_index == MAX_BLINDINGS_PER_RSA) {
```

After that, I get:

```
[18:08:59.339] Verifying RSA_sign_pss_mgf1 ...
[18:08:59.344] Simulating RSA_sign_pss_mgf1 ...
<elided>
[18:08:59.703] Checking proof obligations RSA_sign_pss_mgf1 ...
[18:09:02.347] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/verify-RSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:601:1-601:12):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
"tactic" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:59-66:65):
"w4_unint_z3" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:615:5-615:16):
Prover returned Unknown
```

Oh bother. I ran into this before in the context of `bn_reduce_once_in_place`, but the code in `RSA_sign_pss_mgf1` is _much_ more complicated. So complicated, in fact, that I shudder to think about doing this. I'm going to skip this for now:

```diff
diff --git a/SAW/proof/RSA/RSA.saw b/SAW/proof/RSA/RSA.saw
index e8ca7a3..f3c639b 100644
--- a/SAW/proof/RSA/RSA.saw
+++ b/SAW/proof/RSA/RSA.saw
@@ -577,73 +598,89 @@ let RSA_sign_pss_mgf1_ovs =
   , OPENSSL_cleanse_ov
   ];

-llvm_verify
+// llvm_verify
+//   m
+//   "RSA_sign_pss_mgf1"
+//   RSA_sign_pss_mgf1_ovs
+//   true
+//   (RSA_sign_pss_mgf1_spec false false)
+//   (do {
+//     sign_pss_mgf1_base_tactic;
+//     goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
+//     goal_num_when 1 vrfy_no_blinding_tactic;
+//     goal_num_when 2 sign_tactic;
+//     goal_num_when 3 vrfy_no_blinding_tactic;
+//     goal_num_when 4 vrfy_no_blinding_tactic;
+//     goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//     w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//   });
+llvm_unsafe_assume_spec
   m
   "RSA_sign_pss_mgf1"
-  RSA_sign_pss_mgf1_ovs
-  true
-  (RSA_sign_pss_mgf1_spec false false)
-  (do {
-    sign_pss_mgf1_base_tactic;
-    goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
-    goal_num_when 1 vrfy_no_blinding_tactic;
-    goal_num_when 2 sign_tactic;
-    goal_num_when 3 vrfy_no_blinding_tactic;
-    goal_num_when 4 vrfy_no_blinding_tactic;
-    goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-    w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-  });
-
-llvm_verify
+  (RSA_sign_pss_mgf1_spec false false);
+
+// llvm_verify
+//   m
+//   "RSA_sign_pss_mgf1"
+//   RSA_sign_pss_mgf1_ovs
+//   true
+//   (RSA_sign_pss_mgf1_spec true false)
+//   (do {
+//     sign_pss_mgf1_base_tactic;
+//     goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
+//     goal_num_when 2 vrfy_no_blinding_tactic;
+//     goal_num_when 3 sign_tactic;
+//     goal_num_when 4 vrfy_no_blinding_tactic;
+//     goal_num_when 5 vrfy_no_blinding_tactic;
+//     goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//     w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//   });
+llvm_unsafe_assume_spec
   m
   "RSA_sign_pss_mgf1"
-  RSA_sign_pss_mgf1_ovs
-  true
-  (RSA_sign_pss_mgf1_spec true false)
-  (do {
-    sign_pss_mgf1_base_tactic;
-    goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
-    goal_num_when 2 vrfy_no_blinding_tactic;
-    goal_num_when 3 sign_tactic;
-    goal_num_when 4 vrfy_no_blinding_tactic;
-    goal_num_when 5 vrfy_no_blinding_tactic;
-    goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-    w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-  });
-
-llvm_verify
+  (RSA_sign_pss_mgf1_spec true false);
+
+// llvm_verify
+//   m
+//   "RSA_sign_pss_mgf1"
+//   RSA_sign_pss_mgf1_ovs
+//   true
+//   (RSA_sign_pss_mgf1_spec false true)
+//   (do {
+//     sign_pss_mgf1_base_tactic;
+//     goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
+//     goal_num_when 1 vrfy_tactic;
+//     goal_num_when 2 sign_tactic;
+//     goal_num_when 3 vrfy_tactic;
+//     goal_num_when 4 vrfy_tactic;
+//     goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//     w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//   });
+llvm_unsafe_assume_spec
   m
   "RSA_sign_pss_mgf1"
-  RSA_sign_pss_mgf1_ovs
-  true
-  (RSA_sign_pss_mgf1_spec false true)
-  (do {
-    sign_pss_mgf1_base_tactic;
-    goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
-    goal_num_when 1 vrfy_tactic;
-    goal_num_when 2 sign_tactic;
-    goal_num_when 3 vrfy_tactic;
-    goal_num_when 4 vrfy_tactic;
-    goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-    w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-  });
-
-RSA_sign_pss_mgf1_ov <- llvm_verify
+  (RSA_sign_pss_mgf1_spec false true);
+
+// RSA_sign_pss_mgf1_ov <- llvm_verify
+//   m
+//   "RSA_sign_pss_mgf1"
+//   RSA_sign_pss_mgf1_ovs
+//   true
+//   (RSA_sign_pss_mgf1_spec true true)
+//   (do {
+//     sign_pss_mgf1_base_tactic;
+//     goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
+//     goal_num_when 3 vrfy_tactic;
+//     goal_num_when 4 sign_tactic;
+//     goal_num_when 5 vrfy_tactic;
+//     goal_num_when 6 vrfy_tactic;
+//     goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//     w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
+//   });
+RSA_sign_pss_mgf1_ov <- llvm_unsafe_assume_spec
   m
   "RSA_sign_pss_mgf1"
-  RSA_sign_pss_mgf1_ovs
-  true
-  (RSA_sign_pss_mgf1_spec true true)
-  (do {
-    sign_pss_mgf1_base_tactic;
-    goal_num_when 0 (simplify (addsimp PSS_mgf1_encode_0_thm empty_ss));
-    goal_num_when 3 vrfy_tactic;
-    goal_num_when 4 sign_tactic;
-    goal_num_when 5 vrfy_tactic;
-    goal_num_when 6 vrfy_tactic;
-    goal_eval_unint ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-    w4_unint_z3 ["PSS_mgf1_encode", "processBlock_Common", "mont_R_inv_with_N", "bn_mont_n0_with_N", "exp", "inv", "phi", "rad", "integerToBV", "integerFromBV"];
-  });
+  (RSA_sign_pss_mgf1_spec true true);
```

Now I get:

```
[18:38:28.455] Verifying RSA_verify_pss_mgf1 ...
[18:38:28.465] Simulating RSA_verify_pss_mgf1 ...
<elided>
[18:38:28.502] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/verify-RSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:685:27-685:38):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
Symbolic execution failed.
Abort due to false assumption:
  src/crypto/mem.c:115:7: error: in OPENSSL_realloc
  Error translating constant
  Expected integer arguments
  ConstICmp Ine (Typed {typedType = Array 4 (PrimType (Integer 64)), typedValue = ValArray (PrimType (Integer 64)) [ValInteger 7436995610194789060,ValInteger 9042605089262227561,ValInteger 11621508125069628605,ValInteger 7289479057360149973]}) (Typed {typedType = P      trTo (Array 80 (PrimType (Integer 8))), typedValue = ValSymbol (Symbol ".str")})
```

Perhaps this is due to inlining exposing a call site to `OPENSSL_realloc` that wasn't there before? I don't know for sure, and I've lost the patience to investigate why. I'm just going to add some overrides for `OPENSSL_realloc` and hope for the best:

```diff
diff --git a/SAW/proof/RSA/RSA.saw b/SAW/proof/RSA/RSA.saw
index e8ca7a3..ab1fc23 100644
--- a/SAW/proof/RSA/RSA.saw
+++ b/SAW/proof/RSA/RSA.saw
@@ -667,6 +704,8 @@ RSA_verify_pss_mgf1_ov <- llvm_verify
   , OPENSSL_free_nonnull_1_ov
   , OPENSSL_free_null_ov
   , OPENSSL_cleanse_ov
+  , OPENSSL_realloc_null_ov
+  , OPENSSL_realloc_nonnull_ov
   ]
   true
   RSA_verify_pss_mgf1_spec
```

I hoped for too much, it seems:

```
[18:47:54.240] Verifying RSA_verify_pss_mgf1 ...
[18:47:54.245] Simulating RSA_verify_pss_mgf1 ...
<elided>
[18:47:54.457] Checking proof obligations RSA_verify_pss_mgf1 ...
[18:47:55.326] Stack trace:
"include" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/verify-RSA.saw:6:1-6:8):
"llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:685:27-685:38):
"crucible_llvm_verify" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:8-66:28):
"tactic" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/common/helpers.saw:66:59-66:65):
"goal_num_ite" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:714:5-714:17):
"w4_unint_z3" (/home/rscott/Documents/Hacking/SAW/aws-lc-verification/SAW/proof/RSA/RSA.saw:716:8-716:19):
Prover returned Unknown
```

Ugh. I feel like running from my problems today, so...

```
diff --git a/SAW/proof/RSA/RSA.saw b/SAW/proof/RSA/RSA.saw
index e8ca7a3..ab1fc23 100644
--- a/SAW/proof/RSA/RSA.saw
+++ b/SAW/proof/RSA/RSA.saw
+// RSA_verify_pss_mgf1_ov <- llvm_verify
+//   m
+//   "RSA_verify_pss_mgf1"
+//   [ RSA_verify_PKCS1_PSS_mgf1_ov
+//   , BN_mod_exp_mont_n_1_ov
+//   , BN_bn2bin_padded_n_ov
+//   , BN_bin2bn_n_ov
+//   , BN_ucmp_n_ov
+//   , BN_ucmp_gt_n_e_ov
+//   , BN_num_bits_n_bits_ov
+//   , BN_num_bits_e_bits_ov
+//   , sha512_block_data_order_spec
+//   // , value_barrier_w_ov
+//   , ERR_put_error_ov
+//   , CRYPTO_MUTEX_lock_read_ov
+//   , CRYPTO_MUTEX_unlock_read_ov
+//   , CRYPTO_MUTEX_lock_write_ov
+//   , CRYPTO_MUTEX_unlock_write_ov
+//   , OPENSSL_malloc_ov
+//   , OPENSSL_free_nonnull_1_ov
+//   , OPENSSL_free_null_ov
+//   , OPENSSL_cleanse_ov
+//   , OPENSSL_realloc_null_ov
+//   , OPENSSL_realloc_nonnull_ov
+//   ]
+//   true
+//   RSA_verify_pss_mgf1_spec
+//   (do {
+//     goal_eval_unint ["PSS_mgf1_verify", "processBlock_Common", "bn_mont_n0_with_N", "exp", "integerToBV", "integerFromBV"];
+//     goal_num_ite 0
+//       (w4_unint_z3 ["PSS_mgf1_verify", "processBlock_Common", "bn_mont_n0_with_N", "exp", "phi", "rad"])
+//       (w4_unint_z3 ["PSS_mgf1_verify", "processBlock_Common", "bn_mont_n0_with_N", "exp", "phi", "rad", "integerToBV", "integerFromBV"]);
+//   });
+RSA_verify_pss_mgf1_ov <- llvm_unsafe_assume_spec
   m
   "RSA_verify_pss_mgf1"
-  [ RSA_verify_PKCS1_PSS_mgf1_ov
-  , BN_mod_exp_mont_n_1_ov
-  , BN_bn2bin_padded_n_ov
-  , BN_bin2bn_n_ov
-  , BN_ucmp_n_ov
-  , BN_ucmp_gt_n_e_ov
-  , BN_num_bits_n_bits_ov
-  , BN_num_bits_e_bits_ov
-  , sha512_block_data_order_spec
-  , value_barrier_w_ov
-  , ERR_put_error_ov
-  , CRYPTO_MUTEX_lock_read_ov
-  , CRYPTO_MUTEX_unlock_read_ov
-  , CRYPTO_MUTEX_lock_write_ov
-  , CRYPTO_MUTEX_unlock_write_ov
-  , OPENSSL_malloc_ov
-  , OPENSSL_free_nonnull_1_ov
-  , OPENSSL_free_null_ov
-  , OPENSSL_cleanse_ov
-  ]
-  true
-  RSA_verify_pss_mgf1_spec
-  (do {
-    goal_eval_unint ["PSS_mgf1_verify", "processBlock_Common", "bn_mont_n0_with_N", "exp", "integerToBV", "integerFromBV"];
-    goal_num_ite 0
-      (w4_unint_z3 ["PSS_mgf1_verify", "processBlock_Common", "bn_mont_n0_with_N", "exp", "phi", "rad"])
-      (w4_unint_z3 ["PSS_mgf1_verify", "processBlock_Common", "bn_mont_n0_with_N", "exp", "phi", "rad", "integerToBV", "integerFromBV"]);
-  });
+  RSA_verify_pss_mgf1_spec;
```

And that's all for RSA.

Here are the elliptic curve-related functions that are currently marked as `noinline`:

* Remove the uses of `noinline` for the following functions used in the proof of `ECDSA_do_sign`:
  * [X] `ec_scalar_from_montgomery` (shared in common with `ECDSA_do_verify`)

    ```c
    void ec_scalar_from_montgomery(const EC_GROUP *group, EC_SCALAR *r,
                                   const EC_SCALAR *a) {
      const BIGNUM *order = &group->order;
      bn_from_montgomery_small(r->words, order->width, a->words, order->width,
                               group->order_mont);
    }
    ```

  * [X] `ec_scalar_mul_montgomery` (shared in common with `ECDSA_do_verify`)

    ```c
    void ec_scalar_mul_montgomery(const EC_GROUP *group, EC_SCALAR *r,
                                  const EC_SCALAR *a, const EC_SCALAR *b) {
      const BIGNUM *order = &group->order;
      bn_mod_mul_montgomery_small(r->words, a->words, b->words, order->width,
                                  group->order_mont);
    }
    ```
  * [X] `ec_scalar_to_montgomery`

    ```c
    void ec_scalar_to_montgomery(const EC_GROUP *group, EC_SCALAR *r,
                                 const EC_SCALAR *a) {
      const BIGNUM *order = &group->order;
      bn_to_montgomery_small(r->words, a->words, order->width, group->order_mont);
    }

    void bn_to_montgomery_small(BN_ULONG *r, const BN_ULONG *a, size_t num,
                                const BN_MONT_CTX *mont) {
      bn_mod_mul_montgomery_small(r, a, mont->RR.d, num, mont);
    }
    ```
  * [X] `ec_point_mul_scalar_base`

    ```c
    int ec_point_mul_scalar_base(const EC_GROUP *group, EC_RAW_POINT *r,
                                 const EC_SCALAR *scalar) {
      if (scalar == NULL) {
        OPENSSL_PUT_ERROR(EC, ERR_R_PASSED_NULL_PARAMETER);
        return 0;
      }

      group->meth->mul_base(group, r, scalar);

      // Check the result is on the curve to defend against fault attacks or bugs.
      // This has negligible cost compared to the multiplication.
      if (!ec_GFp_simple_is_on_curve(group, r)) {
        OPENSSL_PUT_ERROR(EC, ERR_R_INTERNAL_ERROR);
        return 0;
      }

      return 1;
    }
    ```

    TODO RGS: Figure out what `group->meth->mul_base` resolves to
  * [ ] `ec_scalar_add`

    ```c
    void ec_scalar_add(const EC_GROUP *group, EC_SCALAR *r, const EC_SCALAR *a,
                       const EC_SCALAR *b) {
      const BIGNUM *order = &group->order;
      BN_ULONG tmp[EC_MAX_WORDS];
      bn_mod_add_words(r->words, a->words, b->words, order->d, tmp, order->width);
      OPENSSL_cleanse(tmp, sizeof(tmp));
    }
    ```
  * [ ] `ec_scalar_is_zero`

    ```c
    int ec_scalar_is_zero(const EC_GROUP *group, const EC_SCALAR *a) {
      BN_ULONG mask = 0;
      for (int i = 0; i < group->order.width; i++) {
        mask |= a->words[i];
      }
      return mask == 0;
    }
    ```
* Remove the uses of `noinline` for the following functions used in the proof of `ECDSA_do_verify`:
  * [X] `ec_scalar_from_montgomery` (shared in common with `ECDSA_do_sign`)
  * [X] `ec_scalar_mul_montgomery` (shared in common with `ECDSA_do_sign`)
  * [ ] `ec_cmp_x_coordinate`

    ```c
    int ec_cmp_x_coordinate(const EC_GROUP *group, const EC_RAW_POINT *p,
                            const EC_SCALAR *r) {
      return group->meth->cmp_x_coordinate(group, p, r);
    }
    ```

    TODO RGS: Figure out what `group->meth->cmp_x_coordinate` resolves to
  * [ ] `ec_point_mul_scalar_public`

    ```c
    int ec_point_mul_scalar_public(const EC_GROUP *group, EC_RAW_POINT *r,
                                   const EC_SCALAR *g_scalar, const EC_RAW_POINT *p,
                                   const EC_SCALAR *p_scalar) {
      if (g_scalar == NULL || p_scalar == NULL || p == NULL) {
        OPENSSL_PUT_ERROR(EC, ERR_R_PASSED_NULL_PARAMETER);
        return 0;
      }

      if (group->meth->mul_public == NULL) {
        return group->meth->mul_public_batch(group, r, g_scalar, p, p_scalar, 1);
      }

      group->meth->mul_public(group, r, g_scalar, p, p_scalar);
      return 1;
    }
    ```

    TODO RGS: Figure out what `group->meth->mul_public{,_batch}` resolve to
